// Code generated by Thrift Compiler (0.18.1). DO NOT EDIT.

package hbase

import (
	"bytes"
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	thrift "github.com/apache/thrift/lib/go/thrift"
	"regexp"
	"strings"
	"time"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = errors.New
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

// (needed by validator.)
var _ = strings.Contains
var _ = regexp.MatchString

// Specify type of delete:
// - DELETE_COLUMN means exactly one version will be removed,
// - DELETE_COLUMNS means previous versions will also be removed.
type TDeleteType int64

const (
	TDeleteType_DELETE_COLUMN         TDeleteType = 0
	TDeleteType_DELETE_COLUMNS        TDeleteType = 1
	TDeleteType_DELETE_FAMILY         TDeleteType = 2
	TDeleteType_DELETE_FAMILY_VERSION TDeleteType = 3
)

func (p TDeleteType) String() string {
	switch p {
	case TDeleteType_DELETE_COLUMN:
		return "DELETE_COLUMN"
	case TDeleteType_DELETE_COLUMNS:
		return "DELETE_COLUMNS"
	case TDeleteType_DELETE_FAMILY:
		return "DELETE_FAMILY"
	case TDeleteType_DELETE_FAMILY_VERSION:
		return "DELETE_FAMILY_VERSION"
	}
	return "<UNSET>"
}

func TDeleteTypeFromString(s string) (TDeleteType, error) {
	switch s {
	case "DELETE_COLUMN":
		return TDeleteType_DELETE_COLUMN, nil
	case "DELETE_COLUMNS":
		return TDeleteType_DELETE_COLUMNS, nil
	case "DELETE_FAMILY":
		return TDeleteType_DELETE_FAMILY, nil
	case "DELETE_FAMILY_VERSION":
		return TDeleteType_DELETE_FAMILY_VERSION, nil
	}
	return TDeleteType(0), fmt.Errorf("not a valid TDeleteType string")
}

func TDeleteTypePtr(v TDeleteType) *TDeleteType { return &v }

func (p TDeleteType) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TDeleteType) UnmarshalText(text []byte) error {
	q, err := TDeleteTypeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TDeleteType) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TDeleteType(v)
	return nil
}

func (p *TDeleteType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

// Specify Durability:
// - SKIP_WAL means do not write the Mutation to the WAL.
// - ASYNC_WAL means write the Mutation to the WAL asynchronously,
// - SYNC_WAL means write the Mutation to the WAL synchronously,
// - FSYNC_WAL means Write the Mutation to the WAL synchronously and force the entries to disk.
type TDurability int64

const (
	TDurability_USE_DEFAULT TDurability = 0
	TDurability_SKIP_WAL    TDurability = 1
	TDurability_ASYNC_WAL   TDurability = 2
	TDurability_SYNC_WAL    TDurability = 3
	TDurability_FSYNC_WAL   TDurability = 4
)

func (p TDurability) String() string {
	switch p {
	case TDurability_USE_DEFAULT:
		return "USE_DEFAULT"
	case TDurability_SKIP_WAL:
		return "SKIP_WAL"
	case TDurability_ASYNC_WAL:
		return "ASYNC_WAL"
	case TDurability_SYNC_WAL:
		return "SYNC_WAL"
	case TDurability_FSYNC_WAL:
		return "FSYNC_WAL"
	}
	return "<UNSET>"
}

func TDurabilityFromString(s string) (TDurability, error) {
	switch s {
	case "USE_DEFAULT":
		return TDurability_USE_DEFAULT, nil
	case "SKIP_WAL":
		return TDurability_SKIP_WAL, nil
	case "ASYNC_WAL":
		return TDurability_ASYNC_WAL, nil
	case "SYNC_WAL":
		return TDurability_SYNC_WAL, nil
	case "FSYNC_WAL":
		return TDurability_FSYNC_WAL, nil
	}
	return TDurability(0), fmt.Errorf("not a valid TDurability string")
}

func TDurabilityPtr(v TDurability) *TDurability { return &v }

func (p TDurability) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TDurability) UnmarshalText(text []byte) error {
	q, err := TDurabilityFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TDurability) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TDurability(v)
	return nil
}

func (p *TDurability) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

// Specify Consistency:
// - STRONG means reads only from primary region
// - TIMELINE means reads might return values from secondary region replicas
type TConsistency int64

const (
	TConsistency_STRONG   TConsistency = 1
	TConsistency_TIMELINE TConsistency = 2
)

func (p TConsistency) String() string {
	switch p {
	case TConsistency_STRONG:
		return "STRONG"
	case TConsistency_TIMELINE:
		return "TIMELINE"
	}
	return "<UNSET>"
}

func TConsistencyFromString(s string) (TConsistency, error) {
	switch s {
	case "STRONG":
		return TConsistency_STRONG, nil
	case "TIMELINE":
		return TConsistency_TIMELINE, nil
	}
	return TConsistency(0), fmt.Errorf("not a valid TConsistency string")
}

func TConsistencyPtr(v TConsistency) *TConsistency { return &v }

func (p TConsistency) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TConsistency) UnmarshalText(text []byte) error {
	q, err := TConsistencyFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TConsistency) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TConsistency(v)
	return nil
}

func (p *TConsistency) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type TReadType int64

const (
	TReadType_DEFAULT TReadType = 1
	TReadType_STREAM  TReadType = 2
	TReadType_PREAD   TReadType = 3
)

func (p TReadType) String() string {
	switch p {
	case TReadType_DEFAULT:
		return "DEFAULT"
	case TReadType_STREAM:
		return "STREAM"
	case TReadType_PREAD:
		return "PREAD"
	}
	return "<UNSET>"
}

func TReadTypeFromString(s string) (TReadType, error) {
	switch s {
	case "DEFAULT":
		return TReadType_DEFAULT, nil
	case "STREAM":
		return TReadType_STREAM, nil
	case "PREAD":
		return TReadType_PREAD, nil
	}
	return TReadType(0), fmt.Errorf("not a valid TReadType string")
}

func TReadTypePtr(v TReadType) *TReadType { return &v }

func (p TReadType) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TReadType) UnmarshalText(text []byte) error {
	q, err := TReadTypeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TReadType) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TReadType(v)
	return nil
}

func (p *TReadType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

// Thrift wrapper around
// org.apache.hadoop.hbase.filter.CompareFilter$CompareOp.
type TCompareOp int64

const (
	TCompareOp_LESS             TCompareOp = 0
	TCompareOp_LESS_OR_EQUAL    TCompareOp = 1
	TCompareOp_EQUAL            TCompareOp = 2
	TCompareOp_NOT_EQUAL        TCompareOp = 3
	TCompareOp_GREATER_OR_EQUAL TCompareOp = 4
	TCompareOp_GREATER          TCompareOp = 5
	TCompareOp_NO_OP            TCompareOp = 6
)

func (p TCompareOp) String() string {
	switch p {
	case TCompareOp_LESS:
		return "LESS"
	case TCompareOp_LESS_OR_EQUAL:
		return "LESS_OR_EQUAL"
	case TCompareOp_EQUAL:
		return "EQUAL"
	case TCompareOp_NOT_EQUAL:
		return "NOT_EQUAL"
	case TCompareOp_GREATER_OR_EQUAL:
		return "GREATER_OR_EQUAL"
	case TCompareOp_GREATER:
		return "GREATER"
	case TCompareOp_NO_OP:
		return "NO_OP"
	}
	return "<UNSET>"
}

func TCompareOpFromString(s string) (TCompareOp, error) {
	switch s {
	case "LESS":
		return TCompareOp_LESS, nil
	case "LESS_OR_EQUAL":
		return TCompareOp_LESS_OR_EQUAL, nil
	case "EQUAL":
		return TCompareOp_EQUAL, nil
	case "NOT_EQUAL":
		return TCompareOp_NOT_EQUAL, nil
	case "GREATER_OR_EQUAL":
		return TCompareOp_GREATER_OR_EQUAL, nil
	case "GREATER":
		return TCompareOp_GREATER, nil
	case "NO_OP":
		return TCompareOp_NO_OP, nil
	}
	return TCompareOp(0), fmt.Errorf("not a valid TCompareOp string")
}

func TCompareOpPtr(v TCompareOp) *TCompareOp { return &v }

func (p TCompareOp) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TCompareOp) UnmarshalText(text []byte) error {
	q, err := TCompareOpFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TCompareOp) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TCompareOp(v)
	return nil
}

func (p *TCompareOp) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

// Thrift wrapper around
// org.apache.hadoop.hbase.regionserver.BloomType
type TBloomFilterType int64

const (
	TBloomFilterType_NONE                   TBloomFilterType = 0
	TBloomFilterType_ROW                    TBloomFilterType = 1
	TBloomFilterType_ROWCOL                 TBloomFilterType = 2
	TBloomFilterType_ROWPREFIX_FIXED_LENGTH TBloomFilterType = 3
)

func (p TBloomFilterType) String() string {
	switch p {
	case TBloomFilterType_NONE:
		return "NONE"
	case TBloomFilterType_ROW:
		return "ROW"
	case TBloomFilterType_ROWCOL:
		return "ROWCOL"
	case TBloomFilterType_ROWPREFIX_FIXED_LENGTH:
		return "ROWPREFIX_FIXED_LENGTH"
	}
	return "<UNSET>"
}

func TBloomFilterTypeFromString(s string) (TBloomFilterType, error) {
	switch s {
	case "NONE":
		return TBloomFilterType_NONE, nil
	case "ROW":
		return TBloomFilterType_ROW, nil
	case "ROWCOL":
		return TBloomFilterType_ROWCOL, nil
	case "ROWPREFIX_FIXED_LENGTH":
		return TBloomFilterType_ROWPREFIX_FIXED_LENGTH, nil
	}
	return TBloomFilterType(0), fmt.Errorf("not a valid TBloomFilterType string")
}

func TBloomFilterTypePtr(v TBloomFilterType) *TBloomFilterType { return &v }

func (p TBloomFilterType) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TBloomFilterType) UnmarshalText(text []byte) error {
	q, err := TBloomFilterTypeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TBloomFilterType) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TBloomFilterType(v)
	return nil
}

func (p *TBloomFilterType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

// Thrift wrapper around
// org.apache.hadoop.hbase.io.compress.Algorithm
type TCompressionAlgorithm int64

const (
	TCompressionAlgorithm_LZO    TCompressionAlgorithm = 0
	TCompressionAlgorithm_GZ     TCompressionAlgorithm = 1
	TCompressionAlgorithm_NONE   TCompressionAlgorithm = 2
	TCompressionAlgorithm_SNAPPY TCompressionAlgorithm = 3
	TCompressionAlgorithm_LZ4    TCompressionAlgorithm = 4
	TCompressionAlgorithm_BZIP2  TCompressionAlgorithm = 5
	TCompressionAlgorithm_ZSTD   TCompressionAlgorithm = 6
)

func (p TCompressionAlgorithm) String() string {
	switch p {
	case TCompressionAlgorithm_LZO:
		return "LZO"
	case TCompressionAlgorithm_GZ:
		return "GZ"
	case TCompressionAlgorithm_NONE:
		return "NONE"
	case TCompressionAlgorithm_SNAPPY:
		return "SNAPPY"
	case TCompressionAlgorithm_LZ4:
		return "LZ4"
	case TCompressionAlgorithm_BZIP2:
		return "BZIP2"
	case TCompressionAlgorithm_ZSTD:
		return "ZSTD"
	}
	return "<UNSET>"
}

func TCompressionAlgorithmFromString(s string) (TCompressionAlgorithm, error) {
	switch s {
	case "LZO":
		return TCompressionAlgorithm_LZO, nil
	case "GZ":
		return TCompressionAlgorithm_GZ, nil
	case "NONE":
		return TCompressionAlgorithm_NONE, nil
	case "SNAPPY":
		return TCompressionAlgorithm_SNAPPY, nil
	case "LZ4":
		return TCompressionAlgorithm_LZ4, nil
	case "BZIP2":
		return TCompressionAlgorithm_BZIP2, nil
	case "ZSTD":
		return TCompressionAlgorithm_ZSTD, nil
	}
	return TCompressionAlgorithm(0), fmt.Errorf("not a valid TCompressionAlgorithm string")
}

func TCompressionAlgorithmPtr(v TCompressionAlgorithm) *TCompressionAlgorithm { return &v }

func (p TCompressionAlgorithm) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TCompressionAlgorithm) UnmarshalText(text []byte) error {
	q, err := TCompressionAlgorithmFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TCompressionAlgorithm) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TCompressionAlgorithm(v)
	return nil
}

func (p *TCompressionAlgorithm) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

// Thrift wrapper around
// org.apache.hadoop.hbase.io.encoding.DataBlockEncoding
type TDataBlockEncoding int64

const (
	TDataBlockEncoding_NONE         TDataBlockEncoding = 0
	TDataBlockEncoding_PREFIX       TDataBlockEncoding = 2
	TDataBlockEncoding_DIFF         TDataBlockEncoding = 3
	TDataBlockEncoding_FAST_DIFF    TDataBlockEncoding = 4
	TDataBlockEncoding_ROW_INDEX_V1 TDataBlockEncoding = 7
)

func (p TDataBlockEncoding) String() string {
	switch p {
	case TDataBlockEncoding_NONE:
		return "NONE"
	case TDataBlockEncoding_PREFIX:
		return "PREFIX"
	case TDataBlockEncoding_DIFF:
		return "DIFF"
	case TDataBlockEncoding_FAST_DIFF:
		return "FAST_DIFF"
	case TDataBlockEncoding_ROW_INDEX_V1:
		return "ROW_INDEX_V1"
	}
	return "<UNSET>"
}

func TDataBlockEncodingFromString(s string) (TDataBlockEncoding, error) {
	switch s {
	case "NONE":
		return TDataBlockEncoding_NONE, nil
	case "PREFIX":
		return TDataBlockEncoding_PREFIX, nil
	case "DIFF":
		return TDataBlockEncoding_DIFF, nil
	case "FAST_DIFF":
		return TDataBlockEncoding_FAST_DIFF, nil
	case "ROW_INDEX_V1":
		return TDataBlockEncoding_ROW_INDEX_V1, nil
	}
	return TDataBlockEncoding(0), fmt.Errorf("not a valid TDataBlockEncoding string")
}

func TDataBlockEncodingPtr(v TDataBlockEncoding) *TDataBlockEncoding { return &v }

func (p TDataBlockEncoding) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TDataBlockEncoding) UnmarshalText(text []byte) error {
	q, err := TDataBlockEncodingFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TDataBlockEncoding) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TDataBlockEncoding(v)
	return nil
}

func (p *TDataBlockEncoding) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

// Thrift wrapper around
// org.apache.hadoop.hbase.KeepDeletedCells
type TKeepDeletedCells int64

const (
	TKeepDeletedCells_FALSE TKeepDeletedCells = 0
	TKeepDeletedCells_TRUE  TKeepDeletedCells = 1
	TKeepDeletedCells_TTL   TKeepDeletedCells = 2
)

func (p TKeepDeletedCells) String() string {
	switch p {
	case TKeepDeletedCells_FALSE:
		return "FALSE"
	case TKeepDeletedCells_TRUE:
		return "TRUE"
	case TKeepDeletedCells_TTL:
		return "TTL"
	}
	return "<UNSET>"
}

func TKeepDeletedCellsFromString(s string) (TKeepDeletedCells, error) {
	switch s {
	case "FALSE":
		return TKeepDeletedCells_FALSE, nil
	case "TRUE":
		return TKeepDeletedCells_TRUE, nil
	case "TTL":
		return TKeepDeletedCells_TTL, nil
	}
	return TKeepDeletedCells(0), fmt.Errorf("not a valid TKeepDeletedCells string")
}

func TKeepDeletedCellsPtr(v TKeepDeletedCells) *TKeepDeletedCells { return &v }

func (p TKeepDeletedCells) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TKeepDeletedCells) UnmarshalText(text []byte) error {
	q, err := TKeepDeletedCellsFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TKeepDeletedCells) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TKeepDeletedCells(v)
	return nil
}

func (p *TKeepDeletedCells) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

// Attributes:
//   - MinStamp
//   - MaxStamp
type TTimeRange struct {
	MinStamp int64 `thrift:"minStamp,1,required" db:"minStamp" json:"minStamp"`
	MaxStamp int64 `thrift:"maxStamp,2,required" db:"maxStamp" json:"maxStamp"`
}

func NewTTimeRange() *TTimeRange {
	return &TTimeRange{}
}

func (p *TTimeRange) GetMinStamp() int64 {
	return p.MinStamp
}

func (p *TTimeRange) GetMaxStamp() int64 {
	return p.MaxStamp
}
func (p *TTimeRange) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetMinStamp bool = false
	var issetMaxStamp bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetMinStamp = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetMaxStamp = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetMinStamp {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field MinStamp is not set"))
	}
	if !issetMaxStamp {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field MaxStamp is not set"))
	}
	return nil
}

func (p *TTimeRange) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.MinStamp = v
	}
	return nil
}

func (p *TTimeRange) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.MaxStamp = v
	}
	return nil
}

func (p *TTimeRange) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TTimeRange"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TTimeRange) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "minStamp", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:minStamp: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.MinStamp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.minStamp (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:minStamp: ", p), err)
	}
	return err
}

func (p *TTimeRange) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "maxStamp", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:maxStamp: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.MaxStamp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.maxStamp (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:maxStamp: ", p), err)
	}
	return err
}

func (p *TTimeRange) Equals(other *TTimeRange) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.MinStamp != other.MinStamp {
		return false
	}
	if p.MaxStamp != other.MaxStamp {
		return false
	}
	return true
}

func (p *TTimeRange) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TTimeRange(%+v)", *p)
}

func (p *TTimeRange) Validate() error {
	return nil
}

// Addresses a single cell or multiple cells
// in a HBase table by column family and optionally
// a column qualifier and timestamp
//
// Attributes:
//   - Family
//   - Qualifier
//   - Timestamp
type TColumn struct {
	Family    []byte `thrift:"family,1,required" db:"family" json:"family"`
	Qualifier []byte `thrift:"qualifier,2" db:"qualifier" json:"qualifier,omitempty"`
	Timestamp *int64 `thrift:"timestamp,3" db:"timestamp" json:"timestamp,omitempty"`
}

func NewTColumn() *TColumn {
	return &TColumn{}
}

func (p *TColumn) GetFamily() []byte {
	return p.Family
}

var TColumn_Qualifier_DEFAULT []byte

func (p *TColumn) GetQualifier() []byte {
	return p.Qualifier
}

var TColumn_Timestamp_DEFAULT int64

func (p *TColumn) GetTimestamp() int64 {
	if !p.IsSetTimestamp() {
		return TColumn_Timestamp_DEFAULT
	}
	return *p.Timestamp
}
func (p *TColumn) IsSetQualifier() bool {
	return p.Qualifier != nil
}

func (p *TColumn) IsSetTimestamp() bool {
	return p.Timestamp != nil
}

func (p *TColumn) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetFamily bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetFamily = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetFamily {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Family is not set"))
	}
	return nil
}

func (p *TColumn) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Family = v
	}
	return nil
}

func (p *TColumn) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Qualifier = v
	}
	return nil
}

func (p *TColumn) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Timestamp = &v
	}
	return nil
}

func (p *TColumn) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TColumn"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TColumn) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "family", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:family: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Family); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.family (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:family: ", p), err)
	}
	return err
}

func (p *TColumn) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetQualifier() {
		if err := oprot.WriteFieldBegin(ctx, "qualifier", thrift.STRING, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:qualifier: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.Qualifier); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.qualifier (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:qualifier: ", p), err)
		}
	}
	return err
}

func (p *TColumn) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetTimestamp() {
		if err := oprot.WriteFieldBegin(ctx, "timestamp", thrift.I64, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:timestamp: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.Timestamp)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.timestamp (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:timestamp: ", p), err)
		}
	}
	return err
}

func (p *TColumn) Equals(other *TColumn) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.Family, other.Family) != 0 {
		return false
	}
	if bytes.Compare(p.Qualifier, other.Qualifier) != 0 {
		return false
	}
	if p.Timestamp != other.Timestamp {
		if p.Timestamp == nil || other.Timestamp == nil {
			return false
		}
		if (*p.Timestamp) != (*other.Timestamp) {
			return false
		}
	}
	return true
}

func (p *TColumn) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TColumn(%+v)", *p)
}

func (p *TColumn) Validate() error {
	return nil
}

// Represents a single cell and its value.
//
// Attributes:
//   - Family
//   - Qualifier
//   - Value
//   - Timestamp
//   - Tags
//   - Type
type TColumnValue struct {
	Family    []byte `thrift:"family,1,required" db:"family" json:"family"`
	Qualifier []byte `thrift:"qualifier,2,required" db:"qualifier" json:"qualifier"`
	Value     []byte `thrift:"value,3,required" db:"value" json:"value"`
	Timestamp *int64 `thrift:"timestamp,4" db:"timestamp" json:"timestamp,omitempty"`
	Tags      []byte `thrift:"tags,5" db:"tags" json:"tags,omitempty"`
	Type      *int8  `thrift:"type,6" db:"type" json:"type,omitempty"`
}

func NewTColumnValue() *TColumnValue {
	return &TColumnValue{}
}

func (p *TColumnValue) GetFamily() []byte {
	return p.Family
}

func (p *TColumnValue) GetQualifier() []byte {
	return p.Qualifier
}

func (p *TColumnValue) GetValue() []byte {
	return p.Value
}

var TColumnValue_Timestamp_DEFAULT int64

func (p *TColumnValue) GetTimestamp() int64 {
	if !p.IsSetTimestamp() {
		return TColumnValue_Timestamp_DEFAULT
	}
	return *p.Timestamp
}

var TColumnValue_Tags_DEFAULT []byte

func (p *TColumnValue) GetTags() []byte {
	return p.Tags
}

var TColumnValue_Type_DEFAULT int8

func (p *TColumnValue) GetType() int8 {
	if !p.IsSetType() {
		return TColumnValue_Type_DEFAULT
	}
	return *p.Type
}
func (p *TColumnValue) IsSetTimestamp() bool {
	return p.Timestamp != nil
}

func (p *TColumnValue) IsSetTags() bool {
	return p.Tags != nil
}

func (p *TColumnValue) IsSetType() bool {
	return p.Type != nil
}

func (p *TColumnValue) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetFamily bool = false
	var issetQualifier bool = false
	var issetValue bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetFamily = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetQualifier = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetValue = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.BYTE {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetFamily {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Family is not set"))
	}
	if !issetQualifier {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Qualifier is not set"))
	}
	if !issetValue {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Value is not set"))
	}
	return nil
}

func (p *TColumnValue) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Family = v
	}
	return nil
}

func (p *TColumnValue) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Qualifier = v
	}
	return nil
}

func (p *TColumnValue) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *TColumnValue) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.Timestamp = &v
	}
	return nil
}

func (p *TColumnValue) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.Tags = v
	}
	return nil
}

func (p *TColumnValue) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadByte(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		temp := int8(v)
		p.Type = &temp
	}
	return nil
}

func (p *TColumnValue) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TColumnValue"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField4(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField5(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField6(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TColumnValue) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "family", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:family: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Family); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.family (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:family: ", p), err)
	}
	return err
}

func (p *TColumnValue) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "qualifier", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:qualifier: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Qualifier); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.qualifier (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:qualifier: ", p), err)
	}
	return err
}

func (p *TColumnValue) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:value: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Value); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.value (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:value: ", p), err)
	}
	return err
}

func (p *TColumnValue) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetTimestamp() {
		if err := oprot.WriteFieldBegin(ctx, "timestamp", thrift.I64, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:timestamp: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.Timestamp)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.timestamp (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:timestamp: ", p), err)
		}
	}
	return err
}

func (p *TColumnValue) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetTags() {
		if err := oprot.WriteFieldBegin(ctx, "tags", thrift.STRING, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:tags: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.Tags); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.tags (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:tags: ", p), err)
		}
	}
	return err
}

func (p *TColumnValue) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetType() {
		if err := oprot.WriteFieldBegin(ctx, "type", thrift.BYTE, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:type: ", p), err)
		}
		if err := oprot.WriteByte(ctx, int8(*p.Type)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.type (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:type: ", p), err)
		}
	}
	return err
}

func (p *TColumnValue) Equals(other *TColumnValue) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.Family, other.Family) != 0 {
		return false
	}
	if bytes.Compare(p.Qualifier, other.Qualifier) != 0 {
		return false
	}
	if bytes.Compare(p.Value, other.Value) != 0 {
		return false
	}
	if p.Timestamp != other.Timestamp {
		if p.Timestamp == nil || other.Timestamp == nil {
			return false
		}
		if (*p.Timestamp) != (*other.Timestamp) {
			return false
		}
	}
	if bytes.Compare(p.Tags, other.Tags) != 0 {
		return false
	}
	if p.Type != other.Type {
		if p.Type == nil || other.Type == nil {
			return false
		}
		if (*p.Type) != (*other.Type) {
			return false
		}
	}
	return true
}

func (p *TColumnValue) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TColumnValue(%+v)", *p)
}

func (p *TColumnValue) Validate() error {
	return nil
}

// Represents a single cell and the amount to increment it by
//
// Attributes:
//   - Family
//   - Qualifier
//   - Amount
type TColumnIncrement struct {
	Family    []byte `thrift:"family,1,required" db:"family" json:"family"`
	Qualifier []byte `thrift:"qualifier,2,required" db:"qualifier" json:"qualifier"`
	Amount    int64  `thrift:"amount,3" db:"amount" json:"amount"`
}

func NewTColumnIncrement() *TColumnIncrement {
	return &TColumnIncrement{
		Amount: 1,
	}
}

func (p *TColumnIncrement) GetFamily() []byte {
	return p.Family
}

func (p *TColumnIncrement) GetQualifier() []byte {
	return p.Qualifier
}

var TColumnIncrement_Amount_DEFAULT int64 = 1

func (p *TColumnIncrement) GetAmount() int64 {
	return p.Amount
}
func (p *TColumnIncrement) IsSetAmount() bool {
	return p.Amount != TColumnIncrement_Amount_DEFAULT
}

func (p *TColumnIncrement) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetFamily bool = false
	var issetQualifier bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetFamily = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetQualifier = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetFamily {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Family is not set"))
	}
	if !issetQualifier {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Qualifier is not set"))
	}
	return nil
}

func (p *TColumnIncrement) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Family = v
	}
	return nil
}

func (p *TColumnIncrement) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Qualifier = v
	}
	return nil
}

func (p *TColumnIncrement) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Amount = v
	}
	return nil
}

func (p *TColumnIncrement) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TColumnIncrement"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TColumnIncrement) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "family", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:family: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Family); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.family (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:family: ", p), err)
	}
	return err
}

func (p *TColumnIncrement) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "qualifier", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:qualifier: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Qualifier); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.qualifier (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:qualifier: ", p), err)
	}
	return err
}

func (p *TColumnIncrement) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetAmount() {
		if err := oprot.WriteFieldBegin(ctx, "amount", thrift.I64, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:amount: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(p.Amount)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.amount (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:amount: ", p), err)
		}
	}
	return err
}

func (p *TColumnIncrement) Equals(other *TColumnIncrement) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.Family, other.Family) != 0 {
		return false
	}
	if bytes.Compare(p.Qualifier, other.Qualifier) != 0 {
		return false
	}
	if p.Amount != other.Amount {
		return false
	}
	return true
}

func (p *TColumnIncrement) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TColumnIncrement(%+v)", *p)
}

func (p *TColumnIncrement) Validate() error {
	return nil
}

// if no Result is found, row and columnValues will not be set.
//
// Attributes:
//   - Row
//   - ColumnValues
//   - Stale
//   - Partial
type TResult_ struct {
	Row          []byte          `thrift:"row,1" db:"row" json:"row,omitempty"`
	ColumnValues []*TColumnValue `thrift:"columnValues,2,required" db:"columnValues" json:"columnValues"`
	Stale        bool            `thrift:"stale,3" db:"stale" json:"stale"`
	Partial      bool            `thrift:"partial,4" db:"partial" json:"partial"`
}

func NewTResult_() *TResult_ {
	return &TResult_{}
}

var TResult__Row_DEFAULT []byte

func (p *TResult_) GetRow() []byte {
	return p.Row
}

func (p *TResult_) GetColumnValues() []*TColumnValue {
	return p.ColumnValues
}

var TResult__Stale_DEFAULT bool = false

func (p *TResult_) GetStale() bool {
	return p.Stale
}

var TResult__Partial_DEFAULT bool = false

func (p *TResult_) GetPartial() bool {
	return p.Partial
}
func (p *TResult_) IsSetRow() bool {
	return p.Row != nil
}

func (p *TResult_) IsSetStale() bool {
	return p.Stale != TResult__Stale_DEFAULT
}

func (p *TResult_) IsSetPartial() bool {
	return p.Partial != TResult__Partial_DEFAULT
}

func (p *TResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetColumnValues bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetColumnValues = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetColumnValues {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnValues is not set"))
	}
	return nil
}

func (p *TResult_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *TResult_) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TColumnValue, 0, size)
	p.ColumnValues = tSlice
	for i := 0; i < size; i++ {
		_elem0 := &TColumnValue{}
		if err := _elem0.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem0), err)
		}
		p.ColumnValues = append(p.ColumnValues, _elem0)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *TResult_) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Stale = v
	}
	return nil
}

func (p *TResult_) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.Partial = v
	}
	return nil
}

func (p *TResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField4(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetRow() {
		if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:row: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.Row); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.row (1) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:row: ", p), err)
		}
	}
	return err
}

func (p *TResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "columnValues", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columnValues: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.ColumnValues)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.ColumnValues {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columnValues: ", p), err)
	}
	return err
}

func (p *TResult_) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetStale() {
		if err := oprot.WriteFieldBegin(ctx, "stale", thrift.BOOL, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:stale: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(p.Stale)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.stale (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:stale: ", p), err)
		}
	}
	return err
}

func (p *TResult_) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetPartial() {
		if err := oprot.WriteFieldBegin(ctx, "partial", thrift.BOOL, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:partial: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(p.Partial)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.partial (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:partial: ", p), err)
		}
	}
	return err
}

func (p *TResult_) Equals(other *TResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.Row, other.Row) != 0 {
		return false
	}
	if len(p.ColumnValues) != len(other.ColumnValues) {
		return false
	}
	for i, _tgt := range p.ColumnValues {
		_src1 := other.ColumnValues[i]
		if !_tgt.Equals(_src1) {
			return false
		}
	}
	if p.Stale != other.Stale {
		return false
	}
	if p.Partial != other.Partial {
		return false
	}
	return true
}

func (p *TResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TResult_(%+v)", *p)
}

func (p *TResult_) Validate() error {
	return nil
}

// Attributes:
//   - Labels
type TAuthorization struct {
	Labels []string `thrift:"labels,1" db:"labels" json:"labels,omitempty"`
}

func NewTAuthorization() *TAuthorization {
	return &TAuthorization{}
}

var TAuthorization_Labels_DEFAULT []string

func (p *TAuthorization) GetLabels() []string {
	return p.Labels
}
func (p *TAuthorization) IsSetLabels() bool {
	return p.Labels != nil
}

func (p *TAuthorization) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TAuthorization) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]string, 0, size)
	p.Labels = tSlice
	for i := 0; i < size; i++ {
		var _elem2 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem2 = v
		}
		p.Labels = append(p.Labels, _elem2)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *TAuthorization) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TAuthorization"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TAuthorization) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetLabels() {
		if err := oprot.WriteFieldBegin(ctx, "labels", thrift.LIST, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:labels: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Labels)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Labels {
			if err := oprot.WriteString(ctx, string(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:labels: ", p), err)
		}
	}
	return err
}

func (p *TAuthorization) Equals(other *TAuthorization) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.Labels) != len(other.Labels) {
		return false
	}
	for i, _tgt := range p.Labels {
		_src3 := other.Labels[i]
		if _tgt != _src3 {
			return false
		}
	}
	return true
}

func (p *TAuthorization) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TAuthorization(%+v)", *p)
}

func (p *TAuthorization) Validate() error {
	return nil
}

// Attributes:
//   - Expression
type TCellVisibility struct {
	Expression *string `thrift:"expression,1" db:"expression" json:"expression,omitempty"`
}

func NewTCellVisibility() *TCellVisibility {
	return &TCellVisibility{}
}

var TCellVisibility_Expression_DEFAULT string

func (p *TCellVisibility) GetExpression() string {
	if !p.IsSetExpression() {
		return TCellVisibility_Expression_DEFAULT
	}
	return *p.Expression
}
func (p *TCellVisibility) IsSetExpression() bool {
	return p.Expression != nil
}

func (p *TCellVisibility) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TCellVisibility) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Expression = &v
	}
	return nil
}

func (p *TCellVisibility) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TCellVisibility"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TCellVisibility) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetExpression() {
		if err := oprot.WriteFieldBegin(ctx, "expression", thrift.STRING, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:expression: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.Expression)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.expression (1) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:expression: ", p), err)
		}
	}
	return err
}

func (p *TCellVisibility) Equals(other *TCellVisibility) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Expression != other.Expression {
		if p.Expression == nil || other.Expression == nil {
			return false
		}
		if (*p.Expression) != (*other.Expression) {
			return false
		}
	}
	return true
}

func (p *TCellVisibility) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TCellVisibility(%+v)", *p)
}

func (p *TCellVisibility) Validate() error {
	return nil
}

// Used to perform Get operations on a single row.
//
// The scope can be further narrowed down by specifying a list of
// columns or column families.
//
// To get everything for a row, instantiate a Get object with just the row to get.
// To further define the scope of what to get you can add a timestamp or time range
// with an optional maximum number of versions to return.
//
// If you specify a time range and a timestamp the range is ignored.
// Timestamps on TColumns are ignored.
//
// Attributes:
//   - Row
//   - Columns
//   - Timestamp
//   - TimeRange
//   - MaxVersions
//   - FilterString
//   - Attributes
//   - Authorizations
//   - Consistency
//   - TargetReplicaId
//   - CacheBlocks
//   - StoreLimit
//   - StoreOffset
//   - ExistenceOnly
//   - FilterBytes
type TGet struct {
	Row             []byte            `thrift:"row,1,required" db:"row" json:"row"`
	Columns         []*TColumn        `thrift:"columns,2" db:"columns" json:"columns,omitempty"`
	Timestamp       *int64            `thrift:"timestamp,3" db:"timestamp" json:"timestamp,omitempty"`
	TimeRange       *TTimeRange       `thrift:"timeRange,4" db:"timeRange" json:"timeRange,omitempty"`
	MaxVersions     *int32            `thrift:"maxVersions,5" db:"maxVersions" json:"maxVersions,omitempty"`
	FilterString    []byte            `thrift:"filterString,6" db:"filterString" json:"filterString,omitempty"`
	Attributes      map[string][]byte `thrift:"attributes,7" db:"attributes" json:"attributes,omitempty"`
	Authorizations  *TAuthorization   `thrift:"authorizations,8" db:"authorizations" json:"authorizations,omitempty"`
	Consistency     *TConsistency     `thrift:"consistency,9" db:"consistency" json:"consistency,omitempty"`
	TargetReplicaId *int32            `thrift:"targetReplicaId,10" db:"targetReplicaId" json:"targetReplicaId,omitempty"`
	CacheBlocks     *bool             `thrift:"cacheBlocks,11" db:"cacheBlocks" json:"cacheBlocks,omitempty"`
	StoreLimit      *int32            `thrift:"storeLimit,12" db:"storeLimit" json:"storeLimit,omitempty"`
	StoreOffset     *int32            `thrift:"storeOffset,13" db:"storeOffset" json:"storeOffset,omitempty"`
	ExistenceOnly   *bool             `thrift:"existence_only,14" db:"existence_only" json:"existence_only,omitempty"`
	FilterBytes     []byte            `thrift:"filterBytes,15" db:"filterBytes" json:"filterBytes,omitempty"`
}

func NewTGet() *TGet {
	return &TGet{}
}

func (p *TGet) GetRow() []byte {
	return p.Row
}

var TGet_Columns_DEFAULT []*TColumn

func (p *TGet) GetColumns() []*TColumn {
	return p.Columns
}

var TGet_Timestamp_DEFAULT int64

func (p *TGet) GetTimestamp() int64 {
	if !p.IsSetTimestamp() {
		return TGet_Timestamp_DEFAULT
	}
	return *p.Timestamp
}

var TGet_TimeRange_DEFAULT *TTimeRange

func (p *TGet) GetTimeRange() *TTimeRange {
	if !p.IsSetTimeRange() {
		return TGet_TimeRange_DEFAULT
	}
	return p.TimeRange
}

var TGet_MaxVersions_DEFAULT int32

func (p *TGet) GetMaxVersions() int32 {
	if !p.IsSetMaxVersions() {
		return TGet_MaxVersions_DEFAULT
	}
	return *p.MaxVersions
}

var TGet_FilterString_DEFAULT []byte

func (p *TGet) GetFilterString() []byte {
	return p.FilterString
}

var TGet_Attributes_DEFAULT map[string][]byte

func (p *TGet) GetAttributes() map[string][]byte {
	return p.Attributes
}

var TGet_Authorizations_DEFAULT *TAuthorization

func (p *TGet) GetAuthorizations() *TAuthorization {
	if !p.IsSetAuthorizations() {
		return TGet_Authorizations_DEFAULT
	}
	return p.Authorizations
}

var TGet_Consistency_DEFAULT TConsistency

func (p *TGet) GetConsistency() TConsistency {
	if !p.IsSetConsistency() {
		return TGet_Consistency_DEFAULT
	}
	return *p.Consistency
}

var TGet_TargetReplicaId_DEFAULT int32

func (p *TGet) GetTargetReplicaId() int32 {
	if !p.IsSetTargetReplicaId() {
		return TGet_TargetReplicaId_DEFAULT
	}
	return *p.TargetReplicaId
}

var TGet_CacheBlocks_DEFAULT bool

func (p *TGet) GetCacheBlocks() bool {
	if !p.IsSetCacheBlocks() {
		return TGet_CacheBlocks_DEFAULT
	}
	return *p.CacheBlocks
}

var TGet_StoreLimit_DEFAULT int32

func (p *TGet) GetStoreLimit() int32 {
	if !p.IsSetStoreLimit() {
		return TGet_StoreLimit_DEFAULT
	}
	return *p.StoreLimit
}

var TGet_StoreOffset_DEFAULT int32

func (p *TGet) GetStoreOffset() int32 {
	if !p.IsSetStoreOffset() {
		return TGet_StoreOffset_DEFAULT
	}
	return *p.StoreOffset
}

var TGet_ExistenceOnly_DEFAULT bool

func (p *TGet) GetExistenceOnly() bool {
	if !p.IsSetExistenceOnly() {
		return TGet_ExistenceOnly_DEFAULT
	}
	return *p.ExistenceOnly
}

var TGet_FilterBytes_DEFAULT []byte

func (p *TGet) GetFilterBytes() []byte {
	return p.FilterBytes
}
func (p *TGet) IsSetColumns() bool {
	return p.Columns != nil
}

func (p *TGet) IsSetTimestamp() bool {
	return p.Timestamp != nil
}

func (p *TGet) IsSetTimeRange() bool {
	return p.TimeRange != nil
}

func (p *TGet) IsSetMaxVersions() bool {
	return p.MaxVersions != nil
}

func (p *TGet) IsSetFilterString() bool {
	return p.FilterString != nil
}

func (p *TGet) IsSetAttributes() bool {
	return p.Attributes != nil
}

func (p *TGet) IsSetAuthorizations() bool {
	return p.Authorizations != nil
}

func (p *TGet) IsSetConsistency() bool {
	return p.Consistency != nil
}

func (p *TGet) IsSetTargetReplicaId() bool {
	return p.TargetReplicaId != nil
}

func (p *TGet) IsSetCacheBlocks() bool {
	return p.CacheBlocks != nil
}

func (p *TGet) IsSetStoreLimit() bool {
	return p.StoreLimit != nil
}

func (p *TGet) IsSetStoreOffset() bool {
	return p.StoreOffset != nil
}

func (p *TGet) IsSetExistenceOnly() bool {
	return p.ExistenceOnly != nil
}

func (p *TGet) IsSetFilterBytes() bool {
	return p.FilterBytes != nil
}

func (p *TGet) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetRow bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetRow = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 8:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField8(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 9:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField9(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 10:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField10(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 11:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField11(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 12:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField12(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 13:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField13(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 14:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField14(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 15:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField15(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetRow {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"))
	}
	return nil
}

func (p *TGet) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *TGet) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TColumn, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		_elem4 := &TColumn{}
		if err := _elem4.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem4), err)
		}
		p.Columns = append(p.Columns, _elem4)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *TGet) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Timestamp = &v
	}
	return nil
}

func (p *TGet) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	p.TimeRange = &TTimeRange{}
	if err := p.TimeRange.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TimeRange), err)
	}
	return nil
}

func (p *TGet) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.MaxVersions = &v
	}
	return nil
}

func (p *TGet) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.FilterString = v
	}
	return nil
}

func (p *TGet) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string][]byte, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key5 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key5 = v
		}
		var _val6 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val6 = v
		}
		p.Attributes[_key5] = _val6
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *TGet) ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
	p.Authorizations = &TAuthorization{}
	if err := p.Authorizations.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Authorizations), err)
	}
	return nil
}

func (p *TGet) ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 9: ", err)
	} else {
		temp := TConsistency(v)
		p.Consistency = &temp
	}
	return nil
}

func (p *TGet) ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 10: ", err)
	} else {
		p.TargetReplicaId = &v
	}
	return nil
}

func (p *TGet) ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 11: ", err)
	} else {
		p.CacheBlocks = &v
	}
	return nil
}

func (p *TGet) ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 12: ", err)
	} else {
		p.StoreLimit = &v
	}
	return nil
}

func (p *TGet) ReadField13(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 13: ", err)
	} else {
		p.StoreOffset = &v
	}
	return nil
}

func (p *TGet) ReadField14(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 14: ", err)
	} else {
		p.ExistenceOnly = &v
	}
	return nil
}

func (p *TGet) ReadField15(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 15: ", err)
	} else {
		p.FilterBytes = v
	}
	return nil
}

func (p *TGet) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TGet"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField4(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField5(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField6(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField7(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField8(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField9(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField10(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField11(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField12(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField13(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField14(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField15(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TGet) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:row: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Row); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.row (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:row: ", p), err)
	}
	return err
}

func (p *TGet) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetColumns() {
		if err := oprot.WriteFieldBegin(ctx, "columns", thrift.LIST, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Columns)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Columns {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns: ", p), err)
		}
	}
	return err
}

func (p *TGet) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetTimestamp() {
		if err := oprot.WriteFieldBegin(ctx, "timestamp", thrift.I64, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:timestamp: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.Timestamp)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.timestamp (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:timestamp: ", p), err)
		}
	}
	return err
}

func (p *TGet) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetTimeRange() {
		if err := oprot.WriteFieldBegin(ctx, "timeRange", thrift.STRUCT, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:timeRange: ", p), err)
		}
		if err := p.TimeRange.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TimeRange), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:timeRange: ", p), err)
		}
	}
	return err
}

func (p *TGet) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetMaxVersions() {
		if err := oprot.WriteFieldBegin(ctx, "maxVersions", thrift.I32, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:maxVersions: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.MaxVersions)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.maxVersions (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:maxVersions: ", p), err)
		}
	}
	return err
}

func (p *TGet) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetFilterString() {
		if err := oprot.WriteFieldBegin(ctx, "filterString", thrift.STRING, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:filterString: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.FilterString); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.filterString (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:filterString: ", p), err)
		}
	}
	return err
}

func (p *TGet) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetAttributes() {
		if err := oprot.WriteFieldBegin(ctx, "attributes", thrift.MAP, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:attributes: ", p), err)
		}
		if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(ctx, string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteBinary(ctx, v); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(ctx); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:attributes: ", p), err)
		}
	}
	return err
}

func (p *TGet) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetAuthorizations() {
		if err := oprot.WriteFieldBegin(ctx, "authorizations", thrift.STRUCT, 8); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:authorizations: ", p), err)
		}
		if err := p.Authorizations.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Authorizations), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 8:authorizations: ", p), err)
		}
	}
	return err
}

func (p *TGet) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetConsistency() {
		if err := oprot.WriteFieldBegin(ctx, "consistency", thrift.I32, 9); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:consistency: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.Consistency)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.consistency (9) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 9:consistency: ", p), err)
		}
	}
	return err
}

func (p *TGet) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetTargetReplicaId() {
		if err := oprot.WriteFieldBegin(ctx, "targetReplicaId", thrift.I32, 10); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:targetReplicaId: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.TargetReplicaId)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.targetReplicaId (10) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 10:targetReplicaId: ", p), err)
		}
	}
	return err
}

func (p *TGet) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetCacheBlocks() {
		if err := oprot.WriteFieldBegin(ctx, "cacheBlocks", thrift.BOOL, 11); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:cacheBlocks: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.CacheBlocks)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.cacheBlocks (11) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 11:cacheBlocks: ", p), err)
		}
	}
	return err
}

func (p *TGet) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetStoreLimit() {
		if err := oprot.WriteFieldBegin(ctx, "storeLimit", thrift.I32, 12); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:storeLimit: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.StoreLimit)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.storeLimit (12) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 12:storeLimit: ", p), err)
		}
	}
	return err
}

func (p *TGet) writeField13(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetStoreOffset() {
		if err := oprot.WriteFieldBegin(ctx, "storeOffset", thrift.I32, 13); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 13:storeOffset: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.StoreOffset)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.storeOffset (13) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 13:storeOffset: ", p), err)
		}
	}
	return err
}

func (p *TGet) writeField14(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetExistenceOnly() {
		if err := oprot.WriteFieldBegin(ctx, "existence_only", thrift.BOOL, 14); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 14:existence_only: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.ExistenceOnly)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.existence_only (14) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 14:existence_only: ", p), err)
		}
	}
	return err
}

func (p *TGet) writeField15(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetFilterBytes() {
		if err := oprot.WriteFieldBegin(ctx, "filterBytes", thrift.STRING, 15); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 15:filterBytes: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.FilterBytes); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.filterBytes (15) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 15:filterBytes: ", p), err)
		}
	}
	return err
}

func (p *TGet) Equals(other *TGet) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.Row, other.Row) != 0 {
		return false
	}
	if len(p.Columns) != len(other.Columns) {
		return false
	}
	for i, _tgt := range p.Columns {
		_src7 := other.Columns[i]
		if !_tgt.Equals(_src7) {
			return false
		}
	}
	if p.Timestamp != other.Timestamp {
		if p.Timestamp == nil || other.Timestamp == nil {
			return false
		}
		if (*p.Timestamp) != (*other.Timestamp) {
			return false
		}
	}
	if !p.TimeRange.Equals(other.TimeRange) {
		return false
	}
	if p.MaxVersions != other.MaxVersions {
		if p.MaxVersions == nil || other.MaxVersions == nil {
			return false
		}
		if (*p.MaxVersions) != (*other.MaxVersions) {
			return false
		}
	}
	if bytes.Compare(p.FilterString, other.FilterString) != 0 {
		return false
	}
	if len(p.Attributes) != len(other.Attributes) {
		return false
	}
	for k, _tgt := range p.Attributes {
		_src8 := other.Attributes[k]
		if bytes.Compare(_tgt, _src8) != 0 {
			return false
		}
	}
	if !p.Authorizations.Equals(other.Authorizations) {
		return false
	}
	if p.Consistency != other.Consistency {
		if p.Consistency == nil || other.Consistency == nil {
			return false
		}
		if (*p.Consistency) != (*other.Consistency) {
			return false
		}
	}
	if p.TargetReplicaId != other.TargetReplicaId {
		if p.TargetReplicaId == nil || other.TargetReplicaId == nil {
			return false
		}
		if (*p.TargetReplicaId) != (*other.TargetReplicaId) {
			return false
		}
	}
	if p.CacheBlocks != other.CacheBlocks {
		if p.CacheBlocks == nil || other.CacheBlocks == nil {
			return false
		}
		if (*p.CacheBlocks) != (*other.CacheBlocks) {
			return false
		}
	}
	if p.StoreLimit != other.StoreLimit {
		if p.StoreLimit == nil || other.StoreLimit == nil {
			return false
		}
		if (*p.StoreLimit) != (*other.StoreLimit) {
			return false
		}
	}
	if p.StoreOffset != other.StoreOffset {
		if p.StoreOffset == nil || other.StoreOffset == nil {
			return false
		}
		if (*p.StoreOffset) != (*other.StoreOffset) {
			return false
		}
	}
	if p.ExistenceOnly != other.ExistenceOnly {
		if p.ExistenceOnly == nil || other.ExistenceOnly == nil {
			return false
		}
		if (*p.ExistenceOnly) != (*other.ExistenceOnly) {
			return false
		}
	}
	if bytes.Compare(p.FilterBytes, other.FilterBytes) != 0 {
		return false
	}
	return true
}

func (p *TGet) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TGet(%+v)", *p)
}

func (p *TGet) Validate() error {
	return nil
}

// Used to perform Put operations for a single row.
//
// Add column values to this object and they'll be added.
// You can provide a default timestamp if the column values
// don't have one. If you don't provide a default timestamp
// the current time is inserted.
//
// You can specify how this Put should be written to the write-ahead Log (WAL)
// by changing the durability. If you don't provide durability, it defaults to
// column family's default setting for durability.
//
// Attributes:
//   - Row
//   - ColumnValues
//   - Timestamp
//   - Attributes
//   - Durability
//   - CellVisibility
type TPut struct {
	Row          []byte          `thrift:"row,1,required" db:"row" json:"row"`
	ColumnValues []*TColumnValue `thrift:"columnValues,2,required" db:"columnValues" json:"columnValues"`
	Timestamp    *int64          `thrift:"timestamp,3" db:"timestamp" json:"timestamp,omitempty"`
	// unused field # 4
	Attributes     map[string][]byte `thrift:"attributes,5" db:"attributes" json:"attributes,omitempty"`
	Durability     *TDurability      `thrift:"durability,6" db:"durability" json:"durability,omitempty"`
	CellVisibility *TCellVisibility  `thrift:"cellVisibility,7" db:"cellVisibility" json:"cellVisibility,omitempty"`
}

func NewTPut() *TPut {
	return &TPut{}
}

func (p *TPut) GetRow() []byte {
	return p.Row
}

func (p *TPut) GetColumnValues() []*TColumnValue {
	return p.ColumnValues
}

var TPut_Timestamp_DEFAULT int64

func (p *TPut) GetTimestamp() int64 {
	if !p.IsSetTimestamp() {
		return TPut_Timestamp_DEFAULT
	}
	return *p.Timestamp
}

var TPut_Attributes_DEFAULT map[string][]byte

func (p *TPut) GetAttributes() map[string][]byte {
	return p.Attributes
}

var TPut_Durability_DEFAULT TDurability

func (p *TPut) GetDurability() TDurability {
	if !p.IsSetDurability() {
		return TPut_Durability_DEFAULT
	}
	return *p.Durability
}

var TPut_CellVisibility_DEFAULT *TCellVisibility

func (p *TPut) GetCellVisibility() *TCellVisibility {
	if !p.IsSetCellVisibility() {
		return TPut_CellVisibility_DEFAULT
	}
	return p.CellVisibility
}
func (p *TPut) IsSetTimestamp() bool {
	return p.Timestamp != nil
}

func (p *TPut) IsSetAttributes() bool {
	return p.Attributes != nil
}

func (p *TPut) IsSetDurability() bool {
	return p.Durability != nil
}

func (p *TPut) IsSetCellVisibility() bool {
	return p.CellVisibility != nil
}

func (p *TPut) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetRow bool = false
	var issetColumnValues bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetRow = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetColumnValues = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetRow {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"))
	}
	if !issetColumnValues {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnValues is not set"))
	}
	return nil
}

func (p *TPut) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *TPut) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TColumnValue, 0, size)
	p.ColumnValues = tSlice
	for i := 0; i < size; i++ {
		_elem9 := &TColumnValue{}
		if err := _elem9.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem9), err)
		}
		p.ColumnValues = append(p.ColumnValues, _elem9)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *TPut) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Timestamp = &v
	}
	return nil
}

func (p *TPut) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string][]byte, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key10 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key10 = v
		}
		var _val11 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val11 = v
		}
		p.Attributes[_key10] = _val11
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *TPut) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		temp := TDurability(v)
		p.Durability = &temp
	}
	return nil
}

func (p *TPut) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	p.CellVisibility = &TCellVisibility{}
	if err := p.CellVisibility.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CellVisibility), err)
	}
	return nil
}

func (p *TPut) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TPut"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField5(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField6(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField7(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TPut) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:row: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Row); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.row (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:row: ", p), err)
	}
	return err
}

func (p *TPut) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "columnValues", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columnValues: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.ColumnValues)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.ColumnValues {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columnValues: ", p), err)
	}
	return err
}

func (p *TPut) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetTimestamp() {
		if err := oprot.WriteFieldBegin(ctx, "timestamp", thrift.I64, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:timestamp: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.Timestamp)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.timestamp (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:timestamp: ", p), err)
		}
	}
	return err
}

func (p *TPut) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetAttributes() {
		if err := oprot.WriteFieldBegin(ctx, "attributes", thrift.MAP, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:attributes: ", p), err)
		}
		if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(ctx, string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteBinary(ctx, v); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(ctx); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:attributes: ", p), err)
		}
	}
	return err
}

func (p *TPut) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetDurability() {
		if err := oprot.WriteFieldBegin(ctx, "durability", thrift.I32, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:durability: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.Durability)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.durability (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:durability: ", p), err)
		}
	}
	return err
}

func (p *TPut) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetCellVisibility() {
		if err := oprot.WriteFieldBegin(ctx, "cellVisibility", thrift.STRUCT, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:cellVisibility: ", p), err)
		}
		if err := p.CellVisibility.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CellVisibility), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:cellVisibility: ", p), err)
		}
	}
	return err
}

func (p *TPut) Equals(other *TPut) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.Row, other.Row) != 0 {
		return false
	}
	if len(p.ColumnValues) != len(other.ColumnValues) {
		return false
	}
	for i, _tgt := range p.ColumnValues {
		_src12 := other.ColumnValues[i]
		if !_tgt.Equals(_src12) {
			return false
		}
	}
	if p.Timestamp != other.Timestamp {
		if p.Timestamp == nil || other.Timestamp == nil {
			return false
		}
		if (*p.Timestamp) != (*other.Timestamp) {
			return false
		}
	}
	if len(p.Attributes) != len(other.Attributes) {
		return false
	}
	for k, _tgt := range p.Attributes {
		_src13 := other.Attributes[k]
		if bytes.Compare(_tgt, _src13) != 0 {
			return false
		}
	}
	if p.Durability != other.Durability {
		if p.Durability == nil || other.Durability == nil {
			return false
		}
		if (*p.Durability) != (*other.Durability) {
			return false
		}
	}
	if !p.CellVisibility.Equals(other.CellVisibility) {
		return false
	}
	return true
}

func (p *TPut) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TPut(%+v)", *p)
}

func (p *TPut) Validate() error {
	return nil
}

// Used to perform Delete operations on a single row.
//
// The scope can be further narrowed down by specifying a list of
// columns or column families as TColumns.
//
// Specifying only a family in a TColumn will delete the whole family.
// If a timestamp is specified all versions with a timestamp less than
// or equal to this will be deleted. If no timestamp is specified the
// current time will be used.
//
// Specifying a family and a column qualifier in a TColumn will delete only
// this qualifier. If a timestamp is specified only versions equal
// to this timestamp will be deleted. If no timestamp is specified the
// most recent version will be deleted.  To delete all previous versions,
// specify the DELETE_COLUMNS TDeleteType.
//
// The top level timestamp is only used if a complete row should be deleted
// (i.e. no columns are passed) and if it is specified it works the same way
// as if you had added a TColumn for every column family and this timestamp
// (i.e. all versions older than or equal in all column families will be deleted)
//
// You can specify how this Delete should be written to the write-ahead Log (WAL)
// by changing the durability. If you don't provide durability, it defaults to
// column family's default setting for durability.
//
// Attributes:
//   - Row
//   - Columns
//   - Timestamp
//   - DeleteType
//   - Attributes
//   - Durability
type TDelete struct {
	Row        []byte      `thrift:"row,1,required" db:"row" json:"row"`
	Columns    []*TColumn  `thrift:"columns,2" db:"columns" json:"columns,omitempty"`
	Timestamp  *int64      `thrift:"timestamp,3" db:"timestamp" json:"timestamp,omitempty"`
	DeleteType TDeleteType `thrift:"deleteType,4" db:"deleteType" json:"deleteType"`
	// unused field # 5
	Attributes map[string][]byte `thrift:"attributes,6" db:"attributes" json:"attributes,omitempty"`
	Durability *TDurability      `thrift:"durability,7" db:"durability" json:"durability,omitempty"`
}

func NewTDelete() *TDelete {
	return &TDelete{
		DeleteType: 1,
	}
}

func (p *TDelete) GetRow() []byte {
	return p.Row
}

var TDelete_Columns_DEFAULT []*TColumn

func (p *TDelete) GetColumns() []*TColumn {
	return p.Columns
}

var TDelete_Timestamp_DEFAULT int64

func (p *TDelete) GetTimestamp() int64 {
	if !p.IsSetTimestamp() {
		return TDelete_Timestamp_DEFAULT
	}
	return *p.Timestamp
}

var TDelete_DeleteType_DEFAULT TDeleteType = 1

func (p *TDelete) GetDeleteType() TDeleteType {
	return p.DeleteType
}

var TDelete_Attributes_DEFAULT map[string][]byte

func (p *TDelete) GetAttributes() map[string][]byte {
	return p.Attributes
}

var TDelete_Durability_DEFAULT TDurability

func (p *TDelete) GetDurability() TDurability {
	if !p.IsSetDurability() {
		return TDelete_Durability_DEFAULT
	}
	return *p.Durability
}
func (p *TDelete) IsSetColumns() bool {
	return p.Columns != nil
}

func (p *TDelete) IsSetTimestamp() bool {
	return p.Timestamp != nil
}

func (p *TDelete) IsSetDeleteType() bool {
	return p.DeleteType != TDelete_DeleteType_DEFAULT
}

func (p *TDelete) IsSetAttributes() bool {
	return p.Attributes != nil
}

func (p *TDelete) IsSetDurability() bool {
	return p.Durability != nil
}

func (p *TDelete) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetRow bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetRow = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetRow {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"))
	}
	return nil
}

func (p *TDelete) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *TDelete) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TColumn, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		_elem14 := &TColumn{}
		if err := _elem14.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem14), err)
		}
		p.Columns = append(p.Columns, _elem14)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *TDelete) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Timestamp = &v
	}
	return nil
}

func (p *TDelete) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := TDeleteType(v)
		p.DeleteType = temp
	}
	return nil
}

func (p *TDelete) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string][]byte, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key15 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key15 = v
		}
		var _val16 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val16 = v
		}
		p.Attributes[_key15] = _val16
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *TDelete) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 7: ", err)
	} else {
		temp := TDurability(v)
		p.Durability = &temp
	}
	return nil
}

func (p *TDelete) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TDelete"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField4(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField6(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField7(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TDelete) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:row: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Row); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.row (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:row: ", p), err)
	}
	return err
}

func (p *TDelete) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetColumns() {
		if err := oprot.WriteFieldBegin(ctx, "columns", thrift.LIST, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Columns)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Columns {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns: ", p), err)
		}
	}
	return err
}

func (p *TDelete) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetTimestamp() {
		if err := oprot.WriteFieldBegin(ctx, "timestamp", thrift.I64, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:timestamp: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.Timestamp)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.timestamp (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:timestamp: ", p), err)
		}
	}
	return err
}

func (p *TDelete) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetDeleteType() {
		if err := oprot.WriteFieldBegin(ctx, "deleteType", thrift.I32, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:deleteType: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(p.DeleteType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.deleteType (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:deleteType: ", p), err)
		}
	}
	return err
}

func (p *TDelete) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetAttributes() {
		if err := oprot.WriteFieldBegin(ctx, "attributes", thrift.MAP, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:attributes: ", p), err)
		}
		if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(ctx, string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteBinary(ctx, v); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(ctx); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:attributes: ", p), err)
		}
	}
	return err
}

func (p *TDelete) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetDurability() {
		if err := oprot.WriteFieldBegin(ctx, "durability", thrift.I32, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:durability: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.Durability)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.durability (7) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:durability: ", p), err)
		}
	}
	return err
}

func (p *TDelete) Equals(other *TDelete) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.Row, other.Row) != 0 {
		return false
	}
	if len(p.Columns) != len(other.Columns) {
		return false
	}
	for i, _tgt := range p.Columns {
		_src17 := other.Columns[i]
		if !_tgt.Equals(_src17) {
			return false
		}
	}
	if p.Timestamp != other.Timestamp {
		if p.Timestamp == nil || other.Timestamp == nil {
			return false
		}
		if (*p.Timestamp) != (*other.Timestamp) {
			return false
		}
	}
	if p.DeleteType != other.DeleteType {
		return false
	}
	if len(p.Attributes) != len(other.Attributes) {
		return false
	}
	for k, _tgt := range p.Attributes {
		_src18 := other.Attributes[k]
		if bytes.Compare(_tgt, _src18) != 0 {
			return false
		}
	}
	if p.Durability != other.Durability {
		if p.Durability == nil || other.Durability == nil {
			return false
		}
		if (*p.Durability) != (*other.Durability) {
			return false
		}
	}
	return true
}

func (p *TDelete) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TDelete(%+v)", *p)
}

func (p *TDelete) Validate() error {
	return nil
}

// Used to perform Increment operations for a single row.
//
// You can specify how this Increment should be written to the write-ahead Log (WAL)
// by changing the durability. If you don't provide durability, it defaults to
// column family's default setting for durability.
//
// Attributes:
//   - Row
//   - Columns
//   - Attributes
//   - Durability
//   - CellVisibility
//   - ReturnResults
type TIncrement struct {
	Row     []byte              `thrift:"row,1,required" db:"row" json:"row"`
	Columns []*TColumnIncrement `thrift:"columns,2,required" db:"columns" json:"columns"`
	// unused field # 3
	Attributes     map[string][]byte `thrift:"attributes,4" db:"attributes" json:"attributes,omitempty"`
	Durability     *TDurability      `thrift:"durability,5" db:"durability" json:"durability,omitempty"`
	CellVisibility *TCellVisibility  `thrift:"cellVisibility,6" db:"cellVisibility" json:"cellVisibility,omitempty"`
	ReturnResults  *bool             `thrift:"returnResults,7" db:"returnResults" json:"returnResults,omitempty"`
}

func NewTIncrement() *TIncrement {
	return &TIncrement{}
}

func (p *TIncrement) GetRow() []byte {
	return p.Row
}

func (p *TIncrement) GetColumns() []*TColumnIncrement {
	return p.Columns
}

var TIncrement_Attributes_DEFAULT map[string][]byte

func (p *TIncrement) GetAttributes() map[string][]byte {
	return p.Attributes
}

var TIncrement_Durability_DEFAULT TDurability

func (p *TIncrement) GetDurability() TDurability {
	if !p.IsSetDurability() {
		return TIncrement_Durability_DEFAULT
	}
	return *p.Durability
}

var TIncrement_CellVisibility_DEFAULT *TCellVisibility

func (p *TIncrement) GetCellVisibility() *TCellVisibility {
	if !p.IsSetCellVisibility() {
		return TIncrement_CellVisibility_DEFAULT
	}
	return p.CellVisibility
}

var TIncrement_ReturnResults_DEFAULT bool

func (p *TIncrement) GetReturnResults() bool {
	if !p.IsSetReturnResults() {
		return TIncrement_ReturnResults_DEFAULT
	}
	return *p.ReturnResults
}
func (p *TIncrement) IsSetAttributes() bool {
	return p.Attributes != nil
}

func (p *TIncrement) IsSetDurability() bool {
	return p.Durability != nil
}

func (p *TIncrement) IsSetCellVisibility() bool {
	return p.CellVisibility != nil
}

func (p *TIncrement) IsSetReturnResults() bool {
	return p.ReturnResults != nil
}

func (p *TIncrement) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetRow bool = false
	var issetColumns bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetRow = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetColumns = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetRow {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"))
	}
	if !issetColumns {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Columns is not set"))
	}
	return nil
}

func (p *TIncrement) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *TIncrement) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TColumnIncrement, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		_elem19 := &TColumnIncrement{
			Amount: 1,
		}
		if err := _elem19.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem19), err)
		}
		p.Columns = append(p.Columns, _elem19)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *TIncrement) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string][]byte, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key20 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key20 = v
		}
		var _val21 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val21 = v
		}
		p.Attributes[_key20] = _val21
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *TIncrement) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		temp := TDurability(v)
		p.Durability = &temp
	}
	return nil
}

func (p *TIncrement) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	p.CellVisibility = &TCellVisibility{}
	if err := p.CellVisibility.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CellVisibility), err)
	}
	return nil
}

func (p *TIncrement) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 7: ", err)
	} else {
		p.ReturnResults = &v
	}
	return nil
}

func (p *TIncrement) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TIncrement"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField4(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField5(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField6(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField7(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TIncrement) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:row: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Row); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.row (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:row: ", p), err)
	}
	return err
}

func (p *TIncrement) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "columns", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Columns)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Columns {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns: ", p), err)
	}
	return err
}

func (p *TIncrement) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetAttributes() {
		if err := oprot.WriteFieldBegin(ctx, "attributes", thrift.MAP, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:attributes: ", p), err)
		}
		if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(ctx, string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteBinary(ctx, v); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(ctx); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:attributes: ", p), err)
		}
	}
	return err
}

func (p *TIncrement) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetDurability() {
		if err := oprot.WriteFieldBegin(ctx, "durability", thrift.I32, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:durability: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.Durability)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.durability (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:durability: ", p), err)
		}
	}
	return err
}

func (p *TIncrement) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetCellVisibility() {
		if err := oprot.WriteFieldBegin(ctx, "cellVisibility", thrift.STRUCT, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:cellVisibility: ", p), err)
		}
		if err := p.CellVisibility.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CellVisibility), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:cellVisibility: ", p), err)
		}
	}
	return err
}

func (p *TIncrement) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetReturnResults() {
		if err := oprot.WriteFieldBegin(ctx, "returnResults", thrift.BOOL, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:returnResults: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.ReturnResults)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.returnResults (7) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:returnResults: ", p), err)
		}
	}
	return err
}

func (p *TIncrement) Equals(other *TIncrement) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.Row, other.Row) != 0 {
		return false
	}
	if len(p.Columns) != len(other.Columns) {
		return false
	}
	for i, _tgt := range p.Columns {
		_src22 := other.Columns[i]
		if !_tgt.Equals(_src22) {
			return false
		}
	}
	if len(p.Attributes) != len(other.Attributes) {
		return false
	}
	for k, _tgt := range p.Attributes {
		_src23 := other.Attributes[k]
		if bytes.Compare(_tgt, _src23) != 0 {
			return false
		}
	}
	if p.Durability != other.Durability {
		if p.Durability == nil || other.Durability == nil {
			return false
		}
		if (*p.Durability) != (*other.Durability) {
			return false
		}
	}
	if !p.CellVisibility.Equals(other.CellVisibility) {
		return false
	}
	if p.ReturnResults != other.ReturnResults {
		if p.ReturnResults == nil || other.ReturnResults == nil {
			return false
		}
		if (*p.ReturnResults) != (*other.ReturnResults) {
			return false
		}
	}
	return true
}

func (p *TIncrement) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TIncrement(%+v)", *p)
}

func (p *TIncrement) Validate() error {
	return nil
}

// Attributes:
//   - Row
//   - Columns
//   - Attributes
//   - Durability
//   - CellVisibility
//   - ReturnResults
type TAppend struct {
	Row            []byte            `thrift:"row,1,required" db:"row" json:"row"`
	Columns        []*TColumnValue   `thrift:"columns,2,required" db:"columns" json:"columns"`
	Attributes     map[string][]byte `thrift:"attributes,3" db:"attributes" json:"attributes,omitempty"`
	Durability     *TDurability      `thrift:"durability,4" db:"durability" json:"durability,omitempty"`
	CellVisibility *TCellVisibility  `thrift:"cellVisibility,5" db:"cellVisibility" json:"cellVisibility,omitempty"`
	ReturnResults  *bool             `thrift:"returnResults,6" db:"returnResults" json:"returnResults,omitempty"`
}

func NewTAppend() *TAppend {
	return &TAppend{}
}

func (p *TAppend) GetRow() []byte {
	return p.Row
}

func (p *TAppend) GetColumns() []*TColumnValue {
	return p.Columns
}

var TAppend_Attributes_DEFAULT map[string][]byte

func (p *TAppend) GetAttributes() map[string][]byte {
	return p.Attributes
}

var TAppend_Durability_DEFAULT TDurability

func (p *TAppend) GetDurability() TDurability {
	if !p.IsSetDurability() {
		return TAppend_Durability_DEFAULT
	}
	return *p.Durability
}

var TAppend_CellVisibility_DEFAULT *TCellVisibility

func (p *TAppend) GetCellVisibility() *TCellVisibility {
	if !p.IsSetCellVisibility() {
		return TAppend_CellVisibility_DEFAULT
	}
	return p.CellVisibility
}

var TAppend_ReturnResults_DEFAULT bool

func (p *TAppend) GetReturnResults() bool {
	if !p.IsSetReturnResults() {
		return TAppend_ReturnResults_DEFAULT
	}
	return *p.ReturnResults
}
func (p *TAppend) IsSetAttributes() bool {
	return p.Attributes != nil
}

func (p *TAppend) IsSetDurability() bool {
	return p.Durability != nil
}

func (p *TAppend) IsSetCellVisibility() bool {
	return p.CellVisibility != nil
}

func (p *TAppend) IsSetReturnResults() bool {
	return p.ReturnResults != nil
}

func (p *TAppend) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetRow bool = false
	var issetColumns bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetRow = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetColumns = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetRow {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"))
	}
	if !issetColumns {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Columns is not set"))
	}
	return nil
}

func (p *TAppend) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *TAppend) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TColumnValue, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		_elem24 := &TColumnValue{}
		if err := _elem24.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem24), err)
		}
		p.Columns = append(p.Columns, _elem24)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *TAppend) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string][]byte, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key25 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key25 = v
		}
		var _val26 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val26 = v
		}
		p.Attributes[_key25] = _val26
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *TAppend) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := TDurability(v)
		p.Durability = &temp
	}
	return nil
}

func (p *TAppend) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	p.CellVisibility = &TCellVisibility{}
	if err := p.CellVisibility.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CellVisibility), err)
	}
	return nil
}

func (p *TAppend) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.ReturnResults = &v
	}
	return nil
}

func (p *TAppend) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TAppend"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField4(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField5(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField6(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TAppend) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:row: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Row); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.row (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:row: ", p), err)
	}
	return err
}

func (p *TAppend) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "columns", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Columns)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Columns {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns: ", p), err)
	}
	return err
}

func (p *TAppend) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetAttributes() {
		if err := oprot.WriteFieldBegin(ctx, "attributes", thrift.MAP, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:attributes: ", p), err)
		}
		if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(ctx, string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteBinary(ctx, v); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(ctx); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:attributes: ", p), err)
		}
	}
	return err
}

func (p *TAppend) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetDurability() {
		if err := oprot.WriteFieldBegin(ctx, "durability", thrift.I32, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:durability: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.Durability)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.durability (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:durability: ", p), err)
		}
	}
	return err
}

func (p *TAppend) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetCellVisibility() {
		if err := oprot.WriteFieldBegin(ctx, "cellVisibility", thrift.STRUCT, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:cellVisibility: ", p), err)
		}
		if err := p.CellVisibility.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CellVisibility), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:cellVisibility: ", p), err)
		}
	}
	return err
}

func (p *TAppend) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetReturnResults() {
		if err := oprot.WriteFieldBegin(ctx, "returnResults", thrift.BOOL, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:returnResults: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.ReturnResults)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.returnResults (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:returnResults: ", p), err)
		}
	}
	return err
}

func (p *TAppend) Equals(other *TAppend) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.Row, other.Row) != 0 {
		return false
	}
	if len(p.Columns) != len(other.Columns) {
		return false
	}
	for i, _tgt := range p.Columns {
		_src27 := other.Columns[i]
		if !_tgt.Equals(_src27) {
			return false
		}
	}
	if len(p.Attributes) != len(other.Attributes) {
		return false
	}
	for k, _tgt := range p.Attributes {
		_src28 := other.Attributes[k]
		if bytes.Compare(_tgt, _src28) != 0 {
			return false
		}
	}
	if p.Durability != other.Durability {
		if p.Durability == nil || other.Durability == nil {
			return false
		}
		if (*p.Durability) != (*other.Durability) {
			return false
		}
	}
	if !p.CellVisibility.Equals(other.CellVisibility) {
		return false
	}
	if p.ReturnResults != other.ReturnResults {
		if p.ReturnResults == nil || other.ReturnResults == nil {
			return false
		}
		if (*p.ReturnResults) != (*other.ReturnResults) {
			return false
		}
	}
	return true
}

func (p *TAppend) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TAppend(%+v)", *p)
}

func (p *TAppend) Validate() error {
	return nil
}

// Any timestamps in the columns are ignored but the colFamTimeRangeMap included, use timeRange to select by timestamp.
// Max versions defaults to 1.
//
// Attributes:
//   - StartRow
//   - StopRow
//   - Columns
//   - Caching
//   - MaxVersions
//   - TimeRange
//   - FilterString
//   - BatchSize
//   - Attributes
//   - Authorizations
//   - Reversed
//   - CacheBlocks
//   - ColFamTimeRangeMap
//   - ReadType
//   - Limit
//   - Consistency
//   - TargetReplicaId
//   - FilterBytes
type TScan struct {
	StartRow           []byte                 `thrift:"startRow,1" db:"startRow" json:"startRow,omitempty"`
	StopRow            []byte                 `thrift:"stopRow,2" db:"stopRow" json:"stopRow,omitempty"`
	Columns            []*TColumn             `thrift:"columns,3" db:"columns" json:"columns,omitempty"`
	Caching            *int32                 `thrift:"caching,4" db:"caching" json:"caching,omitempty"`
	MaxVersions        int32                  `thrift:"maxVersions,5" db:"maxVersions" json:"maxVersions"`
	TimeRange          *TTimeRange            `thrift:"timeRange,6" db:"timeRange" json:"timeRange,omitempty"`
	FilterString       []byte                 `thrift:"filterString,7" db:"filterString" json:"filterString,omitempty"`
	BatchSize          *int32                 `thrift:"batchSize,8" db:"batchSize" json:"batchSize,omitempty"`
	Attributes         map[string][]byte      `thrift:"attributes,9" db:"attributes" json:"attributes,omitempty"`
	Authorizations     *TAuthorization        `thrift:"authorizations,10" db:"authorizations" json:"authorizations,omitempty"`
	Reversed           *bool                  `thrift:"reversed,11" db:"reversed" json:"reversed,omitempty"`
	CacheBlocks        *bool                  `thrift:"cacheBlocks,12" db:"cacheBlocks" json:"cacheBlocks,omitempty"`
	ColFamTimeRangeMap map[string]*TTimeRange `thrift:"colFamTimeRangeMap,13" db:"colFamTimeRangeMap" json:"colFamTimeRangeMap,omitempty"`
	ReadType           *TReadType             `thrift:"readType,14" db:"readType" json:"readType,omitempty"`
	Limit              *int32                 `thrift:"limit,15" db:"limit" json:"limit,omitempty"`
	Consistency        *TConsistency          `thrift:"consistency,16" db:"consistency" json:"consistency,omitempty"`
	TargetReplicaId    *int32                 `thrift:"targetReplicaId,17" db:"targetReplicaId" json:"targetReplicaId,omitempty"`
	FilterBytes        []byte                 `thrift:"filterBytes,18" db:"filterBytes" json:"filterBytes,omitempty"`
}

func NewTScan() *TScan {
	return &TScan{
		MaxVersions: 1,
	}
}

var TScan_StartRow_DEFAULT []byte

func (p *TScan) GetStartRow() []byte {
	return p.StartRow
}

var TScan_StopRow_DEFAULT []byte

func (p *TScan) GetStopRow() []byte {
	return p.StopRow
}

var TScan_Columns_DEFAULT []*TColumn

func (p *TScan) GetColumns() []*TColumn {
	return p.Columns
}

var TScan_Caching_DEFAULT int32

func (p *TScan) GetCaching() int32 {
	if !p.IsSetCaching() {
		return TScan_Caching_DEFAULT
	}
	return *p.Caching
}

var TScan_MaxVersions_DEFAULT int32 = 1

func (p *TScan) GetMaxVersions() int32 {
	return p.MaxVersions
}

var TScan_TimeRange_DEFAULT *TTimeRange

func (p *TScan) GetTimeRange() *TTimeRange {
	if !p.IsSetTimeRange() {
		return TScan_TimeRange_DEFAULT
	}
	return p.TimeRange
}

var TScan_FilterString_DEFAULT []byte

func (p *TScan) GetFilterString() []byte {
	return p.FilterString
}

var TScan_BatchSize_DEFAULT int32

func (p *TScan) GetBatchSize() int32 {
	if !p.IsSetBatchSize() {
		return TScan_BatchSize_DEFAULT
	}
	return *p.BatchSize
}

var TScan_Attributes_DEFAULT map[string][]byte

func (p *TScan) GetAttributes() map[string][]byte {
	return p.Attributes
}

var TScan_Authorizations_DEFAULT *TAuthorization

func (p *TScan) GetAuthorizations() *TAuthorization {
	if !p.IsSetAuthorizations() {
		return TScan_Authorizations_DEFAULT
	}
	return p.Authorizations
}

var TScan_Reversed_DEFAULT bool

func (p *TScan) GetReversed() bool {
	if !p.IsSetReversed() {
		return TScan_Reversed_DEFAULT
	}
	return *p.Reversed
}

var TScan_CacheBlocks_DEFAULT bool

func (p *TScan) GetCacheBlocks() bool {
	if !p.IsSetCacheBlocks() {
		return TScan_CacheBlocks_DEFAULT
	}
	return *p.CacheBlocks
}

var TScan_ColFamTimeRangeMap_DEFAULT map[string]*TTimeRange

func (p *TScan) GetColFamTimeRangeMap() map[string]*TTimeRange {
	return p.ColFamTimeRangeMap
}

var TScan_ReadType_DEFAULT TReadType

func (p *TScan) GetReadType() TReadType {
	if !p.IsSetReadType() {
		return TScan_ReadType_DEFAULT
	}
	return *p.ReadType
}

var TScan_Limit_DEFAULT int32

func (p *TScan) GetLimit() int32 {
	if !p.IsSetLimit() {
		return TScan_Limit_DEFAULT
	}
	return *p.Limit
}

var TScan_Consistency_DEFAULT TConsistency

func (p *TScan) GetConsistency() TConsistency {
	if !p.IsSetConsistency() {
		return TScan_Consistency_DEFAULT
	}
	return *p.Consistency
}

var TScan_TargetReplicaId_DEFAULT int32

func (p *TScan) GetTargetReplicaId() int32 {
	if !p.IsSetTargetReplicaId() {
		return TScan_TargetReplicaId_DEFAULT
	}
	return *p.TargetReplicaId
}

var TScan_FilterBytes_DEFAULT []byte

func (p *TScan) GetFilterBytes() []byte {
	return p.FilterBytes
}
func (p *TScan) IsSetStartRow() bool {
	return p.StartRow != nil
}

func (p *TScan) IsSetStopRow() bool {
	return p.StopRow != nil
}

func (p *TScan) IsSetColumns() bool {
	return p.Columns != nil
}

func (p *TScan) IsSetCaching() bool {
	return p.Caching != nil
}

func (p *TScan) IsSetMaxVersions() bool {
	return p.MaxVersions != TScan_MaxVersions_DEFAULT
}

func (p *TScan) IsSetTimeRange() bool {
	return p.TimeRange != nil
}

func (p *TScan) IsSetFilterString() bool {
	return p.FilterString != nil
}

func (p *TScan) IsSetBatchSize() bool {
	return p.BatchSize != nil
}

func (p *TScan) IsSetAttributes() bool {
	return p.Attributes != nil
}

func (p *TScan) IsSetAuthorizations() bool {
	return p.Authorizations != nil
}

func (p *TScan) IsSetReversed() bool {
	return p.Reversed != nil
}

func (p *TScan) IsSetCacheBlocks() bool {
	return p.CacheBlocks != nil
}

func (p *TScan) IsSetColFamTimeRangeMap() bool {
	return p.ColFamTimeRangeMap != nil
}

func (p *TScan) IsSetReadType() bool {
	return p.ReadType != nil
}

func (p *TScan) IsSetLimit() bool {
	return p.Limit != nil
}

func (p *TScan) IsSetConsistency() bool {
	return p.Consistency != nil
}

func (p *TScan) IsSetTargetReplicaId() bool {
	return p.TargetReplicaId != nil
}

func (p *TScan) IsSetFilterBytes() bool {
	return p.FilterBytes != nil
}

func (p *TScan) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 8:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField8(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 9:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField9(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 10:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField10(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 11:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField11(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 12:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField12(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 13:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField13(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 14:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField14(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 15:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField15(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 16:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField16(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 17:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField17(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 18:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField18(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TScan) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.StartRow = v
	}
	return nil
}

func (p *TScan) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.StopRow = v
	}
	return nil
}

func (p *TScan) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TColumn, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		_elem29 := &TColumn{}
		if err := _elem29.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem29), err)
		}
		p.Columns = append(p.Columns, _elem29)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *TScan) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.Caching = &v
	}
	return nil
}

func (p *TScan) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.MaxVersions = v
	}
	return nil
}

func (p *TScan) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	p.TimeRange = &TTimeRange{}
	if err := p.TimeRange.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TimeRange), err)
	}
	return nil
}

func (p *TScan) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 7: ", err)
	} else {
		p.FilterString = v
	}
	return nil
}

func (p *TScan) ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 8: ", err)
	} else {
		p.BatchSize = &v
	}
	return nil
}

func (p *TScan) ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string][]byte, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key30 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key30 = v
		}
		var _val31 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val31 = v
		}
		p.Attributes[_key30] = _val31
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *TScan) ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
	p.Authorizations = &TAuthorization{}
	if err := p.Authorizations.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Authorizations), err)
	}
	return nil
}

func (p *TScan) ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 11: ", err)
	} else {
		p.Reversed = &v
	}
	return nil
}

func (p *TScan) ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 12: ", err)
	} else {
		p.CacheBlocks = &v
	}
	return nil
}

func (p *TScan) ReadField13(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string]*TTimeRange, size)
	p.ColFamTimeRangeMap = tMap
	for i := 0; i < size; i++ {
		var _key32 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key32 = v
		}
		_val33 := &TTimeRange{}
		if err := _val33.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _val33), err)
		}
		p.ColFamTimeRangeMap[_key32] = _val33
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *TScan) ReadField14(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 14: ", err)
	} else {
		temp := TReadType(v)
		p.ReadType = &temp
	}
	return nil
}

func (p *TScan) ReadField15(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 15: ", err)
	} else {
		p.Limit = &v
	}
	return nil
}

func (p *TScan) ReadField16(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 16: ", err)
	} else {
		temp := TConsistency(v)
		p.Consistency = &temp
	}
	return nil
}

func (p *TScan) ReadField17(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 17: ", err)
	} else {
		p.TargetReplicaId = &v
	}
	return nil
}

func (p *TScan) ReadField18(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 18: ", err)
	} else {
		p.FilterBytes = v
	}
	return nil
}

func (p *TScan) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TScan"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField4(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField5(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField6(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField7(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField8(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField9(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField10(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField11(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField12(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField13(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField14(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField15(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField16(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField17(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField18(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TScan) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetStartRow() {
		if err := oprot.WriteFieldBegin(ctx, "startRow", thrift.STRING, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:startRow: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.StartRow); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.startRow (1) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:startRow: ", p), err)
		}
	}
	return err
}

func (p *TScan) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetStopRow() {
		if err := oprot.WriteFieldBegin(ctx, "stopRow", thrift.STRING, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:stopRow: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.StopRow); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.stopRow (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:stopRow: ", p), err)
		}
	}
	return err
}

func (p *TScan) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetColumns() {
		if err := oprot.WriteFieldBegin(ctx, "columns", thrift.LIST, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:columns: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Columns)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Columns {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:columns: ", p), err)
		}
	}
	return err
}

func (p *TScan) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetCaching() {
		if err := oprot.WriteFieldBegin(ctx, "caching", thrift.I32, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:caching: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.Caching)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.caching (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:caching: ", p), err)
		}
	}
	return err
}

func (p *TScan) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetMaxVersions() {
		if err := oprot.WriteFieldBegin(ctx, "maxVersions", thrift.I32, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:maxVersions: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(p.MaxVersions)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.maxVersions (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:maxVersions: ", p), err)
		}
	}
	return err
}

func (p *TScan) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetTimeRange() {
		if err := oprot.WriteFieldBegin(ctx, "timeRange", thrift.STRUCT, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:timeRange: ", p), err)
		}
		if err := p.TimeRange.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TimeRange), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:timeRange: ", p), err)
		}
	}
	return err
}

func (p *TScan) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetFilterString() {
		if err := oprot.WriteFieldBegin(ctx, "filterString", thrift.STRING, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:filterString: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.FilterString); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.filterString (7) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:filterString: ", p), err)
		}
	}
	return err
}

func (p *TScan) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetBatchSize() {
		if err := oprot.WriteFieldBegin(ctx, "batchSize", thrift.I32, 8); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:batchSize: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.BatchSize)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.batchSize (8) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 8:batchSize: ", p), err)
		}
	}
	return err
}

func (p *TScan) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetAttributes() {
		if err := oprot.WriteFieldBegin(ctx, "attributes", thrift.MAP, 9); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:attributes: ", p), err)
		}
		if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(ctx, string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteBinary(ctx, v); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(ctx); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 9:attributes: ", p), err)
		}
	}
	return err
}

func (p *TScan) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetAuthorizations() {
		if err := oprot.WriteFieldBegin(ctx, "authorizations", thrift.STRUCT, 10); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:authorizations: ", p), err)
		}
		if err := p.Authorizations.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Authorizations), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 10:authorizations: ", p), err)
		}
	}
	return err
}

func (p *TScan) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetReversed() {
		if err := oprot.WriteFieldBegin(ctx, "reversed", thrift.BOOL, 11); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:reversed: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Reversed)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.reversed (11) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 11:reversed: ", p), err)
		}
	}
	return err
}

func (p *TScan) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetCacheBlocks() {
		if err := oprot.WriteFieldBegin(ctx, "cacheBlocks", thrift.BOOL, 12); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:cacheBlocks: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.CacheBlocks)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.cacheBlocks (12) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 12:cacheBlocks: ", p), err)
		}
	}
	return err
}

func (p *TScan) writeField13(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetColFamTimeRangeMap() {
		if err := oprot.WriteFieldBegin(ctx, "colFamTimeRangeMap", thrift.MAP, 13); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 13:colFamTimeRangeMap: ", p), err)
		}
		if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRUCT, len(p.ColFamTimeRangeMap)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.ColFamTimeRangeMap {
			if err := oprot.WriteString(ctx, string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteMapEnd(ctx); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 13:colFamTimeRangeMap: ", p), err)
		}
	}
	return err
}

func (p *TScan) writeField14(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetReadType() {
		if err := oprot.WriteFieldBegin(ctx, "readType", thrift.I32, 14); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 14:readType: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.ReadType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.readType (14) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 14:readType: ", p), err)
		}
	}
	return err
}

func (p *TScan) writeField15(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetLimit() {
		if err := oprot.WriteFieldBegin(ctx, "limit", thrift.I32, 15); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 15:limit: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.Limit)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.limit (15) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 15:limit: ", p), err)
		}
	}
	return err
}

func (p *TScan) writeField16(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetConsistency() {
		if err := oprot.WriteFieldBegin(ctx, "consistency", thrift.I32, 16); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 16:consistency: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.Consistency)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.consistency (16) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 16:consistency: ", p), err)
		}
	}
	return err
}

func (p *TScan) writeField17(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetTargetReplicaId() {
		if err := oprot.WriteFieldBegin(ctx, "targetReplicaId", thrift.I32, 17); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 17:targetReplicaId: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.TargetReplicaId)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.targetReplicaId (17) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 17:targetReplicaId: ", p), err)
		}
	}
	return err
}

func (p *TScan) writeField18(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetFilterBytes() {
		if err := oprot.WriteFieldBegin(ctx, "filterBytes", thrift.STRING, 18); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 18:filterBytes: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.FilterBytes); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.filterBytes (18) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 18:filterBytes: ", p), err)
		}
	}
	return err
}

func (p *TScan) Equals(other *TScan) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.StartRow, other.StartRow) != 0 {
		return false
	}
	if bytes.Compare(p.StopRow, other.StopRow) != 0 {
		return false
	}
	if len(p.Columns) != len(other.Columns) {
		return false
	}
	for i, _tgt := range p.Columns {
		_src34 := other.Columns[i]
		if !_tgt.Equals(_src34) {
			return false
		}
	}
	if p.Caching != other.Caching {
		if p.Caching == nil || other.Caching == nil {
			return false
		}
		if (*p.Caching) != (*other.Caching) {
			return false
		}
	}
	if p.MaxVersions != other.MaxVersions {
		return false
	}
	if !p.TimeRange.Equals(other.TimeRange) {
		return false
	}
	if bytes.Compare(p.FilterString, other.FilterString) != 0 {
		return false
	}
	if p.BatchSize != other.BatchSize {
		if p.BatchSize == nil || other.BatchSize == nil {
			return false
		}
		if (*p.BatchSize) != (*other.BatchSize) {
			return false
		}
	}
	if len(p.Attributes) != len(other.Attributes) {
		return false
	}
	for k, _tgt := range p.Attributes {
		_src35 := other.Attributes[k]
		if bytes.Compare(_tgt, _src35) != 0 {
			return false
		}
	}
	if !p.Authorizations.Equals(other.Authorizations) {
		return false
	}
	if p.Reversed != other.Reversed {
		if p.Reversed == nil || other.Reversed == nil {
			return false
		}
		if (*p.Reversed) != (*other.Reversed) {
			return false
		}
	}
	if p.CacheBlocks != other.CacheBlocks {
		if p.CacheBlocks == nil || other.CacheBlocks == nil {
			return false
		}
		if (*p.CacheBlocks) != (*other.CacheBlocks) {
			return false
		}
	}
	if len(p.ColFamTimeRangeMap) != len(other.ColFamTimeRangeMap) {
		return false
	}
	for k, _tgt := range p.ColFamTimeRangeMap {
		_src36 := other.ColFamTimeRangeMap[k]
		if !_tgt.Equals(_src36) {
			return false
		}
	}
	if p.ReadType != other.ReadType {
		if p.ReadType == nil || other.ReadType == nil {
			return false
		}
		if (*p.ReadType) != (*other.ReadType) {
			return false
		}
	}
	if p.Limit != other.Limit {
		if p.Limit == nil || other.Limit == nil {
			return false
		}
		if (*p.Limit) != (*other.Limit) {
			return false
		}
	}
	if p.Consistency != other.Consistency {
		if p.Consistency == nil || other.Consistency == nil {
			return false
		}
		if (*p.Consistency) != (*other.Consistency) {
			return false
		}
	}
	if p.TargetReplicaId != other.TargetReplicaId {
		if p.TargetReplicaId == nil || other.TargetReplicaId == nil {
			return false
		}
		if (*p.TargetReplicaId) != (*other.TargetReplicaId) {
			return false
		}
	}
	if bytes.Compare(p.FilterBytes, other.FilterBytes) != 0 {
		return false
	}
	return true
}

func (p *TScan) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TScan(%+v)", *p)
}

func (p *TScan) Validate() error {
	return nil
}

// Atomic mutation for the specified row. It can be either Put or Delete.
//
// Attributes:
//   - Put
//   - DeleteSingle
type TMutation struct {
	Put          *TPut    `thrift:"put,1" db:"put" json:"put,omitempty"`
	DeleteSingle *TDelete `thrift:"deleteSingle,2" db:"deleteSingle" json:"deleteSingle,omitempty"`
}

func NewTMutation() *TMutation {
	return &TMutation{}
}

var TMutation_Put_DEFAULT *TPut

func (p *TMutation) GetPut() *TPut {
	if !p.IsSetPut() {
		return TMutation_Put_DEFAULT
	}
	return p.Put
}

var TMutation_DeleteSingle_DEFAULT *TDelete

func (p *TMutation) GetDeleteSingle() *TDelete {
	if !p.IsSetDeleteSingle() {
		return TMutation_DeleteSingle_DEFAULT
	}
	return p.DeleteSingle
}
func (p *TMutation) CountSetFieldsTMutation() int {
	count := 0
	if p.IsSetPut() {
		count++
	}
	if p.IsSetDeleteSingle() {
		count++
	}
	return count

}

func (p *TMutation) IsSetPut() bool {
	return p.Put != nil
}

func (p *TMutation) IsSetDeleteSingle() bool {
	return p.DeleteSingle != nil
}

func (p *TMutation) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TMutation) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Put = &TPut{}
	if err := p.Put.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Put), err)
	}
	return nil
}

func (p *TMutation) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.DeleteSingle = &TDelete{
		DeleteType: 1,
	}
	if err := p.DeleteSingle.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.DeleteSingle), err)
	}
	return nil
}

func (p *TMutation) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if c := p.CountSetFieldsTMutation(); c != 1 {
		return fmt.Errorf("%T write union: exactly one field must be set (%d set)", p, c)
	}
	if err := oprot.WriteStructBegin(ctx, "TMutation"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TMutation) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetPut() {
		if err := oprot.WriteFieldBegin(ctx, "put", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:put: ", p), err)
		}
		if err := p.Put.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Put), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:put: ", p), err)
		}
	}
	return err
}

func (p *TMutation) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetDeleteSingle() {
		if err := oprot.WriteFieldBegin(ctx, "deleteSingle", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:deleteSingle: ", p), err)
		}
		if err := p.DeleteSingle.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.DeleteSingle), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:deleteSingle: ", p), err)
		}
	}
	return err
}

func (p *TMutation) Equals(other *TMutation) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if !p.Put.Equals(other.Put) {
		return false
	}
	if !p.DeleteSingle.Equals(other.DeleteSingle) {
		return false
	}
	return true
}

func (p *TMutation) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TMutation(%+v)", *p)
}

func (p *TMutation) Validate() error {
	return nil
}

// A TRowMutations object is used to apply a number of Mutations to a single row.
//
// Attributes:
//   - Row
//   - Mutations
type TRowMutations struct {
	Row       []byte       `thrift:"row,1,required" db:"row" json:"row"`
	Mutations []*TMutation `thrift:"mutations,2,required" db:"mutations" json:"mutations"`
}

func NewTRowMutations() *TRowMutations {
	return &TRowMutations{}
}

func (p *TRowMutations) GetRow() []byte {
	return p.Row
}

func (p *TRowMutations) GetMutations() []*TMutation {
	return p.Mutations
}
func (p *TRowMutations) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetRow bool = false
	var issetMutations bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetRow = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetMutations = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetRow {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"))
	}
	if !issetMutations {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Mutations is not set"))
	}
	return nil
}

func (p *TRowMutations) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *TRowMutations) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TMutation, 0, size)
	p.Mutations = tSlice
	for i := 0; i < size; i++ {
		_elem37 := &TMutation{}
		if err := _elem37.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem37), err)
		}
		p.Mutations = append(p.Mutations, _elem37)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *TRowMutations) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TRowMutations"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TRowMutations) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:row: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Row); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.row (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:row: ", p), err)
	}
	return err
}

func (p *TRowMutations) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "mutations", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:mutations: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Mutations)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Mutations {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:mutations: ", p), err)
	}
	return err
}

func (p *TRowMutations) Equals(other *TRowMutations) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.Row, other.Row) != 0 {
		return false
	}
	if len(p.Mutations) != len(other.Mutations) {
		return false
	}
	for i, _tgt := range p.Mutations {
		_src38 := other.Mutations[i]
		if !_tgt.Equals(_src38) {
			return false
		}
	}
	return true
}

func (p *TRowMutations) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TRowMutations(%+v)", *p)
}

func (p *TRowMutations) Validate() error {
	return nil
}

// Attributes:
//   - RegionId
//   - TableName
//   - StartKey
//   - EndKey
//   - Offline
//   - Split
//   - ReplicaId
type THRegionInfo struct {
	RegionId  int64  `thrift:"regionId,1,required" db:"regionId" json:"regionId"`
	TableName []byte `thrift:"tableName,2,required" db:"tableName" json:"tableName"`
	StartKey  []byte `thrift:"startKey,3" db:"startKey" json:"startKey,omitempty"`
	EndKey    []byte `thrift:"endKey,4" db:"endKey" json:"endKey,omitempty"`
	Offline   *bool  `thrift:"offline,5" db:"offline" json:"offline,omitempty"`
	Split     *bool  `thrift:"split,6" db:"split" json:"split,omitempty"`
	ReplicaId *int32 `thrift:"replicaId,7" db:"replicaId" json:"replicaId,omitempty"`
}

func NewTHRegionInfo() *THRegionInfo {
	return &THRegionInfo{}
}

func (p *THRegionInfo) GetRegionId() int64 {
	return p.RegionId
}

func (p *THRegionInfo) GetTableName() []byte {
	return p.TableName
}

var THRegionInfo_StartKey_DEFAULT []byte

func (p *THRegionInfo) GetStartKey() []byte {
	return p.StartKey
}

var THRegionInfo_EndKey_DEFAULT []byte

func (p *THRegionInfo) GetEndKey() []byte {
	return p.EndKey
}

var THRegionInfo_Offline_DEFAULT bool

func (p *THRegionInfo) GetOffline() bool {
	if !p.IsSetOffline() {
		return THRegionInfo_Offline_DEFAULT
	}
	return *p.Offline
}

var THRegionInfo_Split_DEFAULT bool

func (p *THRegionInfo) GetSplit() bool {
	if !p.IsSetSplit() {
		return THRegionInfo_Split_DEFAULT
	}
	return *p.Split
}

var THRegionInfo_ReplicaId_DEFAULT int32

func (p *THRegionInfo) GetReplicaId() int32 {
	if !p.IsSetReplicaId() {
		return THRegionInfo_ReplicaId_DEFAULT
	}
	return *p.ReplicaId
}
func (p *THRegionInfo) IsSetStartKey() bool {
	return p.StartKey != nil
}

func (p *THRegionInfo) IsSetEndKey() bool {
	return p.EndKey != nil
}

func (p *THRegionInfo) IsSetOffline() bool {
	return p.Offline != nil
}

func (p *THRegionInfo) IsSetSplit() bool {
	return p.Split != nil
}

func (p *THRegionInfo) IsSetReplicaId() bool {
	return p.ReplicaId != nil
}

func (p *THRegionInfo) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetRegionId bool = false
	var issetTableName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetRegionId = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetTableName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetRegionId {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RegionId is not set"))
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	return nil
}

func (p *THRegionInfo) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.RegionId = v
	}
	return nil
}

func (p *THRegionInfo) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.TableName = v
	}
	return nil
}

func (p *THRegionInfo) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.StartKey = v
	}
	return nil
}

func (p *THRegionInfo) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.EndKey = v
	}
	return nil
}

func (p *THRegionInfo) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.Offline = &v
	}
	return nil
}

func (p *THRegionInfo) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.Split = &v
	}
	return nil
}

func (p *THRegionInfo) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 7: ", err)
	} else {
		p.ReplicaId = &v
	}
	return nil
}

func (p *THRegionInfo) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "THRegionInfo"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField4(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField5(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField6(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField7(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THRegionInfo) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "regionId", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:regionId: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.RegionId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.regionId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:regionId: ", p), err)
	}
	return err
}

func (p *THRegionInfo) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tableName: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.TableName); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.tableName (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tableName: ", p), err)
	}
	return err
}

func (p *THRegionInfo) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetStartKey() {
		if err := oprot.WriteFieldBegin(ctx, "startKey", thrift.STRING, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:startKey: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.StartKey); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.startKey (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:startKey: ", p), err)
		}
	}
	return err
}

func (p *THRegionInfo) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetEndKey() {
		if err := oprot.WriteFieldBegin(ctx, "endKey", thrift.STRING, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:endKey: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.EndKey); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.endKey (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:endKey: ", p), err)
		}
	}
	return err
}

func (p *THRegionInfo) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetOffline() {
		if err := oprot.WriteFieldBegin(ctx, "offline", thrift.BOOL, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:offline: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Offline)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.offline (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:offline: ", p), err)
		}
	}
	return err
}

func (p *THRegionInfo) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSplit() {
		if err := oprot.WriteFieldBegin(ctx, "split", thrift.BOOL, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:split: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Split)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.split (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:split: ", p), err)
		}
	}
	return err
}

func (p *THRegionInfo) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetReplicaId() {
		if err := oprot.WriteFieldBegin(ctx, "replicaId", thrift.I32, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:replicaId: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.ReplicaId)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.replicaId (7) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:replicaId: ", p), err)
		}
	}
	return err
}

func (p *THRegionInfo) Equals(other *THRegionInfo) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.RegionId != other.RegionId {
		return false
	}
	if bytes.Compare(p.TableName, other.TableName) != 0 {
		return false
	}
	if bytes.Compare(p.StartKey, other.StartKey) != 0 {
		return false
	}
	if bytes.Compare(p.EndKey, other.EndKey) != 0 {
		return false
	}
	if p.Offline != other.Offline {
		if p.Offline == nil || other.Offline == nil {
			return false
		}
		if (*p.Offline) != (*other.Offline) {
			return false
		}
	}
	if p.Split != other.Split {
		if p.Split == nil || other.Split == nil {
			return false
		}
		if (*p.Split) != (*other.Split) {
			return false
		}
	}
	if p.ReplicaId != other.ReplicaId {
		if p.ReplicaId == nil || other.ReplicaId == nil {
			return false
		}
		if (*p.ReplicaId) != (*other.ReplicaId) {
			return false
		}
	}
	return true
}

func (p *THRegionInfo) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THRegionInfo(%+v)", *p)
}

func (p *THRegionInfo) Validate() error {
	return nil
}

// Attributes:
//   - HostName
//   - Port
//   - StartCode
type TServerName struct {
	HostName  string `thrift:"hostName,1,required" db:"hostName" json:"hostName"`
	Port      *int32 `thrift:"port,2" db:"port" json:"port,omitempty"`
	StartCode *int64 `thrift:"startCode,3" db:"startCode" json:"startCode,omitempty"`
}

func NewTServerName() *TServerName {
	return &TServerName{}
}

func (p *TServerName) GetHostName() string {
	return p.HostName
}

var TServerName_Port_DEFAULT int32

func (p *TServerName) GetPort() int32 {
	if !p.IsSetPort() {
		return TServerName_Port_DEFAULT
	}
	return *p.Port
}

var TServerName_StartCode_DEFAULT int64

func (p *TServerName) GetStartCode() int64 {
	if !p.IsSetStartCode() {
		return TServerName_StartCode_DEFAULT
	}
	return *p.StartCode
}
func (p *TServerName) IsSetPort() bool {
	return p.Port != nil
}

func (p *TServerName) IsSetStartCode() bool {
	return p.StartCode != nil
}

func (p *TServerName) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetHostName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetHostName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetHostName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field HostName is not set"))
	}
	return nil
}

func (p *TServerName) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.HostName = v
	}
	return nil
}

func (p *TServerName) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Port = &v
	}
	return nil
}

func (p *TServerName) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.StartCode = &v
	}
	return nil
}

func (p *TServerName) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TServerName"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TServerName) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "hostName", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:hostName: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.HostName)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.hostName (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:hostName: ", p), err)
	}
	return err
}

func (p *TServerName) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetPort() {
		if err := oprot.WriteFieldBegin(ctx, "port", thrift.I32, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:port: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.Port)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.port (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:port: ", p), err)
		}
	}
	return err
}

func (p *TServerName) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetStartCode() {
		if err := oprot.WriteFieldBegin(ctx, "startCode", thrift.I64, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:startCode: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.StartCode)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.startCode (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:startCode: ", p), err)
		}
	}
	return err
}

func (p *TServerName) Equals(other *TServerName) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.HostName != other.HostName {
		return false
	}
	if p.Port != other.Port {
		if p.Port == nil || other.Port == nil {
			return false
		}
		if (*p.Port) != (*other.Port) {
			return false
		}
	}
	if p.StartCode != other.StartCode {
		if p.StartCode == nil || other.StartCode == nil {
			return false
		}
		if (*p.StartCode) != (*other.StartCode) {
			return false
		}
	}
	return true
}

func (p *TServerName) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TServerName(%+v)", *p)
}

func (p *TServerName) Validate() error {
	return nil
}

// Attributes:
//   - ServerName
//   - RegionInfo
type THRegionLocation struct {
	ServerName *TServerName  `thrift:"serverName,1,required" db:"serverName" json:"serverName"`
	RegionInfo *THRegionInfo `thrift:"regionInfo,2,required" db:"regionInfo" json:"regionInfo"`
}

func NewTHRegionLocation() *THRegionLocation {
	return &THRegionLocation{}
}

var THRegionLocation_ServerName_DEFAULT *TServerName

func (p *THRegionLocation) GetServerName() *TServerName {
	if !p.IsSetServerName() {
		return THRegionLocation_ServerName_DEFAULT
	}
	return p.ServerName
}

var THRegionLocation_RegionInfo_DEFAULT *THRegionInfo

func (p *THRegionLocation) GetRegionInfo() *THRegionInfo {
	if !p.IsSetRegionInfo() {
		return THRegionLocation_RegionInfo_DEFAULT
	}
	return p.RegionInfo
}
func (p *THRegionLocation) IsSetServerName() bool {
	return p.ServerName != nil
}

func (p *THRegionLocation) IsSetRegionInfo() bool {
	return p.RegionInfo != nil
}

func (p *THRegionLocation) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetServerName bool = false
	var issetRegionInfo bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetServerName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetRegionInfo = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetServerName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ServerName is not set"))
	}
	if !issetRegionInfo {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RegionInfo is not set"))
	}
	return nil
}

func (p *THRegionLocation) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.ServerName = &TServerName{}
	if err := p.ServerName.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ServerName), err)
	}
	return nil
}

func (p *THRegionLocation) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.RegionInfo = &THRegionInfo{}
	if err := p.RegionInfo.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.RegionInfo), err)
	}
	return nil
}

func (p *THRegionLocation) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "THRegionLocation"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THRegionLocation) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "serverName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:serverName: ", p), err)
	}
	if err := p.ServerName.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ServerName), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:serverName: ", p), err)
	}
	return err
}

func (p *THRegionLocation) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "regionInfo", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:regionInfo: ", p), err)
	}
	if err := p.RegionInfo.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.RegionInfo), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:regionInfo: ", p), err)
	}
	return err
}

func (p *THRegionLocation) Equals(other *THRegionLocation) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if !p.ServerName.Equals(other.ServerName) {
		return false
	}
	if !p.RegionInfo.Equals(other.RegionInfo) {
		return false
	}
	return true
}

func (p *THRegionLocation) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THRegionLocation(%+v)", *p)
}

func (p *THRegionLocation) Validate() error {
	return nil
}

// Thrift wrapper around
// org.apache.hadoop.hbase.TableName
//
// Attributes:
//   - Ns: namespace name
//   - Qualifier: tablename
type TTableName struct {
	Ns        []byte `thrift:"ns,1" db:"ns" json:"ns,omitempty"`
	Qualifier []byte `thrift:"qualifier,2,required" db:"qualifier" json:"qualifier"`
}

func NewTTableName() *TTableName {
	return &TTableName{}
}

var TTableName_Ns_DEFAULT []byte

func (p *TTableName) GetNs() []byte {
	return p.Ns
}

func (p *TTableName) GetQualifier() []byte {
	return p.Qualifier
}
func (p *TTableName) IsSetNs() bool {
	return p.Ns != nil
}

func (p *TTableName) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetQualifier bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetQualifier = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetQualifier {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Qualifier is not set"))
	}
	return nil
}

func (p *TTableName) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Ns = v
	}
	return nil
}

func (p *TTableName) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Qualifier = v
	}
	return nil
}

func (p *TTableName) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TTableName"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TTableName) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetNs() {
		if err := oprot.WriteFieldBegin(ctx, "ns", thrift.STRING, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ns: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.Ns); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.ns (1) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ns: ", p), err)
		}
	}
	return err
}

func (p *TTableName) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "qualifier", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:qualifier: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Qualifier); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.qualifier (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:qualifier: ", p), err)
	}
	return err
}

func (p *TTableName) Equals(other *TTableName) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.Ns, other.Ns) != 0 {
		return false
	}
	if bytes.Compare(p.Qualifier, other.Qualifier) != 0 {
		return false
	}
	return true
}

func (p *TTableName) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TTableName(%+v)", *p)
}

func (p *TTableName) Validate() error {
	return nil
}

// Thrift wrapper around
// org.apache.hadoop.hbase.client.ColumnFamilyDescriptor
//
// Attributes:
//   - Name
//   - Attributes
//   - Configuration
//   - BlockSize
//   - BloomnFilterType
//   - CompressionType
//   - DfsReplication
//   - DataBlockEncoding
//   - KeepDeletedCells
//   - MaxVersions
//   - MinVersions
//   - Scope
//   - TimeToLive
//   - BlockCacheEnabled
//   - CacheBloomsOnWrite
//   - CacheDataOnWrite
//   - CacheIndexesOnWrite
//   - CompressTags
//   - EvictBlocksOnClose
//   - InMemory
type TColumnFamilyDescriptor struct {
	Name                []byte                 `thrift:"name,1,required" db:"name" json:"name"`
	Attributes          map[string][]byte      `thrift:"attributes,2" db:"attributes" json:"attributes,omitempty"`
	Configuration       map[string]string      `thrift:"configuration,3" db:"configuration" json:"configuration,omitempty"`
	BlockSize           *int32                 `thrift:"blockSize,4" db:"blockSize" json:"blockSize,omitempty"`
	BloomnFilterType    *TBloomFilterType      `thrift:"bloomnFilterType,5" db:"bloomnFilterType" json:"bloomnFilterType,omitempty"`
	CompressionType     *TCompressionAlgorithm `thrift:"compressionType,6" db:"compressionType" json:"compressionType,omitempty"`
	DfsReplication      *int16                 `thrift:"dfsReplication,7" db:"dfsReplication" json:"dfsReplication,omitempty"`
	DataBlockEncoding   *TDataBlockEncoding    `thrift:"dataBlockEncoding,8" db:"dataBlockEncoding" json:"dataBlockEncoding,omitempty"`
	KeepDeletedCells    *TKeepDeletedCells     `thrift:"keepDeletedCells,9" db:"keepDeletedCells" json:"keepDeletedCells,omitempty"`
	MaxVersions         *int32                 `thrift:"maxVersions,10" db:"maxVersions" json:"maxVersions,omitempty"`
	MinVersions         *int32                 `thrift:"minVersions,11" db:"minVersions" json:"minVersions,omitempty"`
	Scope               *int32                 `thrift:"scope,12" db:"scope" json:"scope,omitempty"`
	TimeToLive          *int32                 `thrift:"timeToLive,13" db:"timeToLive" json:"timeToLive,omitempty"`
	BlockCacheEnabled   *bool                  `thrift:"blockCacheEnabled,14" db:"blockCacheEnabled" json:"blockCacheEnabled,omitempty"`
	CacheBloomsOnWrite  *bool                  `thrift:"cacheBloomsOnWrite,15" db:"cacheBloomsOnWrite" json:"cacheBloomsOnWrite,omitempty"`
	CacheDataOnWrite    *bool                  `thrift:"cacheDataOnWrite,16" db:"cacheDataOnWrite" json:"cacheDataOnWrite,omitempty"`
	CacheIndexesOnWrite *bool                  `thrift:"cacheIndexesOnWrite,17" db:"cacheIndexesOnWrite" json:"cacheIndexesOnWrite,omitempty"`
	CompressTags        *bool                  `thrift:"compressTags,18" db:"compressTags" json:"compressTags,omitempty"`
	EvictBlocksOnClose  *bool                  `thrift:"evictBlocksOnClose,19" db:"evictBlocksOnClose" json:"evictBlocksOnClose,omitempty"`
	InMemory            *bool                  `thrift:"inMemory,20" db:"inMemory" json:"inMemory,omitempty"`
}

func NewTColumnFamilyDescriptor() *TColumnFamilyDescriptor {
	return &TColumnFamilyDescriptor{}
}

func (p *TColumnFamilyDescriptor) GetName() []byte {
	return p.Name
}

var TColumnFamilyDescriptor_Attributes_DEFAULT map[string][]byte

func (p *TColumnFamilyDescriptor) GetAttributes() map[string][]byte {
	return p.Attributes
}

var TColumnFamilyDescriptor_Configuration_DEFAULT map[string]string

func (p *TColumnFamilyDescriptor) GetConfiguration() map[string]string {
	return p.Configuration
}

var TColumnFamilyDescriptor_BlockSize_DEFAULT int32

func (p *TColumnFamilyDescriptor) GetBlockSize() int32 {
	if !p.IsSetBlockSize() {
		return TColumnFamilyDescriptor_BlockSize_DEFAULT
	}
	return *p.BlockSize
}

var TColumnFamilyDescriptor_BloomnFilterType_DEFAULT TBloomFilterType

func (p *TColumnFamilyDescriptor) GetBloomnFilterType() TBloomFilterType {
	if !p.IsSetBloomnFilterType() {
		return TColumnFamilyDescriptor_BloomnFilterType_DEFAULT
	}
	return *p.BloomnFilterType
}

var TColumnFamilyDescriptor_CompressionType_DEFAULT TCompressionAlgorithm

func (p *TColumnFamilyDescriptor) GetCompressionType() TCompressionAlgorithm {
	if !p.IsSetCompressionType() {
		return TColumnFamilyDescriptor_CompressionType_DEFAULT
	}
	return *p.CompressionType
}

var TColumnFamilyDescriptor_DfsReplication_DEFAULT int16

func (p *TColumnFamilyDescriptor) GetDfsReplication() int16 {
	if !p.IsSetDfsReplication() {
		return TColumnFamilyDescriptor_DfsReplication_DEFAULT
	}
	return *p.DfsReplication
}

var TColumnFamilyDescriptor_DataBlockEncoding_DEFAULT TDataBlockEncoding

func (p *TColumnFamilyDescriptor) GetDataBlockEncoding() TDataBlockEncoding {
	if !p.IsSetDataBlockEncoding() {
		return TColumnFamilyDescriptor_DataBlockEncoding_DEFAULT
	}
	return *p.DataBlockEncoding
}

var TColumnFamilyDescriptor_KeepDeletedCells_DEFAULT TKeepDeletedCells

func (p *TColumnFamilyDescriptor) GetKeepDeletedCells() TKeepDeletedCells {
	if !p.IsSetKeepDeletedCells() {
		return TColumnFamilyDescriptor_KeepDeletedCells_DEFAULT
	}
	return *p.KeepDeletedCells
}

var TColumnFamilyDescriptor_MaxVersions_DEFAULT int32

func (p *TColumnFamilyDescriptor) GetMaxVersions() int32 {
	if !p.IsSetMaxVersions() {
		return TColumnFamilyDescriptor_MaxVersions_DEFAULT
	}
	return *p.MaxVersions
}

var TColumnFamilyDescriptor_MinVersions_DEFAULT int32

func (p *TColumnFamilyDescriptor) GetMinVersions() int32 {
	if !p.IsSetMinVersions() {
		return TColumnFamilyDescriptor_MinVersions_DEFAULT
	}
	return *p.MinVersions
}

var TColumnFamilyDescriptor_Scope_DEFAULT int32

func (p *TColumnFamilyDescriptor) GetScope() int32 {
	if !p.IsSetScope() {
		return TColumnFamilyDescriptor_Scope_DEFAULT
	}
	return *p.Scope
}

var TColumnFamilyDescriptor_TimeToLive_DEFAULT int32

func (p *TColumnFamilyDescriptor) GetTimeToLive() int32 {
	if !p.IsSetTimeToLive() {
		return TColumnFamilyDescriptor_TimeToLive_DEFAULT
	}
	return *p.TimeToLive
}

var TColumnFamilyDescriptor_BlockCacheEnabled_DEFAULT bool

func (p *TColumnFamilyDescriptor) GetBlockCacheEnabled() bool {
	if !p.IsSetBlockCacheEnabled() {
		return TColumnFamilyDescriptor_BlockCacheEnabled_DEFAULT
	}
	return *p.BlockCacheEnabled
}

var TColumnFamilyDescriptor_CacheBloomsOnWrite_DEFAULT bool

func (p *TColumnFamilyDescriptor) GetCacheBloomsOnWrite() bool {
	if !p.IsSetCacheBloomsOnWrite() {
		return TColumnFamilyDescriptor_CacheBloomsOnWrite_DEFAULT
	}
	return *p.CacheBloomsOnWrite
}

var TColumnFamilyDescriptor_CacheDataOnWrite_DEFAULT bool

func (p *TColumnFamilyDescriptor) GetCacheDataOnWrite() bool {
	if !p.IsSetCacheDataOnWrite() {
		return TColumnFamilyDescriptor_CacheDataOnWrite_DEFAULT
	}
	return *p.CacheDataOnWrite
}

var TColumnFamilyDescriptor_CacheIndexesOnWrite_DEFAULT bool

func (p *TColumnFamilyDescriptor) GetCacheIndexesOnWrite() bool {
	if !p.IsSetCacheIndexesOnWrite() {
		return TColumnFamilyDescriptor_CacheIndexesOnWrite_DEFAULT
	}
	return *p.CacheIndexesOnWrite
}

var TColumnFamilyDescriptor_CompressTags_DEFAULT bool

func (p *TColumnFamilyDescriptor) GetCompressTags() bool {
	if !p.IsSetCompressTags() {
		return TColumnFamilyDescriptor_CompressTags_DEFAULT
	}
	return *p.CompressTags
}

var TColumnFamilyDescriptor_EvictBlocksOnClose_DEFAULT bool

func (p *TColumnFamilyDescriptor) GetEvictBlocksOnClose() bool {
	if !p.IsSetEvictBlocksOnClose() {
		return TColumnFamilyDescriptor_EvictBlocksOnClose_DEFAULT
	}
	return *p.EvictBlocksOnClose
}

var TColumnFamilyDescriptor_InMemory_DEFAULT bool

func (p *TColumnFamilyDescriptor) GetInMemory() bool {
	if !p.IsSetInMemory() {
		return TColumnFamilyDescriptor_InMemory_DEFAULT
	}
	return *p.InMemory
}
func (p *TColumnFamilyDescriptor) IsSetAttributes() bool {
	return p.Attributes != nil
}

func (p *TColumnFamilyDescriptor) IsSetConfiguration() bool {
	return p.Configuration != nil
}

func (p *TColumnFamilyDescriptor) IsSetBlockSize() bool {
	return p.BlockSize != nil
}

func (p *TColumnFamilyDescriptor) IsSetBloomnFilterType() bool {
	return p.BloomnFilterType != nil
}

func (p *TColumnFamilyDescriptor) IsSetCompressionType() bool {
	return p.CompressionType != nil
}

func (p *TColumnFamilyDescriptor) IsSetDfsReplication() bool {
	return p.DfsReplication != nil
}

func (p *TColumnFamilyDescriptor) IsSetDataBlockEncoding() bool {
	return p.DataBlockEncoding != nil
}

func (p *TColumnFamilyDescriptor) IsSetKeepDeletedCells() bool {
	return p.KeepDeletedCells != nil
}

func (p *TColumnFamilyDescriptor) IsSetMaxVersions() bool {
	return p.MaxVersions != nil
}

func (p *TColumnFamilyDescriptor) IsSetMinVersions() bool {
	return p.MinVersions != nil
}

func (p *TColumnFamilyDescriptor) IsSetScope() bool {
	return p.Scope != nil
}

func (p *TColumnFamilyDescriptor) IsSetTimeToLive() bool {
	return p.TimeToLive != nil
}

func (p *TColumnFamilyDescriptor) IsSetBlockCacheEnabled() bool {
	return p.BlockCacheEnabled != nil
}

func (p *TColumnFamilyDescriptor) IsSetCacheBloomsOnWrite() bool {
	return p.CacheBloomsOnWrite != nil
}

func (p *TColumnFamilyDescriptor) IsSetCacheDataOnWrite() bool {
	return p.CacheDataOnWrite != nil
}

func (p *TColumnFamilyDescriptor) IsSetCacheIndexesOnWrite() bool {
	return p.CacheIndexesOnWrite != nil
}

func (p *TColumnFamilyDescriptor) IsSetCompressTags() bool {
	return p.CompressTags != nil
}

func (p *TColumnFamilyDescriptor) IsSetEvictBlocksOnClose() bool {
	return p.EvictBlocksOnClose != nil
}

func (p *TColumnFamilyDescriptor) IsSetInMemory() bool {
	return p.InMemory != nil
}

func (p *TColumnFamilyDescriptor) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.I16 {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 8:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField8(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 9:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField9(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 10:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField10(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 11:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField11(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 12:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField12(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 13:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField13(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 14:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField14(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 15:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField15(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 16:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField16(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 17:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField17(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 18:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField18(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 19:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField19(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 20:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField20(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string][]byte, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key39 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key39 = v
		}
		var _val40 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val40 = v
		}
		p.Attributes[_key39] = _val40
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string]string, size)
	p.Configuration = tMap
	for i := 0; i < size; i++ {
		var _key41 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key41 = v
		}
		var _val42 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val42 = v
		}
		p.Configuration[_key41] = _val42
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.BlockSize = &v
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		temp := TBloomFilterType(v)
		p.BloomnFilterType = &temp
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		temp := TCompressionAlgorithm(v)
		p.CompressionType = &temp
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI16(ctx); err != nil {
		return thrift.PrependError("error reading field 7: ", err)
	} else {
		p.DfsReplication = &v
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 8: ", err)
	} else {
		temp := TDataBlockEncoding(v)
		p.DataBlockEncoding = &temp
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 9: ", err)
	} else {
		temp := TKeepDeletedCells(v)
		p.KeepDeletedCells = &temp
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 10: ", err)
	} else {
		p.MaxVersions = &v
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 11: ", err)
	} else {
		p.MinVersions = &v
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 12: ", err)
	} else {
		p.Scope = &v
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField13(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 13: ", err)
	} else {
		p.TimeToLive = &v
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField14(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 14: ", err)
	} else {
		p.BlockCacheEnabled = &v
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField15(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 15: ", err)
	} else {
		p.CacheBloomsOnWrite = &v
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField16(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 16: ", err)
	} else {
		p.CacheDataOnWrite = &v
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField17(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 17: ", err)
	} else {
		p.CacheIndexesOnWrite = &v
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField18(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 18: ", err)
	} else {
		p.CompressTags = &v
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField19(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 19: ", err)
	} else {
		p.EvictBlocksOnClose = &v
	}
	return nil
}

func (p *TColumnFamilyDescriptor) ReadField20(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 20: ", err)
	} else {
		p.InMemory = &v
	}
	return nil
}

func (p *TColumnFamilyDescriptor) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TColumnFamilyDescriptor"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField4(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField5(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField6(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField7(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField8(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField9(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField10(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField11(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField12(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField13(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField14(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField15(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField16(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField17(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField18(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField19(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField20(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TColumnFamilyDescriptor) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Name); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *TColumnFamilyDescriptor) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetAttributes() {
		if err := oprot.WriteFieldBegin(ctx, "attributes", thrift.MAP, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:attributes: ", p), err)
		}
		if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(ctx, string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteBinary(ctx, v); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(ctx); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:attributes: ", p), err)
		}
	}
	return err
}

func (p *TColumnFamilyDescriptor) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetConfiguration() {
		if err := oprot.WriteFieldBegin(ctx, "configuration", thrift.MAP, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:configuration: ", p), err)
		}
		if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Configuration)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.Configuration {
			if err := oprot.WriteString(ctx, string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteString(ctx, string(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(ctx); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:configuration: ", p), err)
		}
	}
	return err
}

func (p *TColumnFamilyDescriptor) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetBlockSize() {
		if err := oprot.WriteFieldBegin(ctx, "blockSize", thrift.I32, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:blockSize: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.BlockSize)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.blockSize (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:blockSize: ", p), err)
		}
	}
	return err
}

func (p *TColumnFamilyDescriptor) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetBloomnFilterType() {
		if err := oprot.WriteFieldBegin(ctx, "bloomnFilterType", thrift.I32, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:bloomnFilterType: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.BloomnFilterType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.bloomnFilterType (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:bloomnFilterType: ", p), err)
		}
	}
	return err
}

func (p *TColumnFamilyDescriptor) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetCompressionType() {
		if err := oprot.WriteFieldBegin(ctx, "compressionType", thrift.I32, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:compressionType: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.CompressionType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.compressionType (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:compressionType: ", p), err)
		}
	}
	return err
}

func (p *TColumnFamilyDescriptor) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetDfsReplication() {
		if err := oprot.WriteFieldBegin(ctx, "dfsReplication", thrift.I16, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:dfsReplication: ", p), err)
		}
		if err := oprot.WriteI16(ctx, int16(*p.DfsReplication)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.dfsReplication (7) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:dfsReplication: ", p), err)
		}
	}
	return err
}

func (p *TColumnFamilyDescriptor) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetDataBlockEncoding() {
		if err := oprot.WriteFieldBegin(ctx, "dataBlockEncoding", thrift.I32, 8); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:dataBlockEncoding: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.DataBlockEncoding)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.dataBlockEncoding (8) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 8:dataBlockEncoding: ", p), err)
		}
	}
	return err
}

func (p *TColumnFamilyDescriptor) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetKeepDeletedCells() {
		if err := oprot.WriteFieldBegin(ctx, "keepDeletedCells", thrift.I32, 9); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:keepDeletedCells: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.KeepDeletedCells)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.keepDeletedCells (9) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 9:keepDeletedCells: ", p), err)
		}
	}
	return err
}

func (p *TColumnFamilyDescriptor) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetMaxVersions() {
		if err := oprot.WriteFieldBegin(ctx, "maxVersions", thrift.I32, 10); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:maxVersions: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.MaxVersions)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.maxVersions (10) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 10:maxVersions: ", p), err)
		}
	}
	return err
}

func (p *TColumnFamilyDescriptor) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetMinVersions() {
		if err := oprot.WriteFieldBegin(ctx, "minVersions", thrift.I32, 11); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:minVersions: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.MinVersions)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.minVersions (11) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 11:minVersions: ", p), err)
		}
	}
	return err
}

func (p *TColumnFamilyDescriptor) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetScope() {
		if err := oprot.WriteFieldBegin(ctx, "scope", thrift.I32, 12); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:scope: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.Scope)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.scope (12) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 12:scope: ", p), err)
		}
	}
	return err
}

func (p *TColumnFamilyDescriptor) writeField13(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetTimeToLive() {
		if err := oprot.WriteFieldBegin(ctx, "timeToLive", thrift.I32, 13); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 13:timeToLive: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.TimeToLive)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.timeToLive (13) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 13:timeToLive: ", p), err)
		}
	}
	return err
}

func (p *TColumnFamilyDescriptor) writeField14(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetBlockCacheEnabled() {
		if err := oprot.WriteFieldBegin(ctx, "blockCacheEnabled", thrift.BOOL, 14); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 14:blockCacheEnabled: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.BlockCacheEnabled)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.blockCacheEnabled (14) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 14:blockCacheEnabled: ", p), err)
		}
	}
	return err
}

func (p *TColumnFamilyDescriptor) writeField15(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetCacheBloomsOnWrite() {
		if err := oprot.WriteFieldBegin(ctx, "cacheBloomsOnWrite", thrift.BOOL, 15); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 15:cacheBloomsOnWrite: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.CacheBloomsOnWrite)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.cacheBloomsOnWrite (15) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 15:cacheBloomsOnWrite: ", p), err)
		}
	}
	return err
}

func (p *TColumnFamilyDescriptor) writeField16(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetCacheDataOnWrite() {
		if err := oprot.WriteFieldBegin(ctx, "cacheDataOnWrite", thrift.BOOL, 16); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 16:cacheDataOnWrite: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.CacheDataOnWrite)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.cacheDataOnWrite (16) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 16:cacheDataOnWrite: ", p), err)
		}
	}
	return err
}

func (p *TColumnFamilyDescriptor) writeField17(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetCacheIndexesOnWrite() {
		if err := oprot.WriteFieldBegin(ctx, "cacheIndexesOnWrite", thrift.BOOL, 17); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 17:cacheIndexesOnWrite: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.CacheIndexesOnWrite)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.cacheIndexesOnWrite (17) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 17:cacheIndexesOnWrite: ", p), err)
		}
	}
	return err
}

func (p *TColumnFamilyDescriptor) writeField18(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetCompressTags() {
		if err := oprot.WriteFieldBegin(ctx, "compressTags", thrift.BOOL, 18); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 18:compressTags: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.CompressTags)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.compressTags (18) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 18:compressTags: ", p), err)
		}
	}
	return err
}

func (p *TColumnFamilyDescriptor) writeField19(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetEvictBlocksOnClose() {
		if err := oprot.WriteFieldBegin(ctx, "evictBlocksOnClose", thrift.BOOL, 19); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 19:evictBlocksOnClose: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.EvictBlocksOnClose)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.evictBlocksOnClose (19) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 19:evictBlocksOnClose: ", p), err)
		}
	}
	return err
}

func (p *TColumnFamilyDescriptor) writeField20(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetInMemory() {
		if err := oprot.WriteFieldBegin(ctx, "inMemory", thrift.BOOL, 20); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 20:inMemory: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.InMemory)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.inMemory (20) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 20:inMemory: ", p), err)
		}
	}
	return err
}

func (p *TColumnFamilyDescriptor) Equals(other *TColumnFamilyDescriptor) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.Name, other.Name) != 0 {
		return false
	}
	if len(p.Attributes) != len(other.Attributes) {
		return false
	}
	for k, _tgt := range p.Attributes {
		_src43 := other.Attributes[k]
		if bytes.Compare(_tgt, _src43) != 0 {
			return false
		}
	}
	if len(p.Configuration) != len(other.Configuration) {
		return false
	}
	for k, _tgt := range p.Configuration {
		_src44 := other.Configuration[k]
		if _tgt != _src44 {
			return false
		}
	}
	if p.BlockSize != other.BlockSize {
		if p.BlockSize == nil || other.BlockSize == nil {
			return false
		}
		if (*p.BlockSize) != (*other.BlockSize) {
			return false
		}
	}
	if p.BloomnFilterType != other.BloomnFilterType {
		if p.BloomnFilterType == nil || other.BloomnFilterType == nil {
			return false
		}
		if (*p.BloomnFilterType) != (*other.BloomnFilterType) {
			return false
		}
	}
	if p.CompressionType != other.CompressionType {
		if p.CompressionType == nil || other.CompressionType == nil {
			return false
		}
		if (*p.CompressionType) != (*other.CompressionType) {
			return false
		}
	}
	if p.DfsReplication != other.DfsReplication {
		if p.DfsReplication == nil || other.DfsReplication == nil {
			return false
		}
		if (*p.DfsReplication) != (*other.DfsReplication) {
			return false
		}
	}
	if p.DataBlockEncoding != other.DataBlockEncoding {
		if p.DataBlockEncoding == nil || other.DataBlockEncoding == nil {
			return false
		}
		if (*p.DataBlockEncoding) != (*other.DataBlockEncoding) {
			return false
		}
	}
	if p.KeepDeletedCells != other.KeepDeletedCells {
		if p.KeepDeletedCells == nil || other.KeepDeletedCells == nil {
			return false
		}
		if (*p.KeepDeletedCells) != (*other.KeepDeletedCells) {
			return false
		}
	}
	if p.MaxVersions != other.MaxVersions {
		if p.MaxVersions == nil || other.MaxVersions == nil {
			return false
		}
		if (*p.MaxVersions) != (*other.MaxVersions) {
			return false
		}
	}
	if p.MinVersions != other.MinVersions {
		if p.MinVersions == nil || other.MinVersions == nil {
			return false
		}
		if (*p.MinVersions) != (*other.MinVersions) {
			return false
		}
	}
	if p.Scope != other.Scope {
		if p.Scope == nil || other.Scope == nil {
			return false
		}
		if (*p.Scope) != (*other.Scope) {
			return false
		}
	}
	if p.TimeToLive != other.TimeToLive {
		if p.TimeToLive == nil || other.TimeToLive == nil {
			return false
		}
		if (*p.TimeToLive) != (*other.TimeToLive) {
			return false
		}
	}
	if p.BlockCacheEnabled != other.BlockCacheEnabled {
		if p.BlockCacheEnabled == nil || other.BlockCacheEnabled == nil {
			return false
		}
		if (*p.BlockCacheEnabled) != (*other.BlockCacheEnabled) {
			return false
		}
	}
	if p.CacheBloomsOnWrite != other.CacheBloomsOnWrite {
		if p.CacheBloomsOnWrite == nil || other.CacheBloomsOnWrite == nil {
			return false
		}
		if (*p.CacheBloomsOnWrite) != (*other.CacheBloomsOnWrite) {
			return false
		}
	}
	if p.CacheDataOnWrite != other.CacheDataOnWrite {
		if p.CacheDataOnWrite == nil || other.CacheDataOnWrite == nil {
			return false
		}
		if (*p.CacheDataOnWrite) != (*other.CacheDataOnWrite) {
			return false
		}
	}
	if p.CacheIndexesOnWrite != other.CacheIndexesOnWrite {
		if p.CacheIndexesOnWrite == nil || other.CacheIndexesOnWrite == nil {
			return false
		}
		if (*p.CacheIndexesOnWrite) != (*other.CacheIndexesOnWrite) {
			return false
		}
	}
	if p.CompressTags != other.CompressTags {
		if p.CompressTags == nil || other.CompressTags == nil {
			return false
		}
		if (*p.CompressTags) != (*other.CompressTags) {
			return false
		}
	}
	if p.EvictBlocksOnClose != other.EvictBlocksOnClose {
		if p.EvictBlocksOnClose == nil || other.EvictBlocksOnClose == nil {
			return false
		}
		if (*p.EvictBlocksOnClose) != (*other.EvictBlocksOnClose) {
			return false
		}
	}
	if p.InMemory != other.InMemory {
		if p.InMemory == nil || other.InMemory == nil {
			return false
		}
		if (*p.InMemory) != (*other.InMemory) {
			return false
		}
	}
	return true
}

func (p *TColumnFamilyDescriptor) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TColumnFamilyDescriptor(%+v)", *p)
}

func (p *TColumnFamilyDescriptor) Validate() error {
	return nil
}

// Thrift wrapper around
// org.apache.hadoop.hbase.client.TableDescriptor
//
// Attributes:
//   - TableName
//   - Columns
//   - Attributes
//   - Durability
type TTableDescriptor struct {
	TableName  *TTableName                `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
	Columns    []*TColumnFamilyDescriptor `thrift:"columns,2" db:"columns" json:"columns,omitempty"`
	Attributes map[string][]byte          `thrift:"attributes,3" db:"attributes" json:"attributes,omitempty"`
	Durability *TDurability               `thrift:"durability,4" db:"durability" json:"durability,omitempty"`
}

func NewTTableDescriptor() *TTableDescriptor {
	return &TTableDescriptor{}
}

var TTableDescriptor_TableName_DEFAULT *TTableName

func (p *TTableDescriptor) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return TTableDescriptor_TableName_DEFAULT
	}
	return p.TableName
}

var TTableDescriptor_Columns_DEFAULT []*TColumnFamilyDescriptor

func (p *TTableDescriptor) GetColumns() []*TColumnFamilyDescriptor {
	return p.Columns
}

var TTableDescriptor_Attributes_DEFAULT map[string][]byte

func (p *TTableDescriptor) GetAttributes() map[string][]byte {
	return p.Attributes
}

var TTableDescriptor_Durability_DEFAULT TDurability

func (p *TTableDescriptor) GetDurability() TDurability {
	if !p.IsSetDurability() {
		return TTableDescriptor_Durability_DEFAULT
	}
	return *p.Durability
}
func (p *TTableDescriptor) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *TTableDescriptor) IsSetColumns() bool {
	return p.Columns != nil
}

func (p *TTableDescriptor) IsSetAttributes() bool {
	return p.Attributes != nil
}

func (p *TTableDescriptor) IsSetDurability() bool {
	return p.Durability != nil
}

func (p *TTableDescriptor) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTableName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	return nil
}

func (p *TTableDescriptor) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *TTableDescriptor) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TColumnFamilyDescriptor, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		_elem45 := &TColumnFamilyDescriptor{}
		if err := _elem45.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem45), err)
		}
		p.Columns = append(p.Columns, _elem45)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *TTableDescriptor) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string][]byte, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key46 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key46 = v
		}
		var _val47 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val47 = v
		}
		p.Attributes[_key46] = _val47
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *TTableDescriptor) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := TDurability(v)
		p.Durability = &temp
	}
	return nil
}

func (p *TTableDescriptor) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TTableDescriptor"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField4(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TTableDescriptor) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *TTableDescriptor) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetColumns() {
		if err := oprot.WriteFieldBegin(ctx, "columns", thrift.LIST, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Columns)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Columns {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns: ", p), err)
		}
	}
	return err
}

func (p *TTableDescriptor) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetAttributes() {
		if err := oprot.WriteFieldBegin(ctx, "attributes", thrift.MAP, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:attributes: ", p), err)
		}
		if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(ctx, string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteBinary(ctx, v); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(ctx); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:attributes: ", p), err)
		}
	}
	return err
}

func (p *TTableDescriptor) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetDurability() {
		if err := oprot.WriteFieldBegin(ctx, "durability", thrift.I32, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:durability: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.Durability)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.durability (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:durability: ", p), err)
		}
	}
	return err
}

func (p *TTableDescriptor) Equals(other *TTableDescriptor) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if !p.TableName.Equals(other.TableName) {
		return false
	}
	if len(p.Columns) != len(other.Columns) {
		return false
	}
	for i, _tgt := range p.Columns {
		_src48 := other.Columns[i]
		if !_tgt.Equals(_src48) {
			return false
		}
	}
	if len(p.Attributes) != len(other.Attributes) {
		return false
	}
	for k, _tgt := range p.Attributes {
		_src49 := other.Attributes[k]
		if bytes.Compare(_tgt, _src49) != 0 {
			return false
		}
	}
	if p.Durability != other.Durability {
		if p.Durability == nil || other.Durability == nil {
			return false
		}
		if (*p.Durability) != (*other.Durability) {
			return false
		}
	}
	return true
}

func (p *TTableDescriptor) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TTableDescriptor(%+v)", *p)
}

func (p *TTableDescriptor) Validate() error {
	return nil
}

// Thrift wrapper around
// org.apache.hadoop.hbase.NamespaceDescriptor
//
// Attributes:
//   - Name
//   - Configuration
type TNamespaceDescriptor struct {
	Name          string            `thrift:"name,1,required" db:"name" json:"name"`
	Configuration map[string]string `thrift:"configuration,2" db:"configuration" json:"configuration,omitempty"`
}

func NewTNamespaceDescriptor() *TNamespaceDescriptor {
	return &TNamespaceDescriptor{}
}

func (p *TNamespaceDescriptor) GetName() string {
	return p.Name
}

var TNamespaceDescriptor_Configuration_DEFAULT map[string]string

func (p *TNamespaceDescriptor) GetConfiguration() map[string]string {
	return p.Configuration
}
func (p *TNamespaceDescriptor) IsSetConfiguration() bool {
	return p.Configuration != nil
}

func (p *TNamespaceDescriptor) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	return nil
}

func (p *TNamespaceDescriptor) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *TNamespaceDescriptor) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string]string, size)
	p.Configuration = tMap
	for i := 0; i < size; i++ {
		var _key50 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key50 = v
		}
		var _val51 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val51 = v
		}
		p.Configuration[_key50] = _val51
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *TNamespaceDescriptor) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TNamespaceDescriptor"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TNamespaceDescriptor) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *TNamespaceDescriptor) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetConfiguration() {
		if err := oprot.WriteFieldBegin(ctx, "configuration", thrift.MAP, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:configuration: ", p), err)
		}
		if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Configuration)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.Configuration {
			if err := oprot.WriteString(ctx, string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteString(ctx, string(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(ctx); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:configuration: ", p), err)
		}
	}
	return err
}

func (p *TNamespaceDescriptor) Equals(other *TNamespaceDescriptor) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Name != other.Name {
		return false
	}
	if len(p.Configuration) != len(other.Configuration) {
		return false
	}
	for k, _tgt := range p.Configuration {
		_src52 := other.Configuration[k]
		if _tgt != _src52 {
			return false
		}
	}
	return true
}

func (p *TNamespaceDescriptor) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TNamespaceDescriptor(%+v)", *p)
}

func (p *TNamespaceDescriptor) Validate() error {
	return nil
}

// A TIOError exception signals that an error occurred communicating
// to the HBase master or a HBase region server. Also used to return
// more general HBase error conditions.
//
// Attributes:
//   - Message
type TIOError struct {
	Message *string `thrift:"message,1" db:"message" json:"message,omitempty"`
}

func NewTIOError() *TIOError {
	return &TIOError{}
}

var TIOError_Message_DEFAULT string

func (p *TIOError) GetMessage() string {
	if !p.IsSetMessage() {
		return TIOError_Message_DEFAULT
	}
	return *p.Message
}
func (p *TIOError) IsSetMessage() bool {
	return p.Message != nil
}

func (p *TIOError) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TIOError) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Message = &v
	}
	return nil
}

func (p *TIOError) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TIOError"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TIOError) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetMessage() {
		if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:message: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.Message)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.message (1) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:message: ", p), err)
		}
	}
	return err
}

func (p *TIOError) Equals(other *TIOError) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Message != other.Message {
		if p.Message == nil || other.Message == nil {
			return false
		}
		if (*p.Message) != (*other.Message) {
			return false
		}
	}
	return true
}

func (p *TIOError) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TIOError(%+v)", *p)
}

func (p *TIOError) Error() string {
	return p.String()
}

func (TIOError) TExceptionType() thrift.TExceptionType {
	return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*TIOError)(nil)

func (p *TIOError) Validate() error {
	return nil
}

// A TIllegalArgument exception indicates an illegal or invalid
// argument was passed into a procedure.
//
// Attributes:
//   - Message
type TIllegalArgument struct {
	Message *string `thrift:"message,1" db:"message" json:"message,omitempty"`
}

func NewTIllegalArgument() *TIllegalArgument {
	return &TIllegalArgument{}
}

var TIllegalArgument_Message_DEFAULT string

func (p *TIllegalArgument) GetMessage() string {
	if !p.IsSetMessage() {
		return TIllegalArgument_Message_DEFAULT
	}
	return *p.Message
}
func (p *TIllegalArgument) IsSetMessage() bool {
	return p.Message != nil
}

func (p *TIllegalArgument) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TIllegalArgument) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Message = &v
	}
	return nil
}

func (p *TIllegalArgument) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TIllegalArgument"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TIllegalArgument) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetMessage() {
		if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:message: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.Message)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.message (1) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:message: ", p), err)
		}
	}
	return err
}

func (p *TIllegalArgument) Equals(other *TIllegalArgument) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Message != other.Message {
		if p.Message == nil || other.Message == nil {
			return false
		}
		if (*p.Message) != (*other.Message) {
			return false
		}
	}
	return true
}

func (p *TIllegalArgument) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TIllegalArgument(%+v)", *p)
}

func (p *TIllegalArgument) Error() string {
	return p.String()
}

func (TIllegalArgument) TExceptionType() thrift.TExceptionType {
	return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*TIllegalArgument)(nil)

func (p *TIllegalArgument) Validate() error {
	return nil
}

type THBaseService interface {
	// Test for the existence of columns in the table, as specified in the TGet.
	//
	// @return true if the specified TGet matches one or more keys, false if not
	//
	// Parameters:
	//  - Table: the table to check on
	//  - Tget: the TGet to check for
	Exists(ctx context.Context, table []byte, tget *TGet) (_r bool, _err error)
	// Test for the existence of columns in the table, as specified by the TGets.
	//
	// This will return an array of booleans. Each value will be true if the related Get matches
	// one or more keys, false if not.
	//
	// Parameters:
	//  - Table: the table to check on
	//  - Tgets: a list of TGets to check for
	ExistsAll(ctx context.Context, table []byte, tgets []*TGet) (_r []bool, _err error)
	// Method for getting data from a row.
	//
	// If the row cannot be found an empty Result is returned.
	// This can be checked by the empty field of the TResult
	//
	// @return the result
	//
	// Parameters:
	//  - Table: the table to get from
	//  - Tget: the TGet to fetch
	Get(ctx context.Context, table []byte, tget *TGet) (_r *TResult_, _err error)
	// Method for getting multiple rows.
	//
	// If a row cannot be found there will be a null
	// value in the result list for that TGet at the
	// same position.
	//
	// So the Results are in the same order as the TGets.
	//
	// Parameters:
	//  - Table: the table to get from
	//  - Tgets: a list of TGets to fetch, the Result list
	// will have the Results at corresponding positions
	// or null if there was an error
	GetMultiple(ctx context.Context, table []byte, tgets []*TGet) (_r []*TResult_, _err error)
	// Commit a TPut to a table.
	//
	// Parameters:
	//  - Table: the table to put data in
	//  - Tput: the TPut to put
	Put(ctx context.Context, table []byte, tput *TPut) (_err error)
	// Atomically checks if a row/family/qualifier value matches the expected
	// value. If it does, it adds the TPut.
	//
	// @return true if the new put was executed, false otherwise
	//
	// Parameters:
	//  - Table: to check in and put to
	//  - Row: row to check
	//  - Family: column family to check
	//  - Qualifier: column qualifier to check
	//  - Value: the expected value, if not provided the
	// check is for the non-existence of the
	// column in question
	//  - Tput: the TPut to put if the check succeeds
	CheckAndPut(ctx context.Context, table []byte, row []byte, family []byte, qualifier []byte, value []byte, tput *TPut) (_r bool, _err error)
	// Commit a List of Puts to the table.
	//
	// Parameters:
	//  - Table: the table to put data in
	//  - Tputs: a list of TPuts to commit
	PutMultiple(ctx context.Context, table []byte, tputs []*TPut) (_err error)
	// Deletes as specified by the TDelete.
	//
	// Note: "delete" is a reserved keyword and cannot be used in Thrift
	// thus the inconsistent naming scheme from the other functions.
	//
	// Parameters:
	//  - Table: the table to delete from
	//  - Tdelete: the TDelete to delete
	DeleteSingle(ctx context.Context, table []byte, tdelete *TDelete) (_err error)
	// Bulk commit a List of TDeletes to the table.
	//
	// Throws a TIOError if any of the deletes fail.
	//
	// Always returns an empty list for backwards compatibility.
	//
	// Parameters:
	//  - Table: the table to delete from
	//  - Tdeletes: list of TDeletes to delete
	DeleteMultiple(ctx context.Context, table []byte, tdeletes []*TDelete) (_r []*TDelete, _err error)
	// Atomically checks if a row/family/qualifier value matches the expected
	// value. If it does, it adds the delete.
	//
	// @return true if the new delete was executed, false otherwise
	//
	// Parameters:
	//  - Table: to check in and delete from
	//  - Row: row to check
	//  - Family: column family to check
	//  - Qualifier: column qualifier to check
	//  - Value: the expected value, if not provided the
	// check is for the non-existence of the
	// column in question
	//  - Tdelete: the TDelete to execute if the check succeeds
	CheckAndDelete(ctx context.Context, table []byte, row []byte, family []byte, qualifier []byte, value []byte, tdelete *TDelete) (_r bool, _err error)
	// Parameters:
	//  - Table: the table to increment the value on
	//  - Tincrement: the TIncrement to increment
	Increment(ctx context.Context, table []byte, tincrement *TIncrement) (_r *TResult_, _err error)
	// Parameters:
	//  - Table: the table to append the value on
	//  - Tappend: the TAppend to append
	Append(ctx context.Context, table []byte, tappend *TAppend) (_r *TResult_, _err error)
	// Get a Scanner for the provided TScan object.
	//
	// @return Scanner Id to be used with other scanner procedures
	//
	// Parameters:
	//  - Table: the table to get the Scanner for
	//  - Tscan: the scan object to get a Scanner for
	OpenScanner(ctx context.Context, table []byte, tscan *TScan) (_r int32, _err error)
	// Grabs multiple rows from a Scanner.
	//
	// @return Between zero and numRows TResults
	//
	// Parameters:
	//  - ScannerId: the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
	//  - NumRows: number of rows to return
	GetScannerRows(ctx context.Context, scannerId int32, numRows int32) (_r []*TResult_, _err error)
	// Closes the scanner. Should be called to free server side resources timely.
	// Typically close once the scanner is not needed anymore, i.e. after looping
	// over it to get all the required rows.
	//
	// Parameters:
	//  - ScannerId: the Id of the Scanner to close *
	CloseScanner(ctx context.Context, scannerId int32) (_err error)
	// mutateRow performs multiple mutations atomically on a single row.
	//
	// Parameters:
	//  - Table: table to apply the mutations
	//  - TrowMutations: mutations to apply
	MutateRow(ctx context.Context, table []byte, trowMutations *TRowMutations) (_err error)
	// Get results for the provided TScan object.
	// This helper function opens a scanner, get the results and close the scanner.
	//
	// @return between zero and numRows TResults
	//
	// Parameters:
	//  - Table: the table to get the Scanner for
	//  - Tscan: the scan object to get a Scanner for
	//  - NumRows: number of rows to return
	GetScannerResults(ctx context.Context, table []byte, tscan *TScan, numRows int32) (_r []*TResult_, _err error)
	// Given a table and a row get the location of the region that
	// would contain the given row key.
	//
	// reload = true means the cache will be cleared and the location
	// will be fetched from meta.
	//
	// Parameters:
	//  - Table
	//  - Row
	//  - Reload
	GetRegionLocation(ctx context.Context, table []byte, row []byte, reload bool) (_r *THRegionLocation, _err error)
	// Get all of the region locations for a given table.
	//
	//
	// Parameters:
	//  - Table
	GetAllRegionLocations(ctx context.Context, table []byte) (_r []*THRegionLocation, _err error)
	// Atomically checks if a row/family/qualifier value matches the expected
	// value. If it does, it mutates the row.
	//
	// @return true if the row was mutated, false otherwise
	//
	// Parameters:
	//  - Table: to check in and delete from
	//  - Row: row to check
	//  - Family: column family to check
	//  - Qualifier: column qualifier to check
	//  - CompareOp: comparison to make on the value
	//  - Value: the expected value to be compared against, if not provided the
	// check is for the non-existence of the column in question
	//  - RowMutations: row mutations to execute if the value matches
	CheckAndMutate(ctx context.Context, table []byte, row []byte, family []byte, qualifier []byte, compareOp TCompareOp, value []byte, rowMutations *TRowMutations) (_r bool, _err error)
	// Get a table descriptor.
	// @return the TableDescriptor of the giving tablename
	//
	//
	// Parameters:
	//  - Table: the tablename of the table to get tableDescriptor
	GetTableDescriptor(ctx context.Context, table *TTableName) (_r *TTableDescriptor, _err error)
	// Get table descriptors of tables.
	// @return the TableDescriptor of the giving tablename
	//
	//
	// Parameters:
	//  - Tables: the tablename list of the tables to get tableDescriptor
	GetTableDescriptors(ctx context.Context, tables []*TTableName) (_r []*TTableDescriptor, _err error)
	//
	// @return true if table exists already, false if not
	//
	//
	// Parameters:
	//  - TableName: the tablename of the tables to check
	TableExists(ctx context.Context, tableName *TTableName) (_r bool, _err error)
	// Get table descriptors of tables that match the given pattern
	// @return the tableDescriptors of the matching table
	//
	//
	// Parameters:
	//  - Regex: The regular expression to match against
	//  - IncludeSysTables: set to false if match only against userspace tables
	GetTableDescriptorsByPattern(ctx context.Context, regex string, includeSysTables bool) (_r []*TTableDescriptor, _err error)
	// Get table descriptors of tables in the given namespace
	// @return the tableDescriptors in the namespce
	//
	//
	// Parameters:
	//  - Name: The namesapce's name
	GetTableDescriptorsByNamespace(ctx context.Context, name string) (_r []*TTableDescriptor, _err error)
	// Get table names of tables that match the given pattern
	// @return the table names of the matching table
	//
	//
	// Parameters:
	//  - Regex: The regular expression to match against
	//  - IncludeSysTables: set to false if match only against userspace tables
	GetTableNamesByPattern(ctx context.Context, regex string, includeSysTables bool) (_r []*TTableName, _err error)
	// Get table names of tables in the given namespace
	// @return the table names of the matching table
	//
	//
	// Parameters:
	//  - Name: The namesapce's name
	GetTableNamesByNamespace(ctx context.Context, name string) (_r []*TTableName, _err error)
	// Creates a new table with an initial set of empty regions defined by the specified split keys.
	// The total number of regions created will be the number of split keys plus one. Synchronous
	// operation.
	//
	//
	// Parameters:
	//  - Desc: table descriptor for table
	//  - SplitKeys: rray of split keys for the initial regions of the table
	CreateTable(ctx context.Context, desc *TTableDescriptor, splitKeys [][]byte) (_err error)
	// Deletes a table. Synchronous operation.
	//
	//
	// Parameters:
	//  - TableName: the tablename to delete
	DeleteTable(ctx context.Context, tableName *TTableName) (_err error)
	// Truncate a table. Synchronous operation.
	//
	//
	// Parameters:
	//  - TableName: the tablename to truncate
	//  - PreserveSplits: whether to  preserve previous splits
	TruncateTable(ctx context.Context, tableName *TTableName, preserveSplits bool) (_err error)
	// Enalbe a table
	//
	//
	// Parameters:
	//  - TableName: the tablename to enable
	EnableTable(ctx context.Context, tableName *TTableName) (_err error)
	// Disable a table
	//
	//
	// Parameters:
	//  - TableName: the tablename to disable
	DisableTable(ctx context.Context, tableName *TTableName) (_err error)
	//
	// @return true if table is enabled, false if not
	//
	//
	// Parameters:
	//  - TableName: the tablename to check
	IsTableEnabled(ctx context.Context, tableName *TTableName) (_r bool, _err error)
	//
	// @return true if table is disabled, false if not
	//
	//
	// Parameters:
	//  - TableName: the tablename to check
	IsTableDisabled(ctx context.Context, tableName *TTableName) (_r bool, _err error)
	//
	// @return true if table is available, false if not
	//
	//
	// Parameters:
	//  - TableName: the tablename to check
	IsTableAvailable(ctx context.Context, tableName *TTableName) (_r bool, _err error)
	//  * Use this api to check if the table has been created with the specified number of splitkeys
	//  * which was used while creating the given table. Note : If this api is used after a table's
	//  * region gets splitted, the api may return false.
	//  *
	//  * @return true if table is available, false if not
	//  *
	//  * @deprecated Since 2.2.0. Because the same method in Table interface has been deprecated
	//  * since 2.0.0, we will remove it in 3.0.0 release.
	//  * Use {@link #isTableAvailable(TTableName tableName)} instead
	// *
	//
	// Parameters:
	//  - TableName: the tablename to check
	//  - SplitKeys: keys to check if the table has been created with all split keys
	IsTableAvailableWithSplit(ctx context.Context, tableName *TTableName, splitKeys [][]byte) (_r bool, _err error)
	// Add a column family to an existing table. Synchronous operation.
	//
	//
	// Parameters:
	//  - TableName: the tablename to add column family to
	//  - Column: column family descriptor of column family to be added
	AddColumnFamily(ctx context.Context, tableName *TTableName, column *TColumnFamilyDescriptor) (_err error)
	// Delete a column family from a table. Synchronous operation.
	//
	//
	// Parameters:
	//  - TableName: the tablename to delete column family from
	//  - Column: name of column family to be deleted
	DeleteColumnFamily(ctx context.Context, tableName *TTableName, column []byte) (_err error)
	// Modify an existing column family on a table. Synchronous operation.
	//
	//
	// Parameters:
	//  - TableName: the tablename to modify column family
	//  - Column: column family descriptor of column family to be modified
	ModifyColumnFamily(ctx context.Context, tableName *TTableName, column *TColumnFamilyDescriptor) (_err error)
	// Modify an existing table
	//
	//
	// Parameters:
	//  - Desc: the descriptor of the table to modify
	ModifyTable(ctx context.Context, desc *TTableDescriptor) (_err error)
	// Create a new namespace. Blocks until namespace has been successfully created or an exception is
	// thrown
	//
	//
	// Parameters:
	//  - NamespaceDesc: descriptor which describes the new namespace
	CreateNamespace(ctx context.Context, namespaceDesc *TNamespaceDescriptor) (_err error)
	// Modify an existing namespace.  Blocks until namespace has been successfully modified or an
	// exception is thrown
	//
	//
	// Parameters:
	//  - NamespaceDesc: descriptor which describes the new namespace
	ModifyNamespace(ctx context.Context, namespaceDesc *TNamespaceDescriptor) (_err error)
	// Delete an existing namespace. Only empty namespaces (no tables) can be removed.
	// Blocks until namespace has been successfully deleted or an
	// exception is thrown.
	//
	//
	// Parameters:
	//  - Name: namespace name
	DeleteNamespace(ctx context.Context, name string) (_err error)
	// Get a namespace descriptor by name.
	// @retrun the descriptor
	//
	//
	// Parameters:
	//  - Name: name of namespace descriptor
	GetNamespaceDescriptor(ctx context.Context, name string) (_r *TNamespaceDescriptor, _err error)
	// @return all namespaces
	//
	ListNamespaceDescriptors(ctx context.Context) (_r []*TNamespaceDescriptor, _err error)
}

type THBaseServiceClient struct {
	c    thrift.TClient
	meta thrift.ResponseMeta
}

func NewTHBaseServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *THBaseServiceClient {
	return &THBaseServiceClient{
		c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
	}
}

func NewTHBaseServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *THBaseServiceClient {
	return &THBaseServiceClient{
		c: thrift.NewTStandardClient(iprot, oprot),
	}
}

func NewTHBaseServiceClient(c thrift.TClient) *THBaseServiceClient {
	return &THBaseServiceClient{
		c: c,
	}
}

func (p *THBaseServiceClient) Client_() thrift.TClient {
	return p.c
}

func (p *THBaseServiceClient) LastResponseMeta_() thrift.ResponseMeta {
	return p.meta
}

func (p *THBaseServiceClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
	p.meta = meta
}

// Test for the existence of columns in the table, as specified in the TGet.
//
// @return true if the specified TGet matches one or more keys, false if not
//
// Parameters:
//   - Table: the table to check on
//   - Tget: the TGet to check for
func (p *THBaseServiceClient) Exists(ctx context.Context, table []byte, tget *TGet) (_r bool, _err error) {
	var _args53 THBaseServiceExistsArgs
	_args53.Table = table
	_args53.Tget = tget
	var _result55 THBaseServiceExistsResult
	var _meta54 thrift.ResponseMeta
	_meta54, _err = p.Client_().Call(ctx, "exists", &_args53, &_result55)
	p.SetLastResponseMeta_(_meta54)
	if _err != nil {
		return
	}
	switch {
	case _result55.Io != nil:
		return _r, _result55.Io
	}

	return _result55.GetSuccess(), nil
}

// Test for the existence of columns in the table, as specified by the TGets.
//
// This will return an array of booleans. Each value will be true if the related Get matches
// one or more keys, false if not.
//
// Parameters:
//   - Table: the table to check on
//   - Tgets: a list of TGets to check for
func (p *THBaseServiceClient) ExistsAll(ctx context.Context, table []byte, tgets []*TGet) (_r []bool, _err error) {
	var _args56 THBaseServiceExistsAllArgs
	_args56.Table = table
	_args56.Tgets = tgets
	var _result58 THBaseServiceExistsAllResult
	var _meta57 thrift.ResponseMeta
	_meta57, _err = p.Client_().Call(ctx, "existsAll", &_args56, &_result58)
	p.SetLastResponseMeta_(_meta57)
	if _err != nil {
		return
	}
	switch {
	case _result58.Io != nil:
		return _r, _result58.Io
	}

	return _result58.GetSuccess(), nil
}

// Method for getting data from a row.
//
// If the row cannot be found an empty Result is returned.
// This can be checked by the empty field of the TResult
//
// @return the result
//
// Parameters:
//   - Table: the table to get from
//   - Tget: the TGet to fetch
func (p *THBaseServiceClient) Get(ctx context.Context, table []byte, tget *TGet) (_r *TResult_, _err error) {
	var _args59 THBaseServiceGetArgs
	_args59.Table = table
	_args59.Tget = tget
	var _result61 THBaseServiceGetResult
	var _meta60 thrift.ResponseMeta
	_meta60, _err = p.Client_().Call(ctx, "get", &_args59, &_result61)
	p.SetLastResponseMeta_(_meta60)
	if _err != nil {
		return
	}
	switch {
	case _result61.Io != nil:
		return _r, _result61.Io
	}

	if _ret62 := _result61.GetSuccess(); _ret62 != nil {
		return _ret62, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "get failed: unknown result")
}

// Method for getting multiple rows.
//
// If a row cannot be found there will be a null
// value in the result list for that TGet at the
// same position.
//
// So the Results are in the same order as the TGets.
//
// Parameters:
//   - Table: the table to get from
//   - Tgets: a list of TGets to fetch, the Result list
//
// will have the Results at corresponding positions
// or null if there was an error
func (p *THBaseServiceClient) GetMultiple(ctx context.Context, table []byte, tgets []*TGet) (_r []*TResult_, _err error) {
	var _args63 THBaseServiceGetMultipleArgs
	_args63.Table = table
	_args63.Tgets = tgets
	var _result65 THBaseServiceGetMultipleResult
	var _meta64 thrift.ResponseMeta
	_meta64, _err = p.Client_().Call(ctx, "getMultiple", &_args63, &_result65)
	p.SetLastResponseMeta_(_meta64)
	if _err != nil {
		return
	}
	switch {
	case _result65.Io != nil:
		return _r, _result65.Io
	}

	return _result65.GetSuccess(), nil
}

// Commit a TPut to a table.
//
// Parameters:
//   - Table: the table to put data in
//   - Tput: the TPut to put
func (p *THBaseServiceClient) Put(ctx context.Context, table []byte, tput *TPut) (_err error) {
	var _args66 THBaseServicePutArgs
	_args66.Table = table
	_args66.Tput = tput
	var _result68 THBaseServicePutResult
	var _meta67 thrift.ResponseMeta
	_meta67, _err = p.Client_().Call(ctx, "put", &_args66, &_result68)
	p.SetLastResponseMeta_(_meta67)
	if _err != nil {
		return
	}
	switch {
	case _result68.Io != nil:
		return _result68.Io
	}

	return nil
}

// Atomically checks if a row/family/qualifier value matches the expected
// value. If it does, it adds the TPut.
//
// @return true if the new put was executed, false otherwise
//
// Parameters:
//   - Table: to check in and put to
//   - Row: row to check
//   - Family: column family to check
//   - Qualifier: column qualifier to check
//   - Value: the expected value, if not provided the
//
// check is for the non-existence of the
// column in question
//   - Tput: the TPut to put if the check succeeds
func (p *THBaseServiceClient) CheckAndPut(ctx context.Context, table []byte, row []byte, family []byte, qualifier []byte, value []byte, tput *TPut) (_r bool, _err error) {
	var _args69 THBaseServiceCheckAndPutArgs
	_args69.Table = table
	_args69.Row = row
	_args69.Family = family
	_args69.Qualifier = qualifier
	_args69.Value = value
	_args69.Tput = tput
	var _result71 THBaseServiceCheckAndPutResult
	var _meta70 thrift.ResponseMeta
	_meta70, _err = p.Client_().Call(ctx, "checkAndPut", &_args69, &_result71)
	p.SetLastResponseMeta_(_meta70)
	if _err != nil {
		return
	}
	switch {
	case _result71.Io != nil:
		return _r, _result71.Io
	}

	return _result71.GetSuccess(), nil
}

// Commit a List of Puts to the table.
//
// Parameters:
//   - Table: the table to put data in
//   - Tputs: a list of TPuts to commit
func (p *THBaseServiceClient) PutMultiple(ctx context.Context, table []byte, tputs []*TPut) (_err error) {
	var _args72 THBaseServicePutMultipleArgs
	_args72.Table = table
	_args72.Tputs = tputs
	var _result74 THBaseServicePutMultipleResult
	var _meta73 thrift.ResponseMeta
	_meta73, _err = p.Client_().Call(ctx, "putMultiple", &_args72, &_result74)
	p.SetLastResponseMeta_(_meta73)
	if _err != nil {
		return
	}
	switch {
	case _result74.Io != nil:
		return _result74.Io
	}

	return nil
}

// Deletes as specified by the TDelete.
//
// Note: "delete" is a reserved keyword and cannot be used in Thrift
// thus the inconsistent naming scheme from the other functions.
//
// Parameters:
//   - Table: the table to delete from
//   - Tdelete: the TDelete to delete
func (p *THBaseServiceClient) DeleteSingle(ctx context.Context, table []byte, tdelete *TDelete) (_err error) {
	var _args75 THBaseServiceDeleteSingleArgs
	_args75.Table = table
	_args75.Tdelete = tdelete
	var _result77 THBaseServiceDeleteSingleResult
	var _meta76 thrift.ResponseMeta
	_meta76, _err = p.Client_().Call(ctx, "deleteSingle", &_args75, &_result77)
	p.SetLastResponseMeta_(_meta76)
	if _err != nil {
		return
	}
	switch {
	case _result77.Io != nil:
		return _result77.Io
	}

	return nil
}

// Bulk commit a List of TDeletes to the table.
//
// Throws a TIOError if any of the deletes fail.
//
// Always returns an empty list for backwards compatibility.
//
// Parameters:
//   - Table: the table to delete from
//   - Tdeletes: list of TDeletes to delete
func (p *THBaseServiceClient) DeleteMultiple(ctx context.Context, table []byte, tdeletes []*TDelete) (_r []*TDelete, _err error) {
	var _args78 THBaseServiceDeleteMultipleArgs
	_args78.Table = table
	_args78.Tdeletes = tdeletes
	var _result80 THBaseServiceDeleteMultipleResult
	var _meta79 thrift.ResponseMeta
	_meta79, _err = p.Client_().Call(ctx, "deleteMultiple", &_args78, &_result80)
	p.SetLastResponseMeta_(_meta79)
	if _err != nil {
		return
	}
	switch {
	case _result80.Io != nil:
		return _r, _result80.Io
	}

	return _result80.GetSuccess(), nil
}

// Atomically checks if a row/family/qualifier value matches the expected
// value. If it does, it adds the delete.
//
// @return true if the new delete was executed, false otherwise
//
// Parameters:
//   - Table: to check in and delete from
//   - Row: row to check
//   - Family: column family to check
//   - Qualifier: column qualifier to check
//   - Value: the expected value, if not provided the
//
// check is for the non-existence of the
// column in question
//   - Tdelete: the TDelete to execute if the check succeeds
func (p *THBaseServiceClient) CheckAndDelete(ctx context.Context, table []byte, row []byte, family []byte, qualifier []byte, value []byte, tdelete *TDelete) (_r bool, _err error) {
	var _args81 THBaseServiceCheckAndDeleteArgs
	_args81.Table = table
	_args81.Row = row
	_args81.Family = family
	_args81.Qualifier = qualifier
	_args81.Value = value
	_args81.Tdelete = tdelete
	var _result83 THBaseServiceCheckAndDeleteResult
	var _meta82 thrift.ResponseMeta
	_meta82, _err = p.Client_().Call(ctx, "checkAndDelete", &_args81, &_result83)
	p.SetLastResponseMeta_(_meta82)
	if _err != nil {
		return
	}
	switch {
	case _result83.Io != nil:
		return _r, _result83.Io
	}

	return _result83.GetSuccess(), nil
}

// Parameters:
//   - Table: the table to increment the value on
//   - Tincrement: the TIncrement to increment
func (p *THBaseServiceClient) Increment(ctx context.Context, table []byte, tincrement *TIncrement) (_r *TResult_, _err error) {
	var _args84 THBaseServiceIncrementArgs
	_args84.Table = table
	_args84.Tincrement = tincrement
	var _result86 THBaseServiceIncrementResult
	var _meta85 thrift.ResponseMeta
	_meta85, _err = p.Client_().Call(ctx, "increment", &_args84, &_result86)
	p.SetLastResponseMeta_(_meta85)
	if _err != nil {
		return
	}
	switch {
	case _result86.Io != nil:
		return _r, _result86.Io
	}

	if _ret87 := _result86.GetSuccess(); _ret87 != nil {
		return _ret87, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "increment failed: unknown result")
}

// Parameters:
//   - Table: the table to append the value on
//   - Tappend: the TAppend to append
func (p *THBaseServiceClient) Append(ctx context.Context, table []byte, tappend *TAppend) (_r *TResult_, _err error) {
	var _args88 THBaseServiceAppendArgs
	_args88.Table = table
	_args88.Tappend = tappend
	var _result90 THBaseServiceAppendResult
	var _meta89 thrift.ResponseMeta
	_meta89, _err = p.Client_().Call(ctx, "append", &_args88, &_result90)
	p.SetLastResponseMeta_(_meta89)
	if _err != nil {
		return
	}
	switch {
	case _result90.Io != nil:
		return _r, _result90.Io
	}

	if _ret91 := _result90.GetSuccess(); _ret91 != nil {
		return _ret91, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "append failed: unknown result")
}

// Get a Scanner for the provided TScan object.
//
// @return Scanner Id to be used with other scanner procedures
//
// Parameters:
//   - Table: the table to get the Scanner for
//   - Tscan: the scan object to get a Scanner for
func (p *THBaseServiceClient) OpenScanner(ctx context.Context, table []byte, tscan *TScan) (_r int32, _err error) {
	var _args92 THBaseServiceOpenScannerArgs
	_args92.Table = table
	_args92.Tscan = tscan
	var _result94 THBaseServiceOpenScannerResult
	var _meta93 thrift.ResponseMeta
	_meta93, _err = p.Client_().Call(ctx, "openScanner", &_args92, &_result94)
	p.SetLastResponseMeta_(_meta93)
	if _err != nil {
		return
	}
	switch {
	case _result94.Io != nil:
		return _r, _result94.Io
	}

	return _result94.GetSuccess(), nil
}

// Grabs multiple rows from a Scanner.
//
// @return Between zero and numRows TResults
//
// Parameters:
//   - ScannerId: the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
//   - NumRows: number of rows to return
func (p *THBaseServiceClient) GetScannerRows(ctx context.Context, scannerId int32, numRows int32) (_r []*TResult_, _err error) {
	var _args95 THBaseServiceGetScannerRowsArgs
	_args95.ScannerId = scannerId
	_args95.NumRows = numRows
	var _result97 THBaseServiceGetScannerRowsResult
	var _meta96 thrift.ResponseMeta
	_meta96, _err = p.Client_().Call(ctx, "getScannerRows", &_args95, &_result97)
	p.SetLastResponseMeta_(_meta96)
	if _err != nil {
		return
	}
	switch {
	case _result97.Io != nil:
		return _r, _result97.Io
	case _result97.Ia != nil:
		return _r, _result97.Ia
	}

	return _result97.GetSuccess(), nil
}

// Closes the scanner. Should be called to free server side resources timely.
// Typically close once the scanner is not needed anymore, i.e. after looping
// over it to get all the required rows.
//
// Parameters:
//   - ScannerId: the Id of the Scanner to close *
func (p *THBaseServiceClient) CloseScanner(ctx context.Context, scannerId int32) (_err error) {
	var _args98 THBaseServiceCloseScannerArgs
	_args98.ScannerId = scannerId
	var _result100 THBaseServiceCloseScannerResult
	var _meta99 thrift.ResponseMeta
	_meta99, _err = p.Client_().Call(ctx, "closeScanner", &_args98, &_result100)
	p.SetLastResponseMeta_(_meta99)
	if _err != nil {
		return
	}
	switch {
	case _result100.Io != nil:
		return _result100.Io
	case _result100.Ia != nil:
		return _result100.Ia
	}

	return nil
}

// mutateRow performs multiple mutations atomically on a single row.
//
// Parameters:
//   - Table: table to apply the mutations
//   - TrowMutations: mutations to apply
func (p *THBaseServiceClient) MutateRow(ctx context.Context, table []byte, trowMutations *TRowMutations) (_err error) {
	var _args101 THBaseServiceMutateRowArgs
	_args101.Table = table
	_args101.TrowMutations = trowMutations
	var _result103 THBaseServiceMutateRowResult
	var _meta102 thrift.ResponseMeta
	_meta102, _err = p.Client_().Call(ctx, "mutateRow", &_args101, &_result103)
	p.SetLastResponseMeta_(_meta102)
	if _err != nil {
		return
	}
	switch {
	case _result103.Io != nil:
		return _result103.Io
	}

	return nil
}

// Get results for the provided TScan object.
// This helper function opens a scanner, get the results and close the scanner.
//
// @return between zero and numRows TResults
//
// Parameters:
//   - Table: the table to get the Scanner for
//   - Tscan: the scan object to get a Scanner for
//   - NumRows: number of rows to return
func (p *THBaseServiceClient) GetScannerResults(ctx context.Context, table []byte, tscan *TScan, numRows int32) (_r []*TResult_, _err error) {
	var _args104 THBaseServiceGetScannerResultsArgs
	_args104.Table = table
	_args104.Tscan = tscan
	_args104.NumRows = numRows
	var _result106 THBaseServiceGetScannerResultsResult
	var _meta105 thrift.ResponseMeta
	_meta105, _err = p.Client_().Call(ctx, "getScannerResults", &_args104, &_result106)
	p.SetLastResponseMeta_(_meta105)
	if _err != nil {
		return
	}
	switch {
	case _result106.Io != nil:
		return _r, _result106.Io
	}

	return _result106.GetSuccess(), nil
}

// Given a table and a row get the location of the region that
// would contain the given row key.
//
// reload = true means the cache will be cleared and the location
// will be fetched from meta.
//
// Parameters:
//   - Table
//   - Row
//   - Reload
func (p *THBaseServiceClient) GetRegionLocation(ctx context.Context, table []byte, row []byte, reload bool) (_r *THRegionLocation, _err error) {
	var _args107 THBaseServiceGetRegionLocationArgs
	_args107.Table = table
	_args107.Row = row
	_args107.Reload = reload
	var _result109 THBaseServiceGetRegionLocationResult
	var _meta108 thrift.ResponseMeta
	_meta108, _err = p.Client_().Call(ctx, "getRegionLocation", &_args107, &_result109)
	p.SetLastResponseMeta_(_meta108)
	if _err != nil {
		return
	}
	switch {
	case _result109.Io != nil:
		return _r, _result109.Io
	}

	if _ret110 := _result109.GetSuccess(); _ret110 != nil {
		return _ret110, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getRegionLocation failed: unknown result")
}

// Get all of the region locations for a given table.
//
// Parameters:
//   - Table
func (p *THBaseServiceClient) GetAllRegionLocations(ctx context.Context, table []byte) (_r []*THRegionLocation, _err error) {
	var _args111 THBaseServiceGetAllRegionLocationsArgs
	_args111.Table = table
	var _result113 THBaseServiceGetAllRegionLocationsResult
	var _meta112 thrift.ResponseMeta
	_meta112, _err = p.Client_().Call(ctx, "getAllRegionLocations", &_args111, &_result113)
	p.SetLastResponseMeta_(_meta112)
	if _err != nil {
		return
	}
	switch {
	case _result113.Io != nil:
		return _r, _result113.Io
	}

	return _result113.GetSuccess(), nil
}

// Atomically checks if a row/family/qualifier value matches the expected
// value. If it does, it mutates the row.
//
// @return true if the row was mutated, false otherwise
//
// Parameters:
//   - Table: to check in and delete from
//   - Row: row to check
//   - Family: column family to check
//   - Qualifier: column qualifier to check
//   - CompareOp: comparison to make on the value
//   - Value: the expected value to be compared against, if not provided the
//
// check is for the non-existence of the column in question
//   - RowMutations: row mutations to execute if the value matches
func (p *THBaseServiceClient) CheckAndMutate(ctx context.Context, table []byte, row []byte, family []byte, qualifier []byte, compareOp TCompareOp, value []byte, rowMutations *TRowMutations) (_r bool, _err error) {
	var _args114 THBaseServiceCheckAndMutateArgs
	_args114.Table = table
	_args114.Row = row
	_args114.Family = family
	_args114.Qualifier = qualifier
	_args114.CompareOp = compareOp
	_args114.Value = value
	_args114.RowMutations = rowMutations
	var _result116 THBaseServiceCheckAndMutateResult
	var _meta115 thrift.ResponseMeta
	_meta115, _err = p.Client_().Call(ctx, "checkAndMutate", &_args114, &_result116)
	p.SetLastResponseMeta_(_meta115)
	if _err != nil {
		return
	}
	switch {
	case _result116.Io != nil:
		return _r, _result116.Io
	}

	return _result116.GetSuccess(), nil
}

// Get a table descriptor.
// @return the TableDescriptor of the giving tablename
//
// Parameters:
//   - Table: the tablename of the table to get tableDescriptor
func (p *THBaseServiceClient) GetTableDescriptor(ctx context.Context, table *TTableName) (_r *TTableDescriptor, _err error) {
	var _args117 THBaseServiceGetTableDescriptorArgs
	_args117.Table = table
	var _result119 THBaseServiceGetTableDescriptorResult
	var _meta118 thrift.ResponseMeta
	_meta118, _err = p.Client_().Call(ctx, "getTableDescriptor", &_args117, &_result119)
	p.SetLastResponseMeta_(_meta118)
	if _err != nil {
		return
	}
	switch {
	case _result119.Io != nil:
		return _r, _result119.Io
	}

	if _ret120 := _result119.GetSuccess(); _ret120 != nil {
		return _ret120, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getTableDescriptor failed: unknown result")
}

// Get table descriptors of tables.
// @return the TableDescriptor of the giving tablename
//
// Parameters:
//   - Tables: the tablename list of the tables to get tableDescriptor
func (p *THBaseServiceClient) GetTableDescriptors(ctx context.Context, tables []*TTableName) (_r []*TTableDescriptor, _err error) {
	var _args121 THBaseServiceGetTableDescriptorsArgs
	_args121.Tables = tables
	var _result123 THBaseServiceGetTableDescriptorsResult
	var _meta122 thrift.ResponseMeta
	_meta122, _err = p.Client_().Call(ctx, "getTableDescriptors", &_args121, &_result123)
	p.SetLastResponseMeta_(_meta122)
	if _err != nil {
		return
	}
	switch {
	case _result123.Io != nil:
		return _r, _result123.Io
	}

	return _result123.GetSuccess(), nil
}

// @return true if table exists already, false if not
//
// Parameters:
//   - TableName: the tablename of the tables to check
func (p *THBaseServiceClient) TableExists(ctx context.Context, tableName *TTableName) (_r bool, _err error) {
	var _args124 THBaseServiceTableExistsArgs
	_args124.TableName = tableName
	var _result126 THBaseServiceTableExistsResult
	var _meta125 thrift.ResponseMeta
	_meta125, _err = p.Client_().Call(ctx, "tableExists", &_args124, &_result126)
	p.SetLastResponseMeta_(_meta125)
	if _err != nil {
		return
	}
	switch {
	case _result126.Io != nil:
		return _r, _result126.Io
	}

	return _result126.GetSuccess(), nil
}

// Get table descriptors of tables that match the given pattern
// @return the tableDescriptors of the matching table
//
// Parameters:
//   - Regex: The regular expression to match against
//   - IncludeSysTables: set to false if match only against userspace tables
func (p *THBaseServiceClient) GetTableDescriptorsByPattern(ctx context.Context, regex string, includeSysTables bool) (_r []*TTableDescriptor, _err error) {
	var _args127 THBaseServiceGetTableDescriptorsByPatternArgs
	_args127.Regex = regex
	_args127.IncludeSysTables = includeSysTables
	var _result129 THBaseServiceGetTableDescriptorsByPatternResult
	var _meta128 thrift.ResponseMeta
	_meta128, _err = p.Client_().Call(ctx, "getTableDescriptorsByPattern", &_args127, &_result129)
	p.SetLastResponseMeta_(_meta128)
	if _err != nil {
		return
	}
	switch {
	case _result129.Io != nil:
		return _r, _result129.Io
	}

	return _result129.GetSuccess(), nil
}

// Get table descriptors of tables in the given namespace
// @return the tableDescriptors in the namespce
//
// Parameters:
//   - Name: The namesapce's name
func (p *THBaseServiceClient) GetTableDescriptorsByNamespace(ctx context.Context, name string) (_r []*TTableDescriptor, _err error) {
	var _args130 THBaseServiceGetTableDescriptorsByNamespaceArgs
	_args130.Name = name
	var _result132 THBaseServiceGetTableDescriptorsByNamespaceResult
	var _meta131 thrift.ResponseMeta
	_meta131, _err = p.Client_().Call(ctx, "getTableDescriptorsByNamespace", &_args130, &_result132)
	p.SetLastResponseMeta_(_meta131)
	if _err != nil {
		return
	}
	switch {
	case _result132.Io != nil:
		return _r, _result132.Io
	}

	return _result132.GetSuccess(), nil
}

// Get table names of tables that match the given pattern
// @return the table names of the matching table
//
// Parameters:
//   - Regex: The regular expression to match against
//   - IncludeSysTables: set to false if match only against userspace tables
func (p *THBaseServiceClient) GetTableNamesByPattern(ctx context.Context, regex string, includeSysTables bool) (_r []*TTableName, _err error) {
	var _args133 THBaseServiceGetTableNamesByPatternArgs
	_args133.Regex = regex
	_args133.IncludeSysTables = includeSysTables
	var _result135 THBaseServiceGetTableNamesByPatternResult
	var _meta134 thrift.ResponseMeta
	_meta134, _err = p.Client_().Call(ctx, "getTableNamesByPattern", &_args133, &_result135)
	p.SetLastResponseMeta_(_meta134)
	if _err != nil {
		return
	}
	switch {
	case _result135.Io != nil:
		return _r, _result135.Io
	}

	return _result135.GetSuccess(), nil
}

// Get table names of tables in the given namespace
// @return the table names of the matching table
//
// Parameters:
//   - Name: The namesapce's name
func (p *THBaseServiceClient) GetTableNamesByNamespace(ctx context.Context, name string) (_r []*TTableName, _err error) {
	var _args136 THBaseServiceGetTableNamesByNamespaceArgs
	_args136.Name = name
	var _result138 THBaseServiceGetTableNamesByNamespaceResult
	var _meta137 thrift.ResponseMeta
	_meta137, _err = p.Client_().Call(ctx, "getTableNamesByNamespace", &_args136, &_result138)
	p.SetLastResponseMeta_(_meta137)
	if _err != nil {
		return
	}
	switch {
	case _result138.Io != nil:
		return _r, _result138.Io
	}

	return _result138.GetSuccess(), nil
}

// Creates a new table with an initial set of empty regions defined by the specified split keys.
// The total number of regions created will be the number of split keys plus one. Synchronous
// operation.
//
// Parameters:
//   - Desc: table descriptor for table
//   - SplitKeys: rray of split keys for the initial regions of the table
func (p *THBaseServiceClient) CreateTable(ctx context.Context, desc *TTableDescriptor, splitKeys [][]byte) (_err error) {
	var _args139 THBaseServiceCreateTableArgs
	_args139.Desc = desc
	_args139.SplitKeys = splitKeys
	var _result141 THBaseServiceCreateTableResult
	var _meta140 thrift.ResponseMeta
	_meta140, _err = p.Client_().Call(ctx, "createTable", &_args139, &_result141)
	p.SetLastResponseMeta_(_meta140)
	if _err != nil {
		return
	}
	switch {
	case _result141.Io != nil:
		return _result141.Io
	}

	return nil
}

// Deletes a table. Synchronous operation.
//
// Parameters:
//   - TableName: the tablename to delete
func (p *THBaseServiceClient) DeleteTable(ctx context.Context, tableName *TTableName) (_err error) {
	var _args142 THBaseServiceDeleteTableArgs
	_args142.TableName = tableName
	var _result144 THBaseServiceDeleteTableResult
	var _meta143 thrift.ResponseMeta
	_meta143, _err = p.Client_().Call(ctx, "deleteTable", &_args142, &_result144)
	p.SetLastResponseMeta_(_meta143)
	if _err != nil {
		return
	}
	switch {
	case _result144.Io != nil:
		return _result144.Io
	}

	return nil
}

// Truncate a table. Synchronous operation.
//
// Parameters:
//   - TableName: the tablename to truncate
//   - PreserveSplits: whether to  preserve previous splits
func (p *THBaseServiceClient) TruncateTable(ctx context.Context, tableName *TTableName, preserveSplits bool) (_err error) {
	var _args145 THBaseServiceTruncateTableArgs
	_args145.TableName = tableName
	_args145.PreserveSplits = preserveSplits
	var _result147 THBaseServiceTruncateTableResult
	var _meta146 thrift.ResponseMeta
	_meta146, _err = p.Client_().Call(ctx, "truncateTable", &_args145, &_result147)
	p.SetLastResponseMeta_(_meta146)
	if _err != nil {
		return
	}
	switch {
	case _result147.Io != nil:
		return _result147.Io
	}

	return nil
}

// Enalbe a table
//
// Parameters:
//   - TableName: the tablename to enable
func (p *THBaseServiceClient) EnableTable(ctx context.Context, tableName *TTableName) (_err error) {
	var _args148 THBaseServiceEnableTableArgs
	_args148.TableName = tableName
	var _result150 THBaseServiceEnableTableResult
	var _meta149 thrift.ResponseMeta
	_meta149, _err = p.Client_().Call(ctx, "enableTable", &_args148, &_result150)
	p.SetLastResponseMeta_(_meta149)
	if _err != nil {
		return
	}
	switch {
	case _result150.Io != nil:
		return _result150.Io
	}

	return nil
}

// Disable a table
//
// Parameters:
//   - TableName: the tablename to disable
func (p *THBaseServiceClient) DisableTable(ctx context.Context, tableName *TTableName) (_err error) {
	var _args151 THBaseServiceDisableTableArgs
	_args151.TableName = tableName
	var _result153 THBaseServiceDisableTableResult
	var _meta152 thrift.ResponseMeta
	_meta152, _err = p.Client_().Call(ctx, "disableTable", &_args151, &_result153)
	p.SetLastResponseMeta_(_meta152)
	if _err != nil {
		return
	}
	switch {
	case _result153.Io != nil:
		return _result153.Io
	}

	return nil
}

// @return true if table is enabled, false if not
//
// Parameters:
//   - TableName: the tablename to check
func (p *THBaseServiceClient) IsTableEnabled(ctx context.Context, tableName *TTableName) (_r bool, _err error) {
	var _args154 THBaseServiceIsTableEnabledArgs
	_args154.TableName = tableName
	var _result156 THBaseServiceIsTableEnabledResult
	var _meta155 thrift.ResponseMeta
	_meta155, _err = p.Client_().Call(ctx, "isTableEnabled", &_args154, &_result156)
	p.SetLastResponseMeta_(_meta155)
	if _err != nil {
		return
	}
	switch {
	case _result156.Io != nil:
		return _r, _result156.Io
	}

	return _result156.GetSuccess(), nil
}

// @return true if table is disabled, false if not
//
// Parameters:
//   - TableName: the tablename to check
func (p *THBaseServiceClient) IsTableDisabled(ctx context.Context, tableName *TTableName) (_r bool, _err error) {
	var _args157 THBaseServiceIsTableDisabledArgs
	_args157.TableName = tableName
	var _result159 THBaseServiceIsTableDisabledResult
	var _meta158 thrift.ResponseMeta
	_meta158, _err = p.Client_().Call(ctx, "isTableDisabled", &_args157, &_result159)
	p.SetLastResponseMeta_(_meta158)
	if _err != nil {
		return
	}
	switch {
	case _result159.Io != nil:
		return _r, _result159.Io
	}

	return _result159.GetSuccess(), nil
}

// @return true if table is available, false if not
//
// Parameters:
//   - TableName: the tablename to check
func (p *THBaseServiceClient) IsTableAvailable(ctx context.Context, tableName *TTableName) (_r bool, _err error) {
	var _args160 THBaseServiceIsTableAvailableArgs
	_args160.TableName = tableName
	var _result162 THBaseServiceIsTableAvailableResult
	var _meta161 thrift.ResponseMeta
	_meta161, _err = p.Client_().Call(ctx, "isTableAvailable", &_args160, &_result162)
	p.SetLastResponseMeta_(_meta161)
	if _err != nil {
		return
	}
	switch {
	case _result162.Io != nil:
		return _r, _result162.Io
	}

	return _result162.GetSuccess(), nil
}

//   - Use this api to check if the table has been created with the specified number of splitkeys
//   - which was used while creating the given table. Note : If this api is used after a table's
//   - region gets splitted, the api may return false.
//     *
//   - @return true if table is available, false if not
//     *
//   - @deprecated Since 2.2.0. Because the same method in Table interface has been deprecated
//   - since 2.0.0, we will remove it in 3.0.0 release.
//   - Use {@link #isTableAvailable(TTableName tableName)} instead
//
// *
//
// Parameters:
//   - TableName: the tablename to check
//   - SplitKeys: keys to check if the table has been created with all split keys
func (p *THBaseServiceClient) IsTableAvailableWithSplit(ctx context.Context, tableName *TTableName, splitKeys [][]byte) (_r bool, _err error) {
	var _args163 THBaseServiceIsTableAvailableWithSplitArgs
	_args163.TableName = tableName
	_args163.SplitKeys = splitKeys
	var _result165 THBaseServiceIsTableAvailableWithSplitResult
	var _meta164 thrift.ResponseMeta
	_meta164, _err = p.Client_().Call(ctx, "isTableAvailableWithSplit", &_args163, &_result165)
	p.SetLastResponseMeta_(_meta164)
	if _err != nil {
		return
	}
	switch {
	case _result165.Io != nil:
		return _r, _result165.Io
	}

	return _result165.GetSuccess(), nil
}

// Add a column family to an existing table. Synchronous operation.
//
// Parameters:
//   - TableName: the tablename to add column family to
//   - Column: column family descriptor of column family to be added
func (p *THBaseServiceClient) AddColumnFamily(ctx context.Context, tableName *TTableName, column *TColumnFamilyDescriptor) (_err error) {
	var _args166 THBaseServiceAddColumnFamilyArgs
	_args166.TableName = tableName
	_args166.Column = column
	var _result168 THBaseServiceAddColumnFamilyResult
	var _meta167 thrift.ResponseMeta
	_meta167, _err = p.Client_().Call(ctx, "addColumnFamily", &_args166, &_result168)
	p.SetLastResponseMeta_(_meta167)
	if _err != nil {
		return
	}
	switch {
	case _result168.Io != nil:
		return _result168.Io
	}

	return nil
}

// Delete a column family from a table. Synchronous operation.
//
// Parameters:
//   - TableName: the tablename to delete column family from
//   - Column: name of column family to be deleted
func (p *THBaseServiceClient) DeleteColumnFamily(ctx context.Context, tableName *TTableName, column []byte) (_err error) {
	var _args169 THBaseServiceDeleteColumnFamilyArgs
	_args169.TableName = tableName
	_args169.Column = column
	var _result171 THBaseServiceDeleteColumnFamilyResult
	var _meta170 thrift.ResponseMeta
	_meta170, _err = p.Client_().Call(ctx, "deleteColumnFamily", &_args169, &_result171)
	p.SetLastResponseMeta_(_meta170)
	if _err != nil {
		return
	}
	switch {
	case _result171.Io != nil:
		return _result171.Io
	}

	return nil
}

// Modify an existing column family on a table. Synchronous operation.
//
// Parameters:
//   - TableName: the tablename to modify column family
//   - Column: column family descriptor of column family to be modified
func (p *THBaseServiceClient) ModifyColumnFamily(ctx context.Context, tableName *TTableName, column *TColumnFamilyDescriptor) (_err error) {
	var _args172 THBaseServiceModifyColumnFamilyArgs
	_args172.TableName = tableName
	_args172.Column = column
	var _result174 THBaseServiceModifyColumnFamilyResult
	var _meta173 thrift.ResponseMeta
	_meta173, _err = p.Client_().Call(ctx, "modifyColumnFamily", &_args172, &_result174)
	p.SetLastResponseMeta_(_meta173)
	if _err != nil {
		return
	}
	switch {
	case _result174.Io != nil:
		return _result174.Io
	}

	return nil
}

// Modify an existing table
//
// Parameters:
//   - Desc: the descriptor of the table to modify
func (p *THBaseServiceClient) ModifyTable(ctx context.Context, desc *TTableDescriptor) (_err error) {
	var _args175 THBaseServiceModifyTableArgs
	_args175.Desc = desc
	var _result177 THBaseServiceModifyTableResult
	var _meta176 thrift.ResponseMeta
	_meta176, _err = p.Client_().Call(ctx, "modifyTable", &_args175, &_result177)
	p.SetLastResponseMeta_(_meta176)
	if _err != nil {
		return
	}
	switch {
	case _result177.Io != nil:
		return _result177.Io
	}

	return nil
}

// Create a new namespace. Blocks until namespace has been successfully created or an exception is
// thrown
//
// Parameters:
//   - NamespaceDesc: descriptor which describes the new namespace
func (p *THBaseServiceClient) CreateNamespace(ctx context.Context, namespaceDesc *TNamespaceDescriptor) (_err error) {
	var _args178 THBaseServiceCreateNamespaceArgs
	_args178.NamespaceDesc = namespaceDesc
	var _result180 THBaseServiceCreateNamespaceResult
	var _meta179 thrift.ResponseMeta
	_meta179, _err = p.Client_().Call(ctx, "createNamespace", &_args178, &_result180)
	p.SetLastResponseMeta_(_meta179)
	if _err != nil {
		return
	}
	switch {
	case _result180.Io != nil:
		return _result180.Io
	}

	return nil
}

// Modify an existing namespace.  Blocks until namespace has been successfully modified or an
// exception is thrown
//
// Parameters:
//   - NamespaceDesc: descriptor which describes the new namespace
func (p *THBaseServiceClient) ModifyNamespace(ctx context.Context, namespaceDesc *TNamespaceDescriptor) (_err error) {
	var _args181 THBaseServiceModifyNamespaceArgs
	_args181.NamespaceDesc = namespaceDesc
	var _result183 THBaseServiceModifyNamespaceResult
	var _meta182 thrift.ResponseMeta
	_meta182, _err = p.Client_().Call(ctx, "modifyNamespace", &_args181, &_result183)
	p.SetLastResponseMeta_(_meta182)
	if _err != nil {
		return
	}
	switch {
	case _result183.Io != nil:
		return _result183.Io
	}

	return nil
}

// Delete an existing namespace. Only empty namespaces (no tables) can be removed.
// Blocks until namespace has been successfully deleted or an
// exception is thrown.
//
// Parameters:
//   - Name: namespace name
func (p *THBaseServiceClient) DeleteNamespace(ctx context.Context, name string) (_err error) {
	var _args184 THBaseServiceDeleteNamespaceArgs
	_args184.Name = name
	var _result186 THBaseServiceDeleteNamespaceResult
	var _meta185 thrift.ResponseMeta
	_meta185, _err = p.Client_().Call(ctx, "deleteNamespace", &_args184, &_result186)
	p.SetLastResponseMeta_(_meta185)
	if _err != nil {
		return
	}
	switch {
	case _result186.Io != nil:
		return _result186.Io
	}

	return nil
}

// Get a namespace descriptor by name.
// @retrun the descriptor
//
// Parameters:
//   - Name: name of namespace descriptor
func (p *THBaseServiceClient) GetNamespaceDescriptor(ctx context.Context, name string) (_r *TNamespaceDescriptor, _err error) {
	var _args187 THBaseServiceGetNamespaceDescriptorArgs
	_args187.Name = name
	var _result189 THBaseServiceGetNamespaceDescriptorResult
	var _meta188 thrift.ResponseMeta
	_meta188, _err = p.Client_().Call(ctx, "getNamespaceDescriptor", &_args187, &_result189)
	p.SetLastResponseMeta_(_meta188)
	if _err != nil {
		return
	}
	switch {
	case _result189.Io != nil:
		return _r, _result189.Io
	}

	if _ret190 := _result189.GetSuccess(); _ret190 != nil {
		return _ret190, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getNamespaceDescriptor failed: unknown result")
}

// @return all namespaces
func (p *THBaseServiceClient) ListNamespaceDescriptors(ctx context.Context) (_r []*TNamespaceDescriptor, _err error) {
	var _args191 THBaseServiceListNamespaceDescriptorsArgs
	var _result193 THBaseServiceListNamespaceDescriptorsResult
	var _meta192 thrift.ResponseMeta
	_meta192, _err = p.Client_().Call(ctx, "listNamespaceDescriptors", &_args191, &_result193)
	p.SetLastResponseMeta_(_meta192)
	if _err != nil {
		return
	}
	switch {
	case _result193.Io != nil:
		return _r, _result193.Io
	}

	return _result193.GetSuccess(), nil
}

type THBaseServiceProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      THBaseService
}

func (p *THBaseServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *THBaseServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *THBaseServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewTHBaseServiceProcessor(handler THBaseService) *THBaseServiceProcessor {

	self194 := &THBaseServiceProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self194.processorMap["exists"] = &tHBaseServiceProcessorExists{handler: handler}
	self194.processorMap["existsAll"] = &tHBaseServiceProcessorExistsAll{handler: handler}
	self194.processorMap["get"] = &tHBaseServiceProcessorGet{handler: handler}
	self194.processorMap["getMultiple"] = &tHBaseServiceProcessorGetMultiple{handler: handler}
	self194.processorMap["put"] = &tHBaseServiceProcessorPut{handler: handler}
	self194.processorMap["checkAndPut"] = &tHBaseServiceProcessorCheckAndPut{handler: handler}
	self194.processorMap["putMultiple"] = &tHBaseServiceProcessorPutMultiple{handler: handler}
	self194.processorMap["deleteSingle"] = &tHBaseServiceProcessorDeleteSingle{handler: handler}
	self194.processorMap["deleteMultiple"] = &tHBaseServiceProcessorDeleteMultiple{handler: handler}
	self194.processorMap["checkAndDelete"] = &tHBaseServiceProcessorCheckAndDelete{handler: handler}
	self194.processorMap["increment"] = &tHBaseServiceProcessorIncrement{handler: handler}
	self194.processorMap["append"] = &tHBaseServiceProcessorAppend{handler: handler}
	self194.processorMap["openScanner"] = &tHBaseServiceProcessorOpenScanner{handler: handler}
	self194.processorMap["getScannerRows"] = &tHBaseServiceProcessorGetScannerRows{handler: handler}
	self194.processorMap["closeScanner"] = &tHBaseServiceProcessorCloseScanner{handler: handler}
	self194.processorMap["mutateRow"] = &tHBaseServiceProcessorMutateRow{handler: handler}
	self194.processorMap["getScannerResults"] = &tHBaseServiceProcessorGetScannerResults{handler: handler}
	self194.processorMap["getRegionLocation"] = &tHBaseServiceProcessorGetRegionLocation{handler: handler}
	self194.processorMap["getAllRegionLocations"] = &tHBaseServiceProcessorGetAllRegionLocations{handler: handler}
	self194.processorMap["checkAndMutate"] = &tHBaseServiceProcessorCheckAndMutate{handler: handler}
	self194.processorMap["getTableDescriptor"] = &tHBaseServiceProcessorGetTableDescriptor{handler: handler}
	self194.processorMap["getTableDescriptors"] = &tHBaseServiceProcessorGetTableDescriptors{handler: handler}
	self194.processorMap["tableExists"] = &tHBaseServiceProcessorTableExists{handler: handler}
	self194.processorMap["getTableDescriptorsByPattern"] = &tHBaseServiceProcessorGetTableDescriptorsByPattern{handler: handler}
	self194.processorMap["getTableDescriptorsByNamespace"] = &tHBaseServiceProcessorGetTableDescriptorsByNamespace{handler: handler}
	self194.processorMap["getTableNamesByPattern"] = &tHBaseServiceProcessorGetTableNamesByPattern{handler: handler}
	self194.processorMap["getTableNamesByNamespace"] = &tHBaseServiceProcessorGetTableNamesByNamespace{handler: handler}
	self194.processorMap["createTable"] = &tHBaseServiceProcessorCreateTable{handler: handler}
	self194.processorMap["deleteTable"] = &tHBaseServiceProcessorDeleteTable{handler: handler}
	self194.processorMap["truncateTable"] = &tHBaseServiceProcessorTruncateTable{handler: handler}
	self194.processorMap["enableTable"] = &tHBaseServiceProcessorEnableTable{handler: handler}
	self194.processorMap["disableTable"] = &tHBaseServiceProcessorDisableTable{handler: handler}
	self194.processorMap["isTableEnabled"] = &tHBaseServiceProcessorIsTableEnabled{handler: handler}
	self194.processorMap["isTableDisabled"] = &tHBaseServiceProcessorIsTableDisabled{handler: handler}
	self194.processorMap["isTableAvailable"] = &tHBaseServiceProcessorIsTableAvailable{handler: handler}
	self194.processorMap["isTableAvailableWithSplit"] = &tHBaseServiceProcessorIsTableAvailableWithSplit{handler: handler}
	self194.processorMap["addColumnFamily"] = &tHBaseServiceProcessorAddColumnFamily{handler: handler}
	self194.processorMap["deleteColumnFamily"] = &tHBaseServiceProcessorDeleteColumnFamily{handler: handler}
	self194.processorMap["modifyColumnFamily"] = &tHBaseServiceProcessorModifyColumnFamily{handler: handler}
	self194.processorMap["modifyTable"] = &tHBaseServiceProcessorModifyTable{handler: handler}
	self194.processorMap["createNamespace"] = &tHBaseServiceProcessorCreateNamespace{handler: handler}
	self194.processorMap["modifyNamespace"] = &tHBaseServiceProcessorModifyNamespace{handler: handler}
	self194.processorMap["deleteNamespace"] = &tHBaseServiceProcessorDeleteNamespace{handler: handler}
	self194.processorMap["getNamespaceDescriptor"] = &tHBaseServiceProcessorGetNamespaceDescriptor{handler: handler}
	self194.processorMap["listNamespaceDescriptors"] = &tHBaseServiceProcessorListNamespaceDescriptors{handler: handler}
	return self194
}

func (p *THBaseServiceProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
	if err2 != nil {
		return false, thrift.WrapTException(err2)
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(ctx, seqId, iprot, oprot)
	}
	iprot.Skip(ctx, thrift.STRUCT)
	iprot.ReadMessageEnd(ctx)
	x195 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
	x195.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return false, x195

}

type tHBaseServiceProcessorExists struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorExists) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err196 error
	args := THBaseServiceExistsArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "exists", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceExistsResult{}
	if retval, err2 := p.handler.Exists(ctx, args.Table, args.Tget); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc197 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing exists: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "exists", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err196 = thrift.WrapTException(err2)
			}
			if err2 := _exc197.Write(ctx, oprot); _write_err196 == nil && err2 != nil {
				_write_err196 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err196 == nil && err2 != nil {
				_write_err196 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err196 == nil && err2 != nil {
				_write_err196 = thrift.WrapTException(err2)
			}
			if _write_err196 != nil {
				return false, thrift.WrapTException(_write_err196)
			}
			return true, err
		}
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "exists", thrift.REPLY, seqId); err2 != nil {
		_write_err196 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err196 == nil && err2 != nil {
		_write_err196 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err196 == nil && err2 != nil {
		_write_err196 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err196 == nil && err2 != nil {
		_write_err196 = thrift.WrapTException(err2)
	}
	if _write_err196 != nil {
		return false, thrift.WrapTException(_write_err196)
	}
	return true, err
}

type tHBaseServiceProcessorExistsAll struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorExistsAll) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err198 error
	args := THBaseServiceExistsAllArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "existsAll", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceExistsAllResult{}
	if retval, err2 := p.handler.ExistsAll(ctx, args.Table, args.Tgets); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc199 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing existsAll: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "existsAll", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err198 = thrift.WrapTException(err2)
			}
			if err2 := _exc199.Write(ctx, oprot); _write_err198 == nil && err2 != nil {
				_write_err198 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err198 == nil && err2 != nil {
				_write_err198 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err198 == nil && err2 != nil {
				_write_err198 = thrift.WrapTException(err2)
			}
			if _write_err198 != nil {
				return false, thrift.WrapTException(_write_err198)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "existsAll", thrift.REPLY, seqId); err2 != nil {
		_write_err198 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err198 == nil && err2 != nil {
		_write_err198 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err198 == nil && err2 != nil {
		_write_err198 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err198 == nil && err2 != nil {
		_write_err198 = thrift.WrapTException(err2)
	}
	if _write_err198 != nil {
		return false, thrift.WrapTException(_write_err198)
	}
	return true, err
}

type tHBaseServiceProcessorGet struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGet) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err200 error
	args := THBaseServiceGetArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "get", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceGetResult{}
	if retval, err2 := p.handler.Get(ctx, args.Table, args.Tget); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc201 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "get", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err200 = thrift.WrapTException(err2)
			}
			if err2 := _exc201.Write(ctx, oprot); _write_err200 == nil && err2 != nil {
				_write_err200 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err200 == nil && err2 != nil {
				_write_err200 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err200 == nil && err2 != nil {
				_write_err200 = thrift.WrapTException(err2)
			}
			if _write_err200 != nil {
				return false, thrift.WrapTException(_write_err200)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "get", thrift.REPLY, seqId); err2 != nil {
		_write_err200 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err200 == nil && err2 != nil {
		_write_err200 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err200 == nil && err2 != nil {
		_write_err200 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err200 == nil && err2 != nil {
		_write_err200 = thrift.WrapTException(err2)
	}
	if _write_err200 != nil {
		return false, thrift.WrapTException(_write_err200)
	}
	return true, err
}

type tHBaseServiceProcessorGetMultiple struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetMultiple) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err202 error
	args := THBaseServiceGetMultipleArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "getMultiple", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceGetMultipleResult{}
	if retval, err2 := p.handler.GetMultiple(ctx, args.Table, args.Tgets); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc203 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getMultiple: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "getMultiple", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err202 = thrift.WrapTException(err2)
			}
			if err2 := _exc203.Write(ctx, oprot); _write_err202 == nil && err2 != nil {
				_write_err202 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err202 == nil && err2 != nil {
				_write_err202 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err202 == nil && err2 != nil {
				_write_err202 = thrift.WrapTException(err2)
			}
			if _write_err202 != nil {
				return false, thrift.WrapTException(_write_err202)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "getMultiple", thrift.REPLY, seqId); err2 != nil {
		_write_err202 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err202 == nil && err2 != nil {
		_write_err202 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err202 == nil && err2 != nil {
		_write_err202 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err202 == nil && err2 != nil {
		_write_err202 = thrift.WrapTException(err2)
	}
	if _write_err202 != nil {
		return false, thrift.WrapTException(_write_err202)
	}
	return true, err
}

type tHBaseServiceProcessorPut struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorPut) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err204 error
	args := THBaseServicePutArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "put", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServicePutResult{}
	if err2 := p.handler.Put(ctx, args.Table, args.Tput); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc205 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing put: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "put", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err204 = thrift.WrapTException(err2)
			}
			if err2 := _exc205.Write(ctx, oprot); _write_err204 == nil && err2 != nil {
				_write_err204 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err204 == nil && err2 != nil {
				_write_err204 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err204 == nil && err2 != nil {
				_write_err204 = thrift.WrapTException(err2)
			}
			if _write_err204 != nil {
				return false, thrift.WrapTException(_write_err204)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "put", thrift.REPLY, seqId); err2 != nil {
		_write_err204 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err204 == nil && err2 != nil {
		_write_err204 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err204 == nil && err2 != nil {
		_write_err204 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err204 == nil && err2 != nil {
		_write_err204 = thrift.WrapTException(err2)
	}
	if _write_err204 != nil {
		return false, thrift.WrapTException(_write_err204)
	}
	return true, err
}

type tHBaseServiceProcessorCheckAndPut struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCheckAndPut) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err206 error
	args := THBaseServiceCheckAndPutArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "checkAndPut", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceCheckAndPutResult{}
	if retval, err2 := p.handler.CheckAndPut(ctx, args.Table, args.Row, args.Family, args.Qualifier, args.Value, args.Tput); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc207 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkAndPut: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "checkAndPut", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err206 = thrift.WrapTException(err2)
			}
			if err2 := _exc207.Write(ctx, oprot); _write_err206 == nil && err2 != nil {
				_write_err206 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err206 == nil && err2 != nil {
				_write_err206 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err206 == nil && err2 != nil {
				_write_err206 = thrift.WrapTException(err2)
			}
			if _write_err206 != nil {
				return false, thrift.WrapTException(_write_err206)
			}
			return true, err
		}
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "checkAndPut", thrift.REPLY, seqId); err2 != nil {
		_write_err206 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err206 == nil && err2 != nil {
		_write_err206 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err206 == nil && err2 != nil {
		_write_err206 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err206 == nil && err2 != nil {
		_write_err206 = thrift.WrapTException(err2)
	}
	if _write_err206 != nil {
		return false, thrift.WrapTException(_write_err206)
	}
	return true, err
}

type tHBaseServiceProcessorPutMultiple struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorPutMultiple) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err208 error
	args := THBaseServicePutMultipleArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "putMultiple", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServicePutMultipleResult{}
	if err2 := p.handler.PutMultiple(ctx, args.Table, args.Tputs); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc209 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing putMultiple: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "putMultiple", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err208 = thrift.WrapTException(err2)
			}
			if err2 := _exc209.Write(ctx, oprot); _write_err208 == nil && err2 != nil {
				_write_err208 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err208 == nil && err2 != nil {
				_write_err208 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err208 == nil && err2 != nil {
				_write_err208 = thrift.WrapTException(err2)
			}
			if _write_err208 != nil {
				return false, thrift.WrapTException(_write_err208)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "putMultiple", thrift.REPLY, seqId); err2 != nil {
		_write_err208 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err208 == nil && err2 != nil {
		_write_err208 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err208 == nil && err2 != nil {
		_write_err208 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err208 == nil && err2 != nil {
		_write_err208 = thrift.WrapTException(err2)
	}
	if _write_err208 != nil {
		return false, thrift.WrapTException(_write_err208)
	}
	return true, err
}

type tHBaseServiceProcessorDeleteSingle struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteSingle) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err210 error
	args := THBaseServiceDeleteSingleArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "deleteSingle", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceDeleteSingleResult{}
	if err2 := p.handler.DeleteSingle(ctx, args.Table, args.Tdelete); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc211 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteSingle: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "deleteSingle", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err210 = thrift.WrapTException(err2)
			}
			if err2 := _exc211.Write(ctx, oprot); _write_err210 == nil && err2 != nil {
				_write_err210 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err210 == nil && err2 != nil {
				_write_err210 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err210 == nil && err2 != nil {
				_write_err210 = thrift.WrapTException(err2)
			}
			if _write_err210 != nil {
				return false, thrift.WrapTException(_write_err210)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "deleteSingle", thrift.REPLY, seqId); err2 != nil {
		_write_err210 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err210 == nil && err2 != nil {
		_write_err210 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err210 == nil && err2 != nil {
		_write_err210 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err210 == nil && err2 != nil {
		_write_err210 = thrift.WrapTException(err2)
	}
	if _write_err210 != nil {
		return false, thrift.WrapTException(_write_err210)
	}
	return true, err
}

type tHBaseServiceProcessorDeleteMultiple struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteMultiple) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err212 error
	args := THBaseServiceDeleteMultipleArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "deleteMultiple", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceDeleteMultipleResult{}
	if retval, err2 := p.handler.DeleteMultiple(ctx, args.Table, args.Tdeletes); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc213 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteMultiple: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "deleteMultiple", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err212 = thrift.WrapTException(err2)
			}
			if err2 := _exc213.Write(ctx, oprot); _write_err212 == nil && err2 != nil {
				_write_err212 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err212 == nil && err2 != nil {
				_write_err212 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err212 == nil && err2 != nil {
				_write_err212 = thrift.WrapTException(err2)
			}
			if _write_err212 != nil {
				return false, thrift.WrapTException(_write_err212)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "deleteMultiple", thrift.REPLY, seqId); err2 != nil {
		_write_err212 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err212 == nil && err2 != nil {
		_write_err212 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err212 == nil && err2 != nil {
		_write_err212 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err212 == nil && err2 != nil {
		_write_err212 = thrift.WrapTException(err2)
	}
	if _write_err212 != nil {
		return false, thrift.WrapTException(_write_err212)
	}
	return true, err
}

type tHBaseServiceProcessorCheckAndDelete struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCheckAndDelete) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err214 error
	args := THBaseServiceCheckAndDeleteArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "checkAndDelete", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceCheckAndDeleteResult{}
	if retval, err2 := p.handler.CheckAndDelete(ctx, args.Table, args.Row, args.Family, args.Qualifier, args.Value, args.Tdelete); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc215 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkAndDelete: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "checkAndDelete", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err214 = thrift.WrapTException(err2)
			}
			if err2 := _exc215.Write(ctx, oprot); _write_err214 == nil && err2 != nil {
				_write_err214 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err214 == nil && err2 != nil {
				_write_err214 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err214 == nil && err2 != nil {
				_write_err214 = thrift.WrapTException(err2)
			}
			if _write_err214 != nil {
				return false, thrift.WrapTException(_write_err214)
			}
			return true, err
		}
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "checkAndDelete", thrift.REPLY, seqId); err2 != nil {
		_write_err214 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err214 == nil && err2 != nil {
		_write_err214 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err214 == nil && err2 != nil {
		_write_err214 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err214 == nil && err2 != nil {
		_write_err214 = thrift.WrapTException(err2)
	}
	if _write_err214 != nil {
		return false, thrift.WrapTException(_write_err214)
	}
	return true, err
}

type tHBaseServiceProcessorIncrement struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorIncrement) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err216 error
	args := THBaseServiceIncrementArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "increment", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceIncrementResult{}
	if retval, err2 := p.handler.Increment(ctx, args.Table, args.Tincrement); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc217 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing increment: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "increment", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err216 = thrift.WrapTException(err2)
			}
			if err2 := _exc217.Write(ctx, oprot); _write_err216 == nil && err2 != nil {
				_write_err216 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err216 == nil && err2 != nil {
				_write_err216 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err216 == nil && err2 != nil {
				_write_err216 = thrift.WrapTException(err2)
			}
			if _write_err216 != nil {
				return false, thrift.WrapTException(_write_err216)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "increment", thrift.REPLY, seqId); err2 != nil {
		_write_err216 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err216 == nil && err2 != nil {
		_write_err216 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err216 == nil && err2 != nil {
		_write_err216 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err216 == nil && err2 != nil {
		_write_err216 = thrift.WrapTException(err2)
	}
	if _write_err216 != nil {
		return false, thrift.WrapTException(_write_err216)
	}
	return true, err
}

type tHBaseServiceProcessorAppend struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorAppend) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err218 error
	args := THBaseServiceAppendArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "append", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceAppendResult{}
	if retval, err2 := p.handler.Append(ctx, args.Table, args.Tappend); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc219 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing append: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "append", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err218 = thrift.WrapTException(err2)
			}
			if err2 := _exc219.Write(ctx, oprot); _write_err218 == nil && err2 != nil {
				_write_err218 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err218 == nil && err2 != nil {
				_write_err218 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err218 == nil && err2 != nil {
				_write_err218 = thrift.WrapTException(err2)
			}
			if _write_err218 != nil {
				return false, thrift.WrapTException(_write_err218)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "append", thrift.REPLY, seqId); err2 != nil {
		_write_err218 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err218 == nil && err2 != nil {
		_write_err218 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err218 == nil && err2 != nil {
		_write_err218 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err218 == nil && err2 != nil {
		_write_err218 = thrift.WrapTException(err2)
	}
	if _write_err218 != nil {
		return false, thrift.WrapTException(_write_err218)
	}
	return true, err
}

type tHBaseServiceProcessorOpenScanner struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorOpenScanner) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err220 error
	args := THBaseServiceOpenScannerArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "openScanner", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceOpenScannerResult{}
	if retval, err2 := p.handler.OpenScanner(ctx, args.Table, args.Tscan); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc221 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing openScanner: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "openScanner", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err220 = thrift.WrapTException(err2)
			}
			if err2 := _exc221.Write(ctx, oprot); _write_err220 == nil && err2 != nil {
				_write_err220 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err220 == nil && err2 != nil {
				_write_err220 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err220 == nil && err2 != nil {
				_write_err220 = thrift.WrapTException(err2)
			}
			if _write_err220 != nil {
				return false, thrift.WrapTException(_write_err220)
			}
			return true, err
		}
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "openScanner", thrift.REPLY, seqId); err2 != nil {
		_write_err220 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err220 == nil && err2 != nil {
		_write_err220 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err220 == nil && err2 != nil {
		_write_err220 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err220 == nil && err2 != nil {
		_write_err220 = thrift.WrapTException(err2)
	}
	if _write_err220 != nil {
		return false, thrift.WrapTException(_write_err220)
	}
	return true, err
}

type tHBaseServiceProcessorGetScannerRows struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetScannerRows) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err222 error
	args := THBaseServiceGetScannerRowsArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "getScannerRows", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceGetScannerRowsResult{}
	if retval, err2 := p.handler.GetScannerRows(ctx, args.ScannerId, args.NumRows); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		case *TIllegalArgument:
			result.Ia = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc223 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getScannerRows: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "getScannerRows", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err222 = thrift.WrapTException(err2)
			}
			if err2 := _exc223.Write(ctx, oprot); _write_err222 == nil && err2 != nil {
				_write_err222 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err222 == nil && err2 != nil {
				_write_err222 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err222 == nil && err2 != nil {
				_write_err222 = thrift.WrapTException(err2)
			}
			if _write_err222 != nil {
				return false, thrift.WrapTException(_write_err222)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "getScannerRows", thrift.REPLY, seqId); err2 != nil {
		_write_err222 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err222 == nil && err2 != nil {
		_write_err222 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err222 == nil && err2 != nil {
		_write_err222 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err222 == nil && err2 != nil {
		_write_err222 = thrift.WrapTException(err2)
	}
	if _write_err222 != nil {
		return false, thrift.WrapTException(_write_err222)
	}
	return true, err
}

type tHBaseServiceProcessorCloseScanner struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCloseScanner) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err224 error
	args := THBaseServiceCloseScannerArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "closeScanner", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceCloseScannerResult{}
	if err2 := p.handler.CloseScanner(ctx, args.ScannerId); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		case *TIllegalArgument:
			result.Ia = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc225 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing closeScanner: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "closeScanner", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err224 = thrift.WrapTException(err2)
			}
			if err2 := _exc225.Write(ctx, oprot); _write_err224 == nil && err2 != nil {
				_write_err224 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err224 == nil && err2 != nil {
				_write_err224 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err224 == nil && err2 != nil {
				_write_err224 = thrift.WrapTException(err2)
			}
			if _write_err224 != nil {
				return false, thrift.WrapTException(_write_err224)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "closeScanner", thrift.REPLY, seqId); err2 != nil {
		_write_err224 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err224 == nil && err2 != nil {
		_write_err224 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err224 == nil && err2 != nil {
		_write_err224 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err224 == nil && err2 != nil {
		_write_err224 = thrift.WrapTException(err2)
	}
	if _write_err224 != nil {
		return false, thrift.WrapTException(_write_err224)
	}
	return true, err
}

type tHBaseServiceProcessorMutateRow struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorMutateRow) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err226 error
	args := THBaseServiceMutateRowArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "mutateRow", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceMutateRowResult{}
	if err2 := p.handler.MutateRow(ctx, args.Table, args.TrowMutations); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc227 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutateRow: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "mutateRow", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err226 = thrift.WrapTException(err2)
			}
			if err2 := _exc227.Write(ctx, oprot); _write_err226 == nil && err2 != nil {
				_write_err226 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err226 == nil && err2 != nil {
				_write_err226 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err226 == nil && err2 != nil {
				_write_err226 = thrift.WrapTException(err2)
			}
			if _write_err226 != nil {
				return false, thrift.WrapTException(_write_err226)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "mutateRow", thrift.REPLY, seqId); err2 != nil {
		_write_err226 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err226 == nil && err2 != nil {
		_write_err226 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err226 == nil && err2 != nil {
		_write_err226 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err226 == nil && err2 != nil {
		_write_err226 = thrift.WrapTException(err2)
	}
	if _write_err226 != nil {
		return false, thrift.WrapTException(_write_err226)
	}
	return true, err
}

type tHBaseServiceProcessorGetScannerResults struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetScannerResults) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err228 error
	args := THBaseServiceGetScannerResultsArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "getScannerResults", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceGetScannerResultsResult{}
	if retval, err2 := p.handler.GetScannerResults(ctx, args.Table, args.Tscan, args.NumRows); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc229 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getScannerResults: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "getScannerResults", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err228 = thrift.WrapTException(err2)
			}
			if err2 := _exc229.Write(ctx, oprot); _write_err228 == nil && err2 != nil {
				_write_err228 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err228 == nil && err2 != nil {
				_write_err228 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err228 == nil && err2 != nil {
				_write_err228 = thrift.WrapTException(err2)
			}
			if _write_err228 != nil {
				return false, thrift.WrapTException(_write_err228)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "getScannerResults", thrift.REPLY, seqId); err2 != nil {
		_write_err228 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err228 == nil && err2 != nil {
		_write_err228 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err228 == nil && err2 != nil {
		_write_err228 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err228 == nil && err2 != nil {
		_write_err228 = thrift.WrapTException(err2)
	}
	if _write_err228 != nil {
		return false, thrift.WrapTException(_write_err228)
	}
	return true, err
}

type tHBaseServiceProcessorGetRegionLocation struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetRegionLocation) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err230 error
	args := THBaseServiceGetRegionLocationArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "getRegionLocation", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceGetRegionLocationResult{}
	if retval, err2 := p.handler.GetRegionLocation(ctx, args.Table, args.Row, args.Reload); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc231 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRegionLocation: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "getRegionLocation", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err230 = thrift.WrapTException(err2)
			}
			if err2 := _exc231.Write(ctx, oprot); _write_err230 == nil && err2 != nil {
				_write_err230 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err230 == nil && err2 != nil {
				_write_err230 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err230 == nil && err2 != nil {
				_write_err230 = thrift.WrapTException(err2)
			}
			if _write_err230 != nil {
				return false, thrift.WrapTException(_write_err230)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "getRegionLocation", thrift.REPLY, seqId); err2 != nil {
		_write_err230 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err230 == nil && err2 != nil {
		_write_err230 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err230 == nil && err2 != nil {
		_write_err230 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err230 == nil && err2 != nil {
		_write_err230 = thrift.WrapTException(err2)
	}
	if _write_err230 != nil {
		return false, thrift.WrapTException(_write_err230)
	}
	return true, err
}

type tHBaseServiceProcessorGetAllRegionLocations struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetAllRegionLocations) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err232 error
	args := THBaseServiceGetAllRegionLocationsArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "getAllRegionLocations", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceGetAllRegionLocationsResult{}
	if retval, err2 := p.handler.GetAllRegionLocations(ctx, args.Table); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc233 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getAllRegionLocations: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "getAllRegionLocations", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err232 = thrift.WrapTException(err2)
			}
			if err2 := _exc233.Write(ctx, oprot); _write_err232 == nil && err2 != nil {
				_write_err232 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err232 == nil && err2 != nil {
				_write_err232 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err232 == nil && err2 != nil {
				_write_err232 = thrift.WrapTException(err2)
			}
			if _write_err232 != nil {
				return false, thrift.WrapTException(_write_err232)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "getAllRegionLocations", thrift.REPLY, seqId); err2 != nil {
		_write_err232 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err232 == nil && err2 != nil {
		_write_err232 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err232 == nil && err2 != nil {
		_write_err232 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err232 == nil && err2 != nil {
		_write_err232 = thrift.WrapTException(err2)
	}
	if _write_err232 != nil {
		return false, thrift.WrapTException(_write_err232)
	}
	return true, err
}

type tHBaseServiceProcessorCheckAndMutate struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCheckAndMutate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err234 error
	args := THBaseServiceCheckAndMutateArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "checkAndMutate", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceCheckAndMutateResult{}
	if retval, err2 := p.handler.CheckAndMutate(ctx, args.Table, args.Row, args.Family, args.Qualifier, args.CompareOp, args.Value, args.RowMutations); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc235 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkAndMutate: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "checkAndMutate", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err234 = thrift.WrapTException(err2)
			}
			if err2 := _exc235.Write(ctx, oprot); _write_err234 == nil && err2 != nil {
				_write_err234 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err234 == nil && err2 != nil {
				_write_err234 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err234 == nil && err2 != nil {
				_write_err234 = thrift.WrapTException(err2)
			}
			if _write_err234 != nil {
				return false, thrift.WrapTException(_write_err234)
			}
			return true, err
		}
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "checkAndMutate", thrift.REPLY, seqId); err2 != nil {
		_write_err234 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err234 == nil && err2 != nil {
		_write_err234 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err234 == nil && err2 != nil {
		_write_err234 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err234 == nil && err2 != nil {
		_write_err234 = thrift.WrapTException(err2)
	}
	if _write_err234 != nil {
		return false, thrift.WrapTException(_write_err234)
	}
	return true, err
}

type tHBaseServiceProcessorGetTableDescriptor struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableDescriptor) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err236 error
	args := THBaseServiceGetTableDescriptorArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "getTableDescriptor", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceGetTableDescriptorResult{}
	if retval, err2 := p.handler.GetTableDescriptor(ctx, args.Table); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc237 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableDescriptor: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "getTableDescriptor", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err236 = thrift.WrapTException(err2)
			}
			if err2 := _exc237.Write(ctx, oprot); _write_err236 == nil && err2 != nil {
				_write_err236 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err236 == nil && err2 != nil {
				_write_err236 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err236 == nil && err2 != nil {
				_write_err236 = thrift.WrapTException(err2)
			}
			if _write_err236 != nil {
				return false, thrift.WrapTException(_write_err236)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "getTableDescriptor", thrift.REPLY, seqId); err2 != nil {
		_write_err236 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err236 == nil && err2 != nil {
		_write_err236 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err236 == nil && err2 != nil {
		_write_err236 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err236 == nil && err2 != nil {
		_write_err236 = thrift.WrapTException(err2)
	}
	if _write_err236 != nil {
		return false, thrift.WrapTException(_write_err236)
	}
	return true, err
}

type tHBaseServiceProcessorGetTableDescriptors struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableDescriptors) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err238 error
	args := THBaseServiceGetTableDescriptorsArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "getTableDescriptors", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceGetTableDescriptorsResult{}
	if retval, err2 := p.handler.GetTableDescriptors(ctx, args.Tables); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc239 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableDescriptors: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "getTableDescriptors", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err238 = thrift.WrapTException(err2)
			}
			if err2 := _exc239.Write(ctx, oprot); _write_err238 == nil && err2 != nil {
				_write_err238 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err238 == nil && err2 != nil {
				_write_err238 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err238 == nil && err2 != nil {
				_write_err238 = thrift.WrapTException(err2)
			}
			if _write_err238 != nil {
				return false, thrift.WrapTException(_write_err238)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "getTableDescriptors", thrift.REPLY, seqId); err2 != nil {
		_write_err238 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err238 == nil && err2 != nil {
		_write_err238 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err238 == nil && err2 != nil {
		_write_err238 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err238 == nil && err2 != nil {
		_write_err238 = thrift.WrapTException(err2)
	}
	if _write_err238 != nil {
		return false, thrift.WrapTException(_write_err238)
	}
	return true, err
}

type tHBaseServiceProcessorTableExists struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorTableExists) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err240 error
	args := THBaseServiceTableExistsArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "tableExists", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceTableExistsResult{}
	if retval, err2 := p.handler.TableExists(ctx, args.TableName); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc241 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing tableExists: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "tableExists", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err240 = thrift.WrapTException(err2)
			}
			if err2 := _exc241.Write(ctx, oprot); _write_err240 == nil && err2 != nil {
				_write_err240 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err240 == nil && err2 != nil {
				_write_err240 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err240 == nil && err2 != nil {
				_write_err240 = thrift.WrapTException(err2)
			}
			if _write_err240 != nil {
				return false, thrift.WrapTException(_write_err240)
			}
			return true, err
		}
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "tableExists", thrift.REPLY, seqId); err2 != nil {
		_write_err240 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err240 == nil && err2 != nil {
		_write_err240 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err240 == nil && err2 != nil {
		_write_err240 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err240 == nil && err2 != nil {
		_write_err240 = thrift.WrapTException(err2)
	}
	if _write_err240 != nil {
		return false, thrift.WrapTException(_write_err240)
	}
	return true, err
}

type tHBaseServiceProcessorGetTableDescriptorsByPattern struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableDescriptorsByPattern) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err242 error
	args := THBaseServiceGetTableDescriptorsByPatternArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "getTableDescriptorsByPattern", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceGetTableDescriptorsByPatternResult{}
	if retval, err2 := p.handler.GetTableDescriptorsByPattern(ctx, args.Regex, args.IncludeSysTables); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc243 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableDescriptorsByPattern: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "getTableDescriptorsByPattern", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err242 = thrift.WrapTException(err2)
			}
			if err2 := _exc243.Write(ctx, oprot); _write_err242 == nil && err2 != nil {
				_write_err242 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err242 == nil && err2 != nil {
				_write_err242 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err242 == nil && err2 != nil {
				_write_err242 = thrift.WrapTException(err2)
			}
			if _write_err242 != nil {
				return false, thrift.WrapTException(_write_err242)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "getTableDescriptorsByPattern", thrift.REPLY, seqId); err2 != nil {
		_write_err242 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err242 == nil && err2 != nil {
		_write_err242 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err242 == nil && err2 != nil {
		_write_err242 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err242 == nil && err2 != nil {
		_write_err242 = thrift.WrapTException(err2)
	}
	if _write_err242 != nil {
		return false, thrift.WrapTException(_write_err242)
	}
	return true, err
}

type tHBaseServiceProcessorGetTableDescriptorsByNamespace struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableDescriptorsByNamespace) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err244 error
	args := THBaseServiceGetTableDescriptorsByNamespaceArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "getTableDescriptorsByNamespace", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceGetTableDescriptorsByNamespaceResult{}
	if retval, err2 := p.handler.GetTableDescriptorsByNamespace(ctx, args.Name); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc245 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableDescriptorsByNamespace: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "getTableDescriptorsByNamespace", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err244 = thrift.WrapTException(err2)
			}
			if err2 := _exc245.Write(ctx, oprot); _write_err244 == nil && err2 != nil {
				_write_err244 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err244 == nil && err2 != nil {
				_write_err244 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err244 == nil && err2 != nil {
				_write_err244 = thrift.WrapTException(err2)
			}
			if _write_err244 != nil {
				return false, thrift.WrapTException(_write_err244)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "getTableDescriptorsByNamespace", thrift.REPLY, seqId); err2 != nil {
		_write_err244 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err244 == nil && err2 != nil {
		_write_err244 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err244 == nil && err2 != nil {
		_write_err244 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err244 == nil && err2 != nil {
		_write_err244 = thrift.WrapTException(err2)
	}
	if _write_err244 != nil {
		return false, thrift.WrapTException(_write_err244)
	}
	return true, err
}

type tHBaseServiceProcessorGetTableNamesByPattern struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableNamesByPattern) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err246 error
	args := THBaseServiceGetTableNamesByPatternArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "getTableNamesByPattern", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceGetTableNamesByPatternResult{}
	if retval, err2 := p.handler.GetTableNamesByPattern(ctx, args.Regex, args.IncludeSysTables); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc247 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableNamesByPattern: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "getTableNamesByPattern", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err246 = thrift.WrapTException(err2)
			}
			if err2 := _exc247.Write(ctx, oprot); _write_err246 == nil && err2 != nil {
				_write_err246 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err246 == nil && err2 != nil {
				_write_err246 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err246 == nil && err2 != nil {
				_write_err246 = thrift.WrapTException(err2)
			}
			if _write_err246 != nil {
				return false, thrift.WrapTException(_write_err246)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "getTableNamesByPattern", thrift.REPLY, seqId); err2 != nil {
		_write_err246 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err246 == nil && err2 != nil {
		_write_err246 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err246 == nil && err2 != nil {
		_write_err246 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err246 == nil && err2 != nil {
		_write_err246 = thrift.WrapTException(err2)
	}
	if _write_err246 != nil {
		return false, thrift.WrapTException(_write_err246)
	}
	return true, err
}

type tHBaseServiceProcessorGetTableNamesByNamespace struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableNamesByNamespace) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err248 error
	args := THBaseServiceGetTableNamesByNamespaceArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "getTableNamesByNamespace", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceGetTableNamesByNamespaceResult{}
	if retval, err2 := p.handler.GetTableNamesByNamespace(ctx, args.Name); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc249 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableNamesByNamespace: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "getTableNamesByNamespace", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err248 = thrift.WrapTException(err2)
			}
			if err2 := _exc249.Write(ctx, oprot); _write_err248 == nil && err2 != nil {
				_write_err248 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err248 == nil && err2 != nil {
				_write_err248 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err248 == nil && err2 != nil {
				_write_err248 = thrift.WrapTException(err2)
			}
			if _write_err248 != nil {
				return false, thrift.WrapTException(_write_err248)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "getTableNamesByNamespace", thrift.REPLY, seqId); err2 != nil {
		_write_err248 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err248 == nil && err2 != nil {
		_write_err248 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err248 == nil && err2 != nil {
		_write_err248 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err248 == nil && err2 != nil {
		_write_err248 = thrift.WrapTException(err2)
	}
	if _write_err248 != nil {
		return false, thrift.WrapTException(_write_err248)
	}
	return true, err
}

type tHBaseServiceProcessorCreateTable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCreateTable) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err250 error
	args := THBaseServiceCreateTableArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "createTable", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceCreateTableResult{}
	if err2 := p.handler.CreateTable(ctx, args.Desc, args.SplitKeys); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc251 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createTable: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "createTable", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err250 = thrift.WrapTException(err2)
			}
			if err2 := _exc251.Write(ctx, oprot); _write_err250 == nil && err2 != nil {
				_write_err250 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err250 == nil && err2 != nil {
				_write_err250 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err250 == nil && err2 != nil {
				_write_err250 = thrift.WrapTException(err2)
			}
			if _write_err250 != nil {
				return false, thrift.WrapTException(_write_err250)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "createTable", thrift.REPLY, seqId); err2 != nil {
		_write_err250 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err250 == nil && err2 != nil {
		_write_err250 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err250 == nil && err2 != nil {
		_write_err250 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err250 == nil && err2 != nil {
		_write_err250 = thrift.WrapTException(err2)
	}
	if _write_err250 != nil {
		return false, thrift.WrapTException(_write_err250)
	}
	return true, err
}

type tHBaseServiceProcessorDeleteTable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteTable) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err252 error
	args := THBaseServiceDeleteTableArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "deleteTable", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceDeleteTableResult{}
	if err2 := p.handler.DeleteTable(ctx, args.TableName); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc253 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteTable: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "deleteTable", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err252 = thrift.WrapTException(err2)
			}
			if err2 := _exc253.Write(ctx, oprot); _write_err252 == nil && err2 != nil {
				_write_err252 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err252 == nil && err2 != nil {
				_write_err252 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err252 == nil && err2 != nil {
				_write_err252 = thrift.WrapTException(err2)
			}
			if _write_err252 != nil {
				return false, thrift.WrapTException(_write_err252)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "deleteTable", thrift.REPLY, seqId); err2 != nil {
		_write_err252 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err252 == nil && err2 != nil {
		_write_err252 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err252 == nil && err2 != nil {
		_write_err252 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err252 == nil && err2 != nil {
		_write_err252 = thrift.WrapTException(err2)
	}
	if _write_err252 != nil {
		return false, thrift.WrapTException(_write_err252)
	}
	return true, err
}

type tHBaseServiceProcessorTruncateTable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorTruncateTable) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err254 error
	args := THBaseServiceTruncateTableArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "truncateTable", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceTruncateTableResult{}
	if err2 := p.handler.TruncateTable(ctx, args.TableName, args.PreserveSplits); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc255 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing truncateTable: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "truncateTable", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err254 = thrift.WrapTException(err2)
			}
			if err2 := _exc255.Write(ctx, oprot); _write_err254 == nil && err2 != nil {
				_write_err254 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err254 == nil && err2 != nil {
				_write_err254 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err254 == nil && err2 != nil {
				_write_err254 = thrift.WrapTException(err2)
			}
			if _write_err254 != nil {
				return false, thrift.WrapTException(_write_err254)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "truncateTable", thrift.REPLY, seqId); err2 != nil {
		_write_err254 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err254 == nil && err2 != nil {
		_write_err254 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err254 == nil && err2 != nil {
		_write_err254 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err254 == nil && err2 != nil {
		_write_err254 = thrift.WrapTException(err2)
	}
	if _write_err254 != nil {
		return false, thrift.WrapTException(_write_err254)
	}
	return true, err
}

type tHBaseServiceProcessorEnableTable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorEnableTable) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err256 error
	args := THBaseServiceEnableTableArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "enableTable", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceEnableTableResult{}
	if err2 := p.handler.EnableTable(ctx, args.TableName); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc257 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing enableTable: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "enableTable", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err256 = thrift.WrapTException(err2)
			}
			if err2 := _exc257.Write(ctx, oprot); _write_err256 == nil && err2 != nil {
				_write_err256 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err256 == nil && err2 != nil {
				_write_err256 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err256 == nil && err2 != nil {
				_write_err256 = thrift.WrapTException(err2)
			}
			if _write_err256 != nil {
				return false, thrift.WrapTException(_write_err256)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "enableTable", thrift.REPLY, seqId); err2 != nil {
		_write_err256 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err256 == nil && err2 != nil {
		_write_err256 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err256 == nil && err2 != nil {
		_write_err256 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err256 == nil && err2 != nil {
		_write_err256 = thrift.WrapTException(err2)
	}
	if _write_err256 != nil {
		return false, thrift.WrapTException(_write_err256)
	}
	return true, err
}

type tHBaseServiceProcessorDisableTable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDisableTable) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err258 error
	args := THBaseServiceDisableTableArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "disableTable", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceDisableTableResult{}
	if err2 := p.handler.DisableTable(ctx, args.TableName); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc259 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing disableTable: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "disableTable", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err258 = thrift.WrapTException(err2)
			}
			if err2 := _exc259.Write(ctx, oprot); _write_err258 == nil && err2 != nil {
				_write_err258 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err258 == nil && err2 != nil {
				_write_err258 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err258 == nil && err2 != nil {
				_write_err258 = thrift.WrapTException(err2)
			}
			if _write_err258 != nil {
				return false, thrift.WrapTException(_write_err258)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "disableTable", thrift.REPLY, seqId); err2 != nil {
		_write_err258 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err258 == nil && err2 != nil {
		_write_err258 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err258 == nil && err2 != nil {
		_write_err258 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err258 == nil && err2 != nil {
		_write_err258 = thrift.WrapTException(err2)
	}
	if _write_err258 != nil {
		return false, thrift.WrapTException(_write_err258)
	}
	return true, err
}

type tHBaseServiceProcessorIsTableEnabled struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorIsTableEnabled) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err260 error
	args := THBaseServiceIsTableEnabledArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "isTableEnabled", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceIsTableEnabledResult{}
	if retval, err2 := p.handler.IsTableEnabled(ctx, args.TableName); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc261 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing isTableEnabled: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "isTableEnabled", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err260 = thrift.WrapTException(err2)
			}
			if err2 := _exc261.Write(ctx, oprot); _write_err260 == nil && err2 != nil {
				_write_err260 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err260 == nil && err2 != nil {
				_write_err260 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err260 == nil && err2 != nil {
				_write_err260 = thrift.WrapTException(err2)
			}
			if _write_err260 != nil {
				return false, thrift.WrapTException(_write_err260)
			}
			return true, err
		}
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "isTableEnabled", thrift.REPLY, seqId); err2 != nil {
		_write_err260 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err260 == nil && err2 != nil {
		_write_err260 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err260 == nil && err2 != nil {
		_write_err260 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err260 == nil && err2 != nil {
		_write_err260 = thrift.WrapTException(err2)
	}
	if _write_err260 != nil {
		return false, thrift.WrapTException(_write_err260)
	}
	return true, err
}

type tHBaseServiceProcessorIsTableDisabled struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorIsTableDisabled) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err262 error
	args := THBaseServiceIsTableDisabledArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "isTableDisabled", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceIsTableDisabledResult{}
	if retval, err2 := p.handler.IsTableDisabled(ctx, args.TableName); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc263 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing isTableDisabled: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "isTableDisabled", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err262 = thrift.WrapTException(err2)
			}
			if err2 := _exc263.Write(ctx, oprot); _write_err262 == nil && err2 != nil {
				_write_err262 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err262 == nil && err2 != nil {
				_write_err262 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err262 == nil && err2 != nil {
				_write_err262 = thrift.WrapTException(err2)
			}
			if _write_err262 != nil {
				return false, thrift.WrapTException(_write_err262)
			}
			return true, err
		}
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "isTableDisabled", thrift.REPLY, seqId); err2 != nil {
		_write_err262 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err262 == nil && err2 != nil {
		_write_err262 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err262 == nil && err2 != nil {
		_write_err262 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err262 == nil && err2 != nil {
		_write_err262 = thrift.WrapTException(err2)
	}
	if _write_err262 != nil {
		return false, thrift.WrapTException(_write_err262)
	}
	return true, err
}

type tHBaseServiceProcessorIsTableAvailable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorIsTableAvailable) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err264 error
	args := THBaseServiceIsTableAvailableArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "isTableAvailable", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceIsTableAvailableResult{}
	if retval, err2 := p.handler.IsTableAvailable(ctx, args.TableName); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc265 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing isTableAvailable: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "isTableAvailable", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err264 = thrift.WrapTException(err2)
			}
			if err2 := _exc265.Write(ctx, oprot); _write_err264 == nil && err2 != nil {
				_write_err264 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err264 == nil && err2 != nil {
				_write_err264 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err264 == nil && err2 != nil {
				_write_err264 = thrift.WrapTException(err2)
			}
			if _write_err264 != nil {
				return false, thrift.WrapTException(_write_err264)
			}
			return true, err
		}
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "isTableAvailable", thrift.REPLY, seqId); err2 != nil {
		_write_err264 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err264 == nil && err2 != nil {
		_write_err264 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err264 == nil && err2 != nil {
		_write_err264 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err264 == nil && err2 != nil {
		_write_err264 = thrift.WrapTException(err2)
	}
	if _write_err264 != nil {
		return false, thrift.WrapTException(_write_err264)
	}
	return true, err
}

type tHBaseServiceProcessorIsTableAvailableWithSplit struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorIsTableAvailableWithSplit) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err266 error
	args := THBaseServiceIsTableAvailableWithSplitArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "isTableAvailableWithSplit", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceIsTableAvailableWithSplitResult{}
	if retval, err2 := p.handler.IsTableAvailableWithSplit(ctx, args.TableName, args.SplitKeys); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc267 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing isTableAvailableWithSplit: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "isTableAvailableWithSplit", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err266 = thrift.WrapTException(err2)
			}
			if err2 := _exc267.Write(ctx, oprot); _write_err266 == nil && err2 != nil {
				_write_err266 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err266 == nil && err2 != nil {
				_write_err266 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err266 == nil && err2 != nil {
				_write_err266 = thrift.WrapTException(err2)
			}
			if _write_err266 != nil {
				return false, thrift.WrapTException(_write_err266)
			}
			return true, err
		}
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "isTableAvailableWithSplit", thrift.REPLY, seqId); err2 != nil {
		_write_err266 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err266 == nil && err2 != nil {
		_write_err266 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err266 == nil && err2 != nil {
		_write_err266 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err266 == nil && err2 != nil {
		_write_err266 = thrift.WrapTException(err2)
	}
	if _write_err266 != nil {
		return false, thrift.WrapTException(_write_err266)
	}
	return true, err
}

type tHBaseServiceProcessorAddColumnFamily struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorAddColumnFamily) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err268 error
	args := THBaseServiceAddColumnFamilyArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "addColumnFamily", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceAddColumnFamilyResult{}
	if err2 := p.handler.AddColumnFamily(ctx, args.TableName, args.Column); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc269 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing addColumnFamily: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "addColumnFamily", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err268 = thrift.WrapTException(err2)
			}
			if err2 := _exc269.Write(ctx, oprot); _write_err268 == nil && err2 != nil {
				_write_err268 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err268 == nil && err2 != nil {
				_write_err268 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err268 == nil && err2 != nil {
				_write_err268 = thrift.WrapTException(err2)
			}
			if _write_err268 != nil {
				return false, thrift.WrapTException(_write_err268)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "addColumnFamily", thrift.REPLY, seqId); err2 != nil {
		_write_err268 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err268 == nil && err2 != nil {
		_write_err268 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err268 == nil && err2 != nil {
		_write_err268 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err268 == nil && err2 != nil {
		_write_err268 = thrift.WrapTException(err2)
	}
	if _write_err268 != nil {
		return false, thrift.WrapTException(_write_err268)
	}
	return true, err
}

type tHBaseServiceProcessorDeleteColumnFamily struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteColumnFamily) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err270 error
	args := THBaseServiceDeleteColumnFamilyArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "deleteColumnFamily", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceDeleteColumnFamilyResult{}
	if err2 := p.handler.DeleteColumnFamily(ctx, args.TableName, args.Column); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc271 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteColumnFamily: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "deleteColumnFamily", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err270 = thrift.WrapTException(err2)
			}
			if err2 := _exc271.Write(ctx, oprot); _write_err270 == nil && err2 != nil {
				_write_err270 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err270 == nil && err2 != nil {
				_write_err270 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err270 == nil && err2 != nil {
				_write_err270 = thrift.WrapTException(err2)
			}
			if _write_err270 != nil {
				return false, thrift.WrapTException(_write_err270)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "deleteColumnFamily", thrift.REPLY, seqId); err2 != nil {
		_write_err270 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err270 == nil && err2 != nil {
		_write_err270 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err270 == nil && err2 != nil {
		_write_err270 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err270 == nil && err2 != nil {
		_write_err270 = thrift.WrapTException(err2)
	}
	if _write_err270 != nil {
		return false, thrift.WrapTException(_write_err270)
	}
	return true, err
}

type tHBaseServiceProcessorModifyColumnFamily struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorModifyColumnFamily) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err272 error
	args := THBaseServiceModifyColumnFamilyArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "modifyColumnFamily", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceModifyColumnFamilyResult{}
	if err2 := p.handler.ModifyColumnFamily(ctx, args.TableName, args.Column); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc273 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing modifyColumnFamily: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "modifyColumnFamily", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err272 = thrift.WrapTException(err2)
			}
			if err2 := _exc273.Write(ctx, oprot); _write_err272 == nil && err2 != nil {
				_write_err272 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err272 == nil && err2 != nil {
				_write_err272 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err272 == nil && err2 != nil {
				_write_err272 = thrift.WrapTException(err2)
			}
			if _write_err272 != nil {
				return false, thrift.WrapTException(_write_err272)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "modifyColumnFamily", thrift.REPLY, seqId); err2 != nil {
		_write_err272 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err272 == nil && err2 != nil {
		_write_err272 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err272 == nil && err2 != nil {
		_write_err272 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err272 == nil && err2 != nil {
		_write_err272 = thrift.WrapTException(err2)
	}
	if _write_err272 != nil {
		return false, thrift.WrapTException(_write_err272)
	}
	return true, err
}

type tHBaseServiceProcessorModifyTable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorModifyTable) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err274 error
	args := THBaseServiceModifyTableArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "modifyTable", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceModifyTableResult{}
	if err2 := p.handler.ModifyTable(ctx, args.Desc); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc275 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing modifyTable: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "modifyTable", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err274 = thrift.WrapTException(err2)
			}
			if err2 := _exc275.Write(ctx, oprot); _write_err274 == nil && err2 != nil {
				_write_err274 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err274 == nil && err2 != nil {
				_write_err274 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err274 == nil && err2 != nil {
				_write_err274 = thrift.WrapTException(err2)
			}
			if _write_err274 != nil {
				return false, thrift.WrapTException(_write_err274)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "modifyTable", thrift.REPLY, seqId); err2 != nil {
		_write_err274 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err274 == nil && err2 != nil {
		_write_err274 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err274 == nil && err2 != nil {
		_write_err274 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err274 == nil && err2 != nil {
		_write_err274 = thrift.WrapTException(err2)
	}
	if _write_err274 != nil {
		return false, thrift.WrapTException(_write_err274)
	}
	return true, err
}

type tHBaseServiceProcessorCreateNamespace struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCreateNamespace) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err276 error
	args := THBaseServiceCreateNamespaceArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "createNamespace", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceCreateNamespaceResult{}
	if err2 := p.handler.CreateNamespace(ctx, args.NamespaceDesc); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc277 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createNamespace: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "createNamespace", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err276 = thrift.WrapTException(err2)
			}
			if err2 := _exc277.Write(ctx, oprot); _write_err276 == nil && err2 != nil {
				_write_err276 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err276 == nil && err2 != nil {
				_write_err276 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err276 == nil && err2 != nil {
				_write_err276 = thrift.WrapTException(err2)
			}
			if _write_err276 != nil {
				return false, thrift.WrapTException(_write_err276)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "createNamespace", thrift.REPLY, seqId); err2 != nil {
		_write_err276 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err276 == nil && err2 != nil {
		_write_err276 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err276 == nil && err2 != nil {
		_write_err276 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err276 == nil && err2 != nil {
		_write_err276 = thrift.WrapTException(err2)
	}
	if _write_err276 != nil {
		return false, thrift.WrapTException(_write_err276)
	}
	return true, err
}

type tHBaseServiceProcessorModifyNamespace struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorModifyNamespace) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err278 error
	args := THBaseServiceModifyNamespaceArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "modifyNamespace", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceModifyNamespaceResult{}
	if err2 := p.handler.ModifyNamespace(ctx, args.NamespaceDesc); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc279 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing modifyNamespace: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "modifyNamespace", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err278 = thrift.WrapTException(err2)
			}
			if err2 := _exc279.Write(ctx, oprot); _write_err278 == nil && err2 != nil {
				_write_err278 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err278 == nil && err2 != nil {
				_write_err278 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err278 == nil && err2 != nil {
				_write_err278 = thrift.WrapTException(err2)
			}
			if _write_err278 != nil {
				return false, thrift.WrapTException(_write_err278)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "modifyNamespace", thrift.REPLY, seqId); err2 != nil {
		_write_err278 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err278 == nil && err2 != nil {
		_write_err278 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err278 == nil && err2 != nil {
		_write_err278 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err278 == nil && err2 != nil {
		_write_err278 = thrift.WrapTException(err2)
	}
	if _write_err278 != nil {
		return false, thrift.WrapTException(_write_err278)
	}
	return true, err
}

type tHBaseServiceProcessorDeleteNamespace struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteNamespace) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err280 error
	args := THBaseServiceDeleteNamespaceArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "deleteNamespace", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceDeleteNamespaceResult{}
	if err2 := p.handler.DeleteNamespace(ctx, args.Name); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc281 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteNamespace: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "deleteNamespace", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err280 = thrift.WrapTException(err2)
			}
			if err2 := _exc281.Write(ctx, oprot); _write_err280 == nil && err2 != nil {
				_write_err280 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err280 == nil && err2 != nil {
				_write_err280 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err280 == nil && err2 != nil {
				_write_err280 = thrift.WrapTException(err2)
			}
			if _write_err280 != nil {
				return false, thrift.WrapTException(_write_err280)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "deleteNamespace", thrift.REPLY, seqId); err2 != nil {
		_write_err280 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err280 == nil && err2 != nil {
		_write_err280 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err280 == nil && err2 != nil {
		_write_err280 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err280 == nil && err2 != nil {
		_write_err280 = thrift.WrapTException(err2)
	}
	if _write_err280 != nil {
		return false, thrift.WrapTException(_write_err280)
	}
	return true, err
}

type tHBaseServiceProcessorGetNamespaceDescriptor struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetNamespaceDescriptor) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err282 error
	args := THBaseServiceGetNamespaceDescriptorArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "getNamespaceDescriptor", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceGetNamespaceDescriptorResult{}
	if retval, err2 := p.handler.GetNamespaceDescriptor(ctx, args.Name); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc283 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNamespaceDescriptor: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "getNamespaceDescriptor", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err282 = thrift.WrapTException(err2)
			}
			if err2 := _exc283.Write(ctx, oprot); _write_err282 == nil && err2 != nil {
				_write_err282 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err282 == nil && err2 != nil {
				_write_err282 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err282 == nil && err2 != nil {
				_write_err282 = thrift.WrapTException(err2)
			}
			if _write_err282 != nil {
				return false, thrift.WrapTException(_write_err282)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "getNamespaceDescriptor", thrift.REPLY, seqId); err2 != nil {
		_write_err282 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err282 == nil && err2 != nil {
		_write_err282 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err282 == nil && err2 != nil {
		_write_err282 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err282 == nil && err2 != nil {
		_write_err282 = thrift.WrapTException(err2)
	}
	if _write_err282 != nil {
		return false, thrift.WrapTException(_write_err282)
	}
	return true, err
}

type tHBaseServiceProcessorListNamespaceDescriptors struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorListNamespaceDescriptors) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err284 error
	args := THBaseServiceListNamespaceDescriptorsArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "listNamespaceDescriptors", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := THBaseServiceListNamespaceDescriptorsResult{}
	if retval, err2 := p.handler.ListNamespaceDescriptors(ctx); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			_exc285 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listNamespaceDescriptors: "+err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "listNamespaceDescriptors", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err284 = thrift.WrapTException(err2)
			}
			if err2 := _exc285.Write(ctx, oprot); _write_err284 == nil && err2 != nil {
				_write_err284 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err284 == nil && err2 != nil {
				_write_err284 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err284 == nil && err2 != nil {
				_write_err284 = thrift.WrapTException(err2)
			}
			if _write_err284 != nil {
				return false, thrift.WrapTException(_write_err284)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "listNamespaceDescriptors", thrift.REPLY, seqId); err2 != nil {
		_write_err284 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err284 == nil && err2 != nil {
		_write_err284 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err284 == nil && err2 != nil {
		_write_err284 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err284 == nil && err2 != nil {
		_write_err284 = thrift.WrapTException(err2)
	}
	if _write_err284 != nil {
		return false, thrift.WrapTException(_write_err284)
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//   - Table: the table to check on
//   - Tget: the TGet to check for
type THBaseServiceExistsArgs struct {
	Table []byte `thrift:"table,1,required" db:"table" json:"table"`
	Tget  *TGet  `thrift:"tget,2,required" db:"tget" json:"tget"`
}

func NewTHBaseServiceExistsArgs() *THBaseServiceExistsArgs {
	return &THBaseServiceExistsArgs{}
}

func (p *THBaseServiceExistsArgs) GetTable() []byte {
	return p.Table
}

var THBaseServiceExistsArgs_Tget_DEFAULT *TGet

func (p *THBaseServiceExistsArgs) GetTget() *TGet {
	if !p.IsSetTget() {
		return THBaseServiceExistsArgs_Tget_DEFAULT
	}
	return p.Tget
}
func (p *THBaseServiceExistsArgs) IsSetTget() bool {
	return p.Tget != nil
}

func (p *THBaseServiceExistsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTget bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTable = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetTget = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTget {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tget is not set"))
	}
	return nil
}

func (p *THBaseServiceExistsArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceExistsArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Tget = &TGet{}
	if err := p.Tget.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tget), err)
	}
	return nil
}

func (p *THBaseServiceExistsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "exists_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceExistsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceExistsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tget", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tget: ", p), err)
	}
	if err := p.Tget.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tget), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tget: ", p), err)
	}
	return err
}

func (p *THBaseServiceExistsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceExistsArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceExistsResult struct {
	Success *bool     `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceExistsResult() *THBaseServiceExistsResult {
	return &THBaseServiceExistsResult{}
}

var THBaseServiceExistsResult_Success_DEFAULT bool

func (p *THBaseServiceExistsResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return THBaseServiceExistsResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceExistsResult_Io_DEFAULT *TIOError

func (p *THBaseServiceExistsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceExistsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceExistsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceExistsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceExistsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceExistsResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceExistsResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceExistsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "exists_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceExistsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceExistsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceExistsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceExistsResult(%+v)", *p)
}

// Attributes:
//   - Table: the table to check on
//   - Tgets: a list of TGets to check for
type THBaseServiceExistsAllArgs struct {
	Table []byte  `thrift:"table,1,required" db:"table" json:"table"`
	Tgets []*TGet `thrift:"tgets,2,required" db:"tgets" json:"tgets"`
}

func NewTHBaseServiceExistsAllArgs() *THBaseServiceExistsAllArgs {
	return &THBaseServiceExistsAllArgs{}
}

func (p *THBaseServiceExistsAllArgs) GetTable() []byte {
	return p.Table
}

func (p *THBaseServiceExistsAllArgs) GetTgets() []*TGet {
	return p.Tgets
}
func (p *THBaseServiceExistsAllArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTgets bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTable = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetTgets = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTgets {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tgets is not set"))
	}
	return nil
}

func (p *THBaseServiceExistsAllArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceExistsAllArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TGet, 0, size)
	p.Tgets = tSlice
	for i := 0; i < size; i++ {
		_elem286 := &TGet{}
		if err := _elem286.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem286), err)
		}
		p.Tgets = append(p.Tgets, _elem286)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceExistsAllArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "existsAll_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceExistsAllArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceExistsAllArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tgets", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tgets: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Tgets)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Tgets {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tgets: ", p), err)
	}
	return err
}

func (p *THBaseServiceExistsAllArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceExistsAllArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceExistsAllResult struct {
	Success []bool    `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceExistsAllResult() *THBaseServiceExistsAllResult {
	return &THBaseServiceExistsAllResult{}
}

var THBaseServiceExistsAllResult_Success_DEFAULT []bool

func (p *THBaseServiceExistsAllResult) GetSuccess() []bool {
	return p.Success
}

var THBaseServiceExistsAllResult_Io_DEFAULT *TIOError

func (p *THBaseServiceExistsAllResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceExistsAllResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceExistsAllResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceExistsAllResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceExistsAllResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceExistsAllResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]bool, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		var _elem287 bool
		if v, err := iprot.ReadBool(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem287 = v
		}
		p.Success = append(p.Success, _elem287)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceExistsAllResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceExistsAllResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "existsAll_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceExistsAllResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.BOOL, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := oprot.WriteBool(ctx, bool(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceExistsAllResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceExistsAllResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceExistsAllResult(%+v)", *p)
}

// Attributes:
//   - Table: the table to get from
//   - Tget: the TGet to fetch
type THBaseServiceGetArgs struct {
	Table []byte `thrift:"table,1,required" db:"table" json:"table"`
	Tget  *TGet  `thrift:"tget,2,required" db:"tget" json:"tget"`
}

func NewTHBaseServiceGetArgs() *THBaseServiceGetArgs {
	return &THBaseServiceGetArgs{}
}

func (p *THBaseServiceGetArgs) GetTable() []byte {
	return p.Table
}

var THBaseServiceGetArgs_Tget_DEFAULT *TGet

func (p *THBaseServiceGetArgs) GetTget() *TGet {
	if !p.IsSetTget() {
		return THBaseServiceGetArgs_Tget_DEFAULT
	}
	return p.Tget
}
func (p *THBaseServiceGetArgs) IsSetTget() bool {
	return p.Tget != nil
}

func (p *THBaseServiceGetArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTget bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTable = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetTget = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTget {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tget is not set"))
	}
	return nil
}

func (p *THBaseServiceGetArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceGetArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Tget = &TGet{}
	if err := p.Tget.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tget), err)
	}
	return nil
}

func (p *THBaseServiceGetArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "get_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tget", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tget: ", p), err)
	}
	if err := p.Tget.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tget), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tget: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceGetResult struct {
	Success *TResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetResult() *THBaseServiceGetResult {
	return &THBaseServiceGetResult{}
}

var THBaseServiceGetResult_Success_DEFAULT *TResult_

func (p *THBaseServiceGetResult) GetSuccess() *TResult_ {
	if !p.IsSetSuccess() {
		return THBaseServiceGetResult_Success_DEFAULT
	}
	return p.Success
}

var THBaseServiceGetResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &TResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *THBaseServiceGetResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "get_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetResult(%+v)", *p)
}

// Attributes:
//   - Table: the table to get from
//   - Tgets: a list of TGets to fetch, the Result list
//
// will have the Results at corresponding positions
// or null if there was an error
type THBaseServiceGetMultipleArgs struct {
	Table []byte  `thrift:"table,1,required" db:"table" json:"table"`
	Tgets []*TGet `thrift:"tgets,2,required" db:"tgets" json:"tgets"`
}

func NewTHBaseServiceGetMultipleArgs() *THBaseServiceGetMultipleArgs {
	return &THBaseServiceGetMultipleArgs{}
}

func (p *THBaseServiceGetMultipleArgs) GetTable() []byte {
	return p.Table
}

func (p *THBaseServiceGetMultipleArgs) GetTgets() []*TGet {
	return p.Tgets
}
func (p *THBaseServiceGetMultipleArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTgets bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTable = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetTgets = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTgets {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tgets is not set"))
	}
	return nil
}

func (p *THBaseServiceGetMultipleArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceGetMultipleArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TGet, 0, size)
	p.Tgets = tSlice
	for i := 0; i < size; i++ {
		_elem288 := &TGet{}
		if err := _elem288.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem288), err)
		}
		p.Tgets = append(p.Tgets, _elem288)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetMultipleArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getMultiple_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetMultipleArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetMultipleArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tgets", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tgets: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Tgets)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Tgets {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tgets: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetMultipleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetMultipleArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceGetMultipleResult struct {
	Success []*TResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError   `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetMultipleResult() *THBaseServiceGetMultipleResult {
	return &THBaseServiceGetMultipleResult{}
}

var THBaseServiceGetMultipleResult_Success_DEFAULT []*TResult_

func (p *THBaseServiceGetMultipleResult) GetSuccess() []*TResult_ {
	return p.Success
}

var THBaseServiceGetMultipleResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetMultipleResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetMultipleResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetMultipleResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetMultipleResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetMultipleResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetMultipleResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem289 := &TResult_{}
		if err := _elem289.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem289), err)
		}
		p.Success = append(p.Success, _elem289)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetMultipleResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetMultipleResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getMultiple_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetMultipleResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetMultipleResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetMultipleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetMultipleResult(%+v)", *p)
}

// Attributes:
//   - Table: the table to put data in
//   - Tput: the TPut to put
type THBaseServicePutArgs struct {
	Table []byte `thrift:"table,1,required" db:"table" json:"table"`
	Tput  *TPut  `thrift:"tput,2,required" db:"tput" json:"tput"`
}

func NewTHBaseServicePutArgs() *THBaseServicePutArgs {
	return &THBaseServicePutArgs{}
}

func (p *THBaseServicePutArgs) GetTable() []byte {
	return p.Table
}

var THBaseServicePutArgs_Tput_DEFAULT *TPut

func (p *THBaseServicePutArgs) GetTput() *TPut {
	if !p.IsSetTput() {
		return THBaseServicePutArgs_Tput_DEFAULT
	}
	return p.Tput
}
func (p *THBaseServicePutArgs) IsSetTput() bool {
	return p.Tput != nil
}

func (p *THBaseServicePutArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTput bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTable = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetTput = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTput {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tput is not set"))
	}
	return nil
}

func (p *THBaseServicePutArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServicePutArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Tput = &TPut{}
	if err := p.Tput.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tput), err)
	}
	return nil
}

func (p *THBaseServicePutArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "put_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServicePutArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServicePutArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tput", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tput: ", p), err)
	}
	if err := p.Tput.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tput), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tput: ", p), err)
	}
	return err
}

func (p *THBaseServicePutArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServicePutArgs(%+v)", *p)
}

// Attributes:
//   - Io
type THBaseServicePutResult struct {
	Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServicePutResult() *THBaseServicePutResult {
	return &THBaseServicePutResult{}
}

var THBaseServicePutResult_Io_DEFAULT *TIOError

func (p *THBaseServicePutResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServicePutResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServicePutResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServicePutResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServicePutResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServicePutResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "put_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServicePutResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServicePutResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServicePutResult(%+v)", *p)
}

// Attributes:
//   - Table: to check in and put to
//   - Row: row to check
//   - Family: column family to check
//   - Qualifier: column qualifier to check
//   - Value: the expected value, if not provided the
//
// check is for the non-existence of the
// column in question
//   - Tput: the TPut to put if the check succeeds
type THBaseServiceCheckAndPutArgs struct {
	Table     []byte `thrift:"table,1,required" db:"table" json:"table"`
	Row       []byte `thrift:"row,2,required" db:"row" json:"row"`
	Family    []byte `thrift:"family,3,required" db:"family" json:"family"`
	Qualifier []byte `thrift:"qualifier,4,required" db:"qualifier" json:"qualifier"`
	Value     []byte `thrift:"value,5" db:"value" json:"value"`
	Tput      *TPut  `thrift:"tput,6,required" db:"tput" json:"tput"`
}

func NewTHBaseServiceCheckAndPutArgs() *THBaseServiceCheckAndPutArgs {
	return &THBaseServiceCheckAndPutArgs{}
}

func (p *THBaseServiceCheckAndPutArgs) GetTable() []byte {
	return p.Table
}

func (p *THBaseServiceCheckAndPutArgs) GetRow() []byte {
	return p.Row
}

func (p *THBaseServiceCheckAndPutArgs) GetFamily() []byte {
	return p.Family
}

func (p *THBaseServiceCheckAndPutArgs) GetQualifier() []byte {
	return p.Qualifier
}

func (p *THBaseServiceCheckAndPutArgs) GetValue() []byte {
	return p.Value
}

var THBaseServiceCheckAndPutArgs_Tput_DEFAULT *TPut

func (p *THBaseServiceCheckAndPutArgs) GetTput() *TPut {
	if !p.IsSetTput() {
		return THBaseServiceCheckAndPutArgs_Tput_DEFAULT
	}
	return p.Tput
}
func (p *THBaseServiceCheckAndPutArgs) IsSetTput() bool {
	return p.Tput != nil
}

func (p *THBaseServiceCheckAndPutArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetRow bool = false
	var issetFamily bool = false
	var issetQualifier bool = false
	var issetTput bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTable = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetRow = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetFamily = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
				issetQualifier = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
				issetTput = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetRow {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"))
	}
	if !issetFamily {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Family is not set"))
	}
	if !issetQualifier {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Qualifier is not set"))
	}
	if !issetTput {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tput is not set"))
	}
	return nil
}

func (p *THBaseServiceCheckAndPutArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceCheckAndPutArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *THBaseServiceCheckAndPutArgs) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Family = v
	}
	return nil
}

func (p *THBaseServiceCheckAndPutArgs) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.Qualifier = v
	}
	return nil
}

func (p *THBaseServiceCheckAndPutArgs) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *THBaseServiceCheckAndPutArgs) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	p.Tput = &TPut{}
	if err := p.Tput.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tput), err)
	}
	return nil
}

func (p *THBaseServiceCheckAndPutArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "checkAndPut_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField4(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField5(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField6(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCheckAndPutArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndPutArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:row: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Row); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.row (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:row: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndPutArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "family", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:family: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Family); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.family (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:family: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndPutArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "qualifier", thrift.STRING, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:qualifier: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Qualifier); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.qualifier (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:qualifier: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndPutArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:value: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Value); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.value (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:value: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndPutArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tput", thrift.STRUCT, 6); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:tput: ", p), err)
	}
	if err := p.Tput.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tput), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 6:tput: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndPutArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCheckAndPutArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceCheckAndPutResult struct {
	Success *bool     `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceCheckAndPutResult() *THBaseServiceCheckAndPutResult {
	return &THBaseServiceCheckAndPutResult{}
}

var THBaseServiceCheckAndPutResult_Success_DEFAULT bool

func (p *THBaseServiceCheckAndPutResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return THBaseServiceCheckAndPutResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceCheckAndPutResult_Io_DEFAULT *TIOError

func (p *THBaseServiceCheckAndPutResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceCheckAndPutResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceCheckAndPutResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceCheckAndPutResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceCheckAndPutResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceCheckAndPutResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceCheckAndPutResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceCheckAndPutResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "checkAndPut_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCheckAndPutResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCheckAndPutResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCheckAndPutResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCheckAndPutResult(%+v)", *p)
}

// Attributes:
//   - Table: the table to put data in
//   - Tputs: a list of TPuts to commit
type THBaseServicePutMultipleArgs struct {
	Table []byte  `thrift:"table,1,required" db:"table" json:"table"`
	Tputs []*TPut `thrift:"tputs,2,required" db:"tputs" json:"tputs"`
}

func NewTHBaseServicePutMultipleArgs() *THBaseServicePutMultipleArgs {
	return &THBaseServicePutMultipleArgs{}
}

func (p *THBaseServicePutMultipleArgs) GetTable() []byte {
	return p.Table
}

func (p *THBaseServicePutMultipleArgs) GetTputs() []*TPut {
	return p.Tputs
}
func (p *THBaseServicePutMultipleArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTputs bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTable = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetTputs = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTputs {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tputs is not set"))
	}
	return nil
}

func (p *THBaseServicePutMultipleArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServicePutMultipleArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TPut, 0, size)
	p.Tputs = tSlice
	for i := 0; i < size; i++ {
		_elem290 := &TPut{}
		if err := _elem290.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem290), err)
		}
		p.Tputs = append(p.Tputs, _elem290)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServicePutMultipleArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "putMultiple_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServicePutMultipleArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServicePutMultipleArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tputs", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tputs: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Tputs)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Tputs {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tputs: ", p), err)
	}
	return err
}

func (p *THBaseServicePutMultipleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServicePutMultipleArgs(%+v)", *p)
}

// Attributes:
//   - Io
type THBaseServicePutMultipleResult struct {
	Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServicePutMultipleResult() *THBaseServicePutMultipleResult {
	return &THBaseServicePutMultipleResult{}
}

var THBaseServicePutMultipleResult_Io_DEFAULT *TIOError

func (p *THBaseServicePutMultipleResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServicePutMultipleResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServicePutMultipleResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServicePutMultipleResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServicePutMultipleResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServicePutMultipleResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "putMultiple_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServicePutMultipleResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServicePutMultipleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServicePutMultipleResult(%+v)", *p)
}

// Attributes:
//   - Table: the table to delete from
//   - Tdelete: the TDelete to delete
type THBaseServiceDeleteSingleArgs struct {
	Table   []byte   `thrift:"table,1,required" db:"table" json:"table"`
	Tdelete *TDelete `thrift:"tdelete,2,required" db:"tdelete" json:"tdelete"`
}

func NewTHBaseServiceDeleteSingleArgs() *THBaseServiceDeleteSingleArgs {
	return &THBaseServiceDeleteSingleArgs{}
}

func (p *THBaseServiceDeleteSingleArgs) GetTable() []byte {
	return p.Table
}

var THBaseServiceDeleteSingleArgs_Tdelete_DEFAULT *TDelete

func (p *THBaseServiceDeleteSingleArgs) GetTdelete() *TDelete {
	if !p.IsSetTdelete() {
		return THBaseServiceDeleteSingleArgs_Tdelete_DEFAULT
	}
	return p.Tdelete
}
func (p *THBaseServiceDeleteSingleArgs) IsSetTdelete() bool {
	return p.Tdelete != nil
}

func (p *THBaseServiceDeleteSingleArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTdelete bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTable = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetTdelete = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTdelete {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tdelete is not set"))
	}
	return nil
}

func (p *THBaseServiceDeleteSingleArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceDeleteSingleArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Tdelete = &TDelete{
		DeleteType: 1,
	}
	if err := p.Tdelete.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tdelete), err)
	}
	return nil
}

func (p *THBaseServiceDeleteSingleArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "deleteSingle_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteSingleArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceDeleteSingleArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tdelete", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tdelete: ", p), err)
	}
	if err := p.Tdelete.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tdelete), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tdelete: ", p), err)
	}
	return err
}

func (p *THBaseServiceDeleteSingleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteSingleArgs(%+v)", *p)
}

// Attributes:
//   - Io
type THBaseServiceDeleteSingleResult struct {
	Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceDeleteSingleResult() *THBaseServiceDeleteSingleResult {
	return &THBaseServiceDeleteSingleResult{}
}

var THBaseServiceDeleteSingleResult_Io_DEFAULT *TIOError

func (p *THBaseServiceDeleteSingleResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceDeleteSingleResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceDeleteSingleResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceDeleteSingleResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceDeleteSingleResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceDeleteSingleResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "deleteSingle_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteSingleResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceDeleteSingleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteSingleResult(%+v)", *p)
}

// Attributes:
//   - Table: the table to delete from
//   - Tdeletes: list of TDeletes to delete
type THBaseServiceDeleteMultipleArgs struct {
	Table    []byte     `thrift:"table,1,required" db:"table" json:"table"`
	Tdeletes []*TDelete `thrift:"tdeletes,2,required" db:"tdeletes" json:"tdeletes"`
}

func NewTHBaseServiceDeleteMultipleArgs() *THBaseServiceDeleteMultipleArgs {
	return &THBaseServiceDeleteMultipleArgs{}
}

func (p *THBaseServiceDeleteMultipleArgs) GetTable() []byte {
	return p.Table
}

func (p *THBaseServiceDeleteMultipleArgs) GetTdeletes() []*TDelete {
	return p.Tdeletes
}
func (p *THBaseServiceDeleteMultipleArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTdeletes bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTable = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetTdeletes = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTdeletes {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tdeletes is not set"))
	}
	return nil
}

func (p *THBaseServiceDeleteMultipleArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceDeleteMultipleArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TDelete, 0, size)
	p.Tdeletes = tSlice
	for i := 0; i < size; i++ {
		_elem291 := &TDelete{
			DeleteType: 1,
		}
		if err := _elem291.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem291), err)
		}
		p.Tdeletes = append(p.Tdeletes, _elem291)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteMultipleArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "deleteMultiple_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteMultipleArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceDeleteMultipleArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tdeletes", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tdeletes: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Tdeletes)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Tdeletes {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tdeletes: ", p), err)
	}
	return err
}

func (p *THBaseServiceDeleteMultipleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteMultipleArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceDeleteMultipleResult struct {
	Success []*TDelete `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError  `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceDeleteMultipleResult() *THBaseServiceDeleteMultipleResult {
	return &THBaseServiceDeleteMultipleResult{}
}

var THBaseServiceDeleteMultipleResult_Success_DEFAULT []*TDelete

func (p *THBaseServiceDeleteMultipleResult) GetSuccess() []*TDelete {
	return p.Success
}

var THBaseServiceDeleteMultipleResult_Io_DEFAULT *TIOError

func (p *THBaseServiceDeleteMultipleResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceDeleteMultipleResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceDeleteMultipleResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceDeleteMultipleResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceDeleteMultipleResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceDeleteMultipleResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TDelete, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem292 := &TDelete{
			DeleteType: 1,
		}
		if err := _elem292.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem292), err)
		}
		p.Success = append(p.Success, _elem292)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteMultipleResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceDeleteMultipleResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "deleteMultiple_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteMultipleResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceDeleteMultipleResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceDeleteMultipleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteMultipleResult(%+v)", *p)
}

// Attributes:
//   - Table: to check in and delete from
//   - Row: row to check
//   - Family: column family to check
//   - Qualifier: column qualifier to check
//   - Value: the expected value, if not provided the
//
// check is for the non-existence of the
// column in question
//   - Tdelete: the TDelete to execute if the check succeeds
type THBaseServiceCheckAndDeleteArgs struct {
	Table     []byte   `thrift:"table,1,required" db:"table" json:"table"`
	Row       []byte   `thrift:"row,2,required" db:"row" json:"row"`
	Family    []byte   `thrift:"family,3,required" db:"family" json:"family"`
	Qualifier []byte   `thrift:"qualifier,4,required" db:"qualifier" json:"qualifier"`
	Value     []byte   `thrift:"value,5" db:"value" json:"value"`
	Tdelete   *TDelete `thrift:"tdelete,6,required" db:"tdelete" json:"tdelete"`
}

func NewTHBaseServiceCheckAndDeleteArgs() *THBaseServiceCheckAndDeleteArgs {
	return &THBaseServiceCheckAndDeleteArgs{}
}

func (p *THBaseServiceCheckAndDeleteArgs) GetTable() []byte {
	return p.Table
}

func (p *THBaseServiceCheckAndDeleteArgs) GetRow() []byte {
	return p.Row
}

func (p *THBaseServiceCheckAndDeleteArgs) GetFamily() []byte {
	return p.Family
}

func (p *THBaseServiceCheckAndDeleteArgs) GetQualifier() []byte {
	return p.Qualifier
}

func (p *THBaseServiceCheckAndDeleteArgs) GetValue() []byte {
	return p.Value
}

var THBaseServiceCheckAndDeleteArgs_Tdelete_DEFAULT *TDelete

func (p *THBaseServiceCheckAndDeleteArgs) GetTdelete() *TDelete {
	if !p.IsSetTdelete() {
		return THBaseServiceCheckAndDeleteArgs_Tdelete_DEFAULT
	}
	return p.Tdelete
}
func (p *THBaseServiceCheckAndDeleteArgs) IsSetTdelete() bool {
	return p.Tdelete != nil
}

func (p *THBaseServiceCheckAndDeleteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetRow bool = false
	var issetFamily bool = false
	var issetQualifier bool = false
	var issetTdelete bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTable = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetRow = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetFamily = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
				issetQualifier = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
				issetTdelete = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetRow {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"))
	}
	if !issetFamily {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Family is not set"))
	}
	if !issetQualifier {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Qualifier is not set"))
	}
	if !issetTdelete {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tdelete is not set"))
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteArgs) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Family = v
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteArgs) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.Qualifier = v
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteArgs) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteArgs) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	p.Tdelete = &TDelete{
		DeleteType: 1,
	}
	if err := p.Tdelete.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tdelete), err)
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "checkAndDelete_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField4(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField5(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField6(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndDeleteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:row: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Row); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.row (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:row: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndDeleteArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "family", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:family: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Family); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.family (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:family: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndDeleteArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "qualifier", thrift.STRING, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:qualifier: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Qualifier); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.qualifier (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:qualifier: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndDeleteArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:value: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Value); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.value (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:value: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndDeleteArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tdelete", thrift.STRUCT, 6); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:tdelete: ", p), err)
	}
	if err := p.Tdelete.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tdelete), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 6:tdelete: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndDeleteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCheckAndDeleteArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceCheckAndDeleteResult struct {
	Success *bool     `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceCheckAndDeleteResult() *THBaseServiceCheckAndDeleteResult {
	return &THBaseServiceCheckAndDeleteResult{}
}

var THBaseServiceCheckAndDeleteResult_Success_DEFAULT bool

func (p *THBaseServiceCheckAndDeleteResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return THBaseServiceCheckAndDeleteResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceCheckAndDeleteResult_Io_DEFAULT *TIOError

func (p *THBaseServiceCheckAndDeleteResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceCheckAndDeleteResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceCheckAndDeleteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceCheckAndDeleteResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceCheckAndDeleteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "checkAndDelete_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCheckAndDeleteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCheckAndDeleteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCheckAndDeleteResult(%+v)", *p)
}

// Attributes:
//   - Table: the table to increment the value on
//   - Tincrement: the TIncrement to increment
type THBaseServiceIncrementArgs struct {
	Table      []byte      `thrift:"table,1,required" db:"table" json:"table"`
	Tincrement *TIncrement `thrift:"tincrement,2,required" db:"tincrement" json:"tincrement"`
}

func NewTHBaseServiceIncrementArgs() *THBaseServiceIncrementArgs {
	return &THBaseServiceIncrementArgs{}
}

func (p *THBaseServiceIncrementArgs) GetTable() []byte {
	return p.Table
}

var THBaseServiceIncrementArgs_Tincrement_DEFAULT *TIncrement

func (p *THBaseServiceIncrementArgs) GetTincrement() *TIncrement {
	if !p.IsSetTincrement() {
		return THBaseServiceIncrementArgs_Tincrement_DEFAULT
	}
	return p.Tincrement
}
func (p *THBaseServiceIncrementArgs) IsSetTincrement() bool {
	return p.Tincrement != nil
}

func (p *THBaseServiceIncrementArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTincrement bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTable = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetTincrement = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTincrement {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tincrement is not set"))
	}
	return nil
}

func (p *THBaseServiceIncrementArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceIncrementArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Tincrement = &TIncrement{}
	if err := p.Tincrement.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tincrement), err)
	}
	return nil
}

func (p *THBaseServiceIncrementArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "increment_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIncrementArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceIncrementArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tincrement", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tincrement: ", p), err)
	}
	if err := p.Tincrement.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tincrement), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tincrement: ", p), err)
	}
	return err
}

func (p *THBaseServiceIncrementArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIncrementArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceIncrementResult struct {
	Success *TResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceIncrementResult() *THBaseServiceIncrementResult {
	return &THBaseServiceIncrementResult{}
}

var THBaseServiceIncrementResult_Success_DEFAULT *TResult_

func (p *THBaseServiceIncrementResult) GetSuccess() *TResult_ {
	if !p.IsSetSuccess() {
		return THBaseServiceIncrementResult_Success_DEFAULT
	}
	return p.Success
}

var THBaseServiceIncrementResult_Io_DEFAULT *TIOError

func (p *THBaseServiceIncrementResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceIncrementResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceIncrementResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceIncrementResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceIncrementResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceIncrementResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &TResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *THBaseServiceIncrementResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceIncrementResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "increment_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIncrementResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIncrementResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIncrementResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIncrementResult(%+v)", *p)
}

// Attributes:
//   - Table: the table to append the value on
//   - Tappend: the TAppend to append
type THBaseServiceAppendArgs struct {
	Table   []byte   `thrift:"table,1,required" db:"table" json:"table"`
	Tappend *TAppend `thrift:"tappend,2,required" db:"tappend" json:"tappend"`
}

func NewTHBaseServiceAppendArgs() *THBaseServiceAppendArgs {
	return &THBaseServiceAppendArgs{}
}

func (p *THBaseServiceAppendArgs) GetTable() []byte {
	return p.Table
}

var THBaseServiceAppendArgs_Tappend_DEFAULT *TAppend

func (p *THBaseServiceAppendArgs) GetTappend() *TAppend {
	if !p.IsSetTappend() {
		return THBaseServiceAppendArgs_Tappend_DEFAULT
	}
	return p.Tappend
}
func (p *THBaseServiceAppendArgs) IsSetTappend() bool {
	return p.Tappend != nil
}

func (p *THBaseServiceAppendArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTappend bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTable = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetTappend = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTappend {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tappend is not set"))
	}
	return nil
}

func (p *THBaseServiceAppendArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceAppendArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Tappend = &TAppend{}
	if err := p.Tappend.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tappend), err)
	}
	return nil
}

func (p *THBaseServiceAppendArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "append_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceAppendArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceAppendArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tappend", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tappend: ", p), err)
	}
	if err := p.Tappend.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tappend), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tappend: ", p), err)
	}
	return err
}

func (p *THBaseServiceAppendArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceAppendArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceAppendResult struct {
	Success *TResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceAppendResult() *THBaseServiceAppendResult {
	return &THBaseServiceAppendResult{}
}

var THBaseServiceAppendResult_Success_DEFAULT *TResult_

func (p *THBaseServiceAppendResult) GetSuccess() *TResult_ {
	if !p.IsSetSuccess() {
		return THBaseServiceAppendResult_Success_DEFAULT
	}
	return p.Success
}

var THBaseServiceAppendResult_Io_DEFAULT *TIOError

func (p *THBaseServiceAppendResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceAppendResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceAppendResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceAppendResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceAppendResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceAppendResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &TResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *THBaseServiceAppendResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceAppendResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "append_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceAppendResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceAppendResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceAppendResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceAppendResult(%+v)", *p)
}

// Attributes:
//   - Table: the table to get the Scanner for
//   - Tscan: the scan object to get a Scanner for
type THBaseServiceOpenScannerArgs struct {
	Table []byte `thrift:"table,1,required" db:"table" json:"table"`
	Tscan *TScan `thrift:"tscan,2,required" db:"tscan" json:"tscan"`
}

func NewTHBaseServiceOpenScannerArgs() *THBaseServiceOpenScannerArgs {
	return &THBaseServiceOpenScannerArgs{}
}

func (p *THBaseServiceOpenScannerArgs) GetTable() []byte {
	return p.Table
}

var THBaseServiceOpenScannerArgs_Tscan_DEFAULT *TScan

func (p *THBaseServiceOpenScannerArgs) GetTscan() *TScan {
	if !p.IsSetTscan() {
		return THBaseServiceOpenScannerArgs_Tscan_DEFAULT
	}
	return p.Tscan
}
func (p *THBaseServiceOpenScannerArgs) IsSetTscan() bool {
	return p.Tscan != nil
}

func (p *THBaseServiceOpenScannerArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTscan bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTable = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetTscan = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTscan {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tscan is not set"))
	}
	return nil
}

func (p *THBaseServiceOpenScannerArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceOpenScannerArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Tscan = &TScan{
		MaxVersions: 1,
	}
	if err := p.Tscan.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tscan), err)
	}
	return nil
}

func (p *THBaseServiceOpenScannerArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "openScanner_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceOpenScannerArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceOpenScannerArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tscan", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tscan: ", p), err)
	}
	if err := p.Tscan.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tscan), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tscan: ", p), err)
	}
	return err
}

func (p *THBaseServiceOpenScannerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceOpenScannerArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceOpenScannerResult struct {
	Success *int32    `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceOpenScannerResult() *THBaseServiceOpenScannerResult {
	return &THBaseServiceOpenScannerResult{}
}

var THBaseServiceOpenScannerResult_Success_DEFAULT int32

func (p *THBaseServiceOpenScannerResult) GetSuccess() int32 {
	if !p.IsSetSuccess() {
		return THBaseServiceOpenScannerResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceOpenScannerResult_Io_DEFAULT *TIOError

func (p *THBaseServiceOpenScannerResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceOpenScannerResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceOpenScannerResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceOpenScannerResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceOpenScannerResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceOpenScannerResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceOpenScannerResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceOpenScannerResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "openScanner_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceOpenScannerResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceOpenScannerResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceOpenScannerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceOpenScannerResult(%+v)", *p)
}

// Attributes:
//   - ScannerId: the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
//   - NumRows: number of rows to return
type THBaseServiceGetScannerRowsArgs struct {
	ScannerId int32 `thrift:"scannerId,1,required" db:"scannerId" json:"scannerId"`
	NumRows   int32 `thrift:"numRows,2" db:"numRows" json:"numRows"`
}

func NewTHBaseServiceGetScannerRowsArgs() *THBaseServiceGetScannerRowsArgs {
	return &THBaseServiceGetScannerRowsArgs{
		NumRows: 1,
	}
}

func (p *THBaseServiceGetScannerRowsArgs) GetScannerId() int32 {
	return p.ScannerId
}

func (p *THBaseServiceGetScannerRowsArgs) GetNumRows() int32 {
	return p.NumRows
}
func (p *THBaseServiceGetScannerRowsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetScannerId bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetScannerId = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetScannerId {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ScannerId is not set"))
	}
	return nil
}

func (p *THBaseServiceGetScannerRowsArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ScannerId = v
	}
	return nil
}

func (p *THBaseServiceGetScannerRowsArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.NumRows = v
	}
	return nil
}

func (p *THBaseServiceGetScannerRowsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getScannerRows_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetScannerRowsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "scannerId", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scannerId: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.ScannerId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.scannerId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scannerId: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetScannerRowsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "numRows", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:numRows: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.NumRows)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.numRows (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:numRows: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetScannerRowsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetScannerRowsArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
//   - Ia: if the scannerId is invalid
type THBaseServiceGetScannerRowsResult struct {
	Success []*TResult_       `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError         `thrift:"io,1" db:"io" json:"io,omitempty"`
	Ia      *TIllegalArgument `thrift:"ia,2" db:"ia" json:"ia,omitempty"`
}

func NewTHBaseServiceGetScannerRowsResult() *THBaseServiceGetScannerRowsResult {
	return &THBaseServiceGetScannerRowsResult{}
}

var THBaseServiceGetScannerRowsResult_Success_DEFAULT []*TResult_

func (p *THBaseServiceGetScannerRowsResult) GetSuccess() []*TResult_ {
	return p.Success
}

var THBaseServiceGetScannerRowsResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetScannerRowsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetScannerRowsResult_Io_DEFAULT
	}
	return p.Io
}

var THBaseServiceGetScannerRowsResult_Ia_DEFAULT *TIllegalArgument

func (p *THBaseServiceGetScannerRowsResult) GetIa() *TIllegalArgument {
	if !p.IsSetIa() {
		return THBaseServiceGetScannerRowsResult_Ia_DEFAULT
	}
	return p.Ia
}
func (p *THBaseServiceGetScannerRowsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetScannerRowsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetScannerRowsResult) IsSetIa() bool {
	return p.Ia != nil
}

func (p *THBaseServiceGetScannerRowsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetScannerRowsResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem293 := &TResult_{}
		if err := _elem293.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem293), err)
		}
		p.Success = append(p.Success, _elem293)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetScannerRowsResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetScannerRowsResult) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Ia = &TIllegalArgument{}
	if err := p.Ia.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ia), err)
	}
	return nil
}

func (p *THBaseServiceGetScannerRowsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getScannerRows_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetScannerRowsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetScannerRowsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetScannerRowsResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIa() {
		if err := oprot.WriteFieldBegin(ctx, "ia", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ia: ", p), err)
		}
		if err := p.Ia.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ia), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ia: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetScannerRowsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetScannerRowsResult(%+v)", *p)
}

// Attributes:
//   - ScannerId: the Id of the Scanner to close *
type THBaseServiceCloseScannerArgs struct {
	ScannerId int32 `thrift:"scannerId,1,required" db:"scannerId" json:"scannerId"`
}

func NewTHBaseServiceCloseScannerArgs() *THBaseServiceCloseScannerArgs {
	return &THBaseServiceCloseScannerArgs{}
}

func (p *THBaseServiceCloseScannerArgs) GetScannerId() int32 {
	return p.ScannerId
}
func (p *THBaseServiceCloseScannerArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetScannerId bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetScannerId = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetScannerId {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ScannerId is not set"))
	}
	return nil
}

func (p *THBaseServiceCloseScannerArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ScannerId = v
	}
	return nil
}

func (p *THBaseServiceCloseScannerArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "closeScanner_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCloseScannerArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "scannerId", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scannerId: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.ScannerId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.scannerId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scannerId: ", p), err)
	}
	return err
}

func (p *THBaseServiceCloseScannerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCloseScannerArgs(%+v)", *p)
}

// Attributes:
//   - Io
//   - Ia: if the scannerId is invalid
type THBaseServiceCloseScannerResult struct {
	Io *TIOError         `thrift:"io,1" db:"io" json:"io,omitempty"`
	Ia *TIllegalArgument `thrift:"ia,2" db:"ia" json:"ia,omitempty"`
}

func NewTHBaseServiceCloseScannerResult() *THBaseServiceCloseScannerResult {
	return &THBaseServiceCloseScannerResult{}
}

var THBaseServiceCloseScannerResult_Io_DEFAULT *TIOError

func (p *THBaseServiceCloseScannerResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceCloseScannerResult_Io_DEFAULT
	}
	return p.Io
}

var THBaseServiceCloseScannerResult_Ia_DEFAULT *TIllegalArgument

func (p *THBaseServiceCloseScannerResult) GetIa() *TIllegalArgument {
	if !p.IsSetIa() {
		return THBaseServiceCloseScannerResult_Ia_DEFAULT
	}
	return p.Ia
}
func (p *THBaseServiceCloseScannerResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceCloseScannerResult) IsSetIa() bool {
	return p.Ia != nil
}

func (p *THBaseServiceCloseScannerResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceCloseScannerResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceCloseScannerResult) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Ia = &TIllegalArgument{}
	if err := p.Ia.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ia), err)
	}
	return nil
}

func (p *THBaseServiceCloseScannerResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "closeScanner_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCloseScannerResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCloseScannerResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIa() {
		if err := oprot.WriteFieldBegin(ctx, "ia", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ia: ", p), err)
		}
		if err := p.Ia.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ia), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ia: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCloseScannerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCloseScannerResult(%+v)", *p)
}

// Attributes:
//   - Table: table to apply the mutations
//   - TrowMutations: mutations to apply
type THBaseServiceMutateRowArgs struct {
	Table         []byte         `thrift:"table,1,required" db:"table" json:"table"`
	TrowMutations *TRowMutations `thrift:"trowMutations,2,required" db:"trowMutations" json:"trowMutations"`
}

func NewTHBaseServiceMutateRowArgs() *THBaseServiceMutateRowArgs {
	return &THBaseServiceMutateRowArgs{}
}

func (p *THBaseServiceMutateRowArgs) GetTable() []byte {
	return p.Table
}

var THBaseServiceMutateRowArgs_TrowMutations_DEFAULT *TRowMutations

func (p *THBaseServiceMutateRowArgs) GetTrowMutations() *TRowMutations {
	if !p.IsSetTrowMutations() {
		return THBaseServiceMutateRowArgs_TrowMutations_DEFAULT
	}
	return p.TrowMutations
}
func (p *THBaseServiceMutateRowArgs) IsSetTrowMutations() bool {
	return p.TrowMutations != nil
}

func (p *THBaseServiceMutateRowArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTrowMutations bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTable = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetTrowMutations = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTrowMutations {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TrowMutations is not set"))
	}
	return nil
}

func (p *THBaseServiceMutateRowArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceMutateRowArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.TrowMutations = &TRowMutations{}
	if err := p.TrowMutations.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TrowMutations), err)
	}
	return nil
}

func (p *THBaseServiceMutateRowArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "mutateRow_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceMutateRowArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceMutateRowArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "trowMutations", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:trowMutations: ", p), err)
	}
	if err := p.TrowMutations.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TrowMutations), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:trowMutations: ", p), err)
	}
	return err
}

func (p *THBaseServiceMutateRowArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceMutateRowArgs(%+v)", *p)
}

// Attributes:
//   - Io
type THBaseServiceMutateRowResult struct {
	Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceMutateRowResult() *THBaseServiceMutateRowResult {
	return &THBaseServiceMutateRowResult{}
}

var THBaseServiceMutateRowResult_Io_DEFAULT *TIOError

func (p *THBaseServiceMutateRowResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceMutateRowResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceMutateRowResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceMutateRowResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceMutateRowResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceMutateRowResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "mutateRow_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceMutateRowResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceMutateRowResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceMutateRowResult(%+v)", *p)
}

// Attributes:
//   - Table: the table to get the Scanner for
//   - Tscan: the scan object to get a Scanner for
//   - NumRows: number of rows to return
type THBaseServiceGetScannerResultsArgs struct {
	Table   []byte `thrift:"table,1,required" db:"table" json:"table"`
	Tscan   *TScan `thrift:"tscan,2,required" db:"tscan" json:"tscan"`
	NumRows int32  `thrift:"numRows,3" db:"numRows" json:"numRows"`
}

func NewTHBaseServiceGetScannerResultsArgs() *THBaseServiceGetScannerResultsArgs {
	return &THBaseServiceGetScannerResultsArgs{
		NumRows: 1,
	}
}

func (p *THBaseServiceGetScannerResultsArgs) GetTable() []byte {
	return p.Table
}

var THBaseServiceGetScannerResultsArgs_Tscan_DEFAULT *TScan

func (p *THBaseServiceGetScannerResultsArgs) GetTscan() *TScan {
	if !p.IsSetTscan() {
		return THBaseServiceGetScannerResultsArgs_Tscan_DEFAULT
	}
	return p.Tscan
}

func (p *THBaseServiceGetScannerResultsArgs) GetNumRows() int32 {
	return p.NumRows
}
func (p *THBaseServiceGetScannerResultsArgs) IsSetTscan() bool {
	return p.Tscan != nil
}

func (p *THBaseServiceGetScannerResultsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTscan bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTable = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetTscan = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTscan {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tscan is not set"))
	}
	return nil
}

func (p *THBaseServiceGetScannerResultsArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceGetScannerResultsArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Tscan = &TScan{
		MaxVersions: 1,
	}
	if err := p.Tscan.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tscan), err)
	}
	return nil
}

func (p *THBaseServiceGetScannerResultsArgs) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.NumRows = v
	}
	return nil
}

func (p *THBaseServiceGetScannerResultsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getScannerResults_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetScannerResultsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetScannerResultsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tscan", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tscan: ", p), err)
	}
	if err := p.Tscan.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tscan), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tscan: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetScannerResultsArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "numRows", thrift.I32, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:numRows: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.NumRows)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.numRows (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:numRows: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetScannerResultsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetScannerResultsArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceGetScannerResultsResult struct {
	Success []*TResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError   `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetScannerResultsResult() *THBaseServiceGetScannerResultsResult {
	return &THBaseServiceGetScannerResultsResult{}
}

var THBaseServiceGetScannerResultsResult_Success_DEFAULT []*TResult_

func (p *THBaseServiceGetScannerResultsResult) GetSuccess() []*TResult_ {
	return p.Success
}

var THBaseServiceGetScannerResultsResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetScannerResultsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetScannerResultsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetScannerResultsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetScannerResultsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetScannerResultsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetScannerResultsResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem294 := &TResult_{}
		if err := _elem294.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem294), err)
		}
		p.Success = append(p.Success, _elem294)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetScannerResultsResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetScannerResultsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getScannerResults_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetScannerResultsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetScannerResultsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetScannerResultsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetScannerResultsResult(%+v)", *p)
}

// Attributes:
//   - Table
//   - Row
//   - Reload
type THBaseServiceGetRegionLocationArgs struct {
	Table  []byte `thrift:"table,1,required" db:"table" json:"table"`
	Row    []byte `thrift:"row,2,required" db:"row" json:"row"`
	Reload bool   `thrift:"reload,3" db:"reload" json:"reload"`
}

func NewTHBaseServiceGetRegionLocationArgs() *THBaseServiceGetRegionLocationArgs {
	return &THBaseServiceGetRegionLocationArgs{}
}

func (p *THBaseServiceGetRegionLocationArgs) GetTable() []byte {
	return p.Table
}

func (p *THBaseServiceGetRegionLocationArgs) GetRow() []byte {
	return p.Row
}

func (p *THBaseServiceGetRegionLocationArgs) GetReload() bool {
	return p.Reload
}
func (p *THBaseServiceGetRegionLocationArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetRow bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTable = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetRow = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetRow {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"))
	}
	return nil
}

func (p *THBaseServiceGetRegionLocationArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceGetRegionLocationArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *THBaseServiceGetRegionLocationArgs) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Reload = v
	}
	return nil
}

func (p *THBaseServiceGetRegionLocationArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getRegionLocation_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetRegionLocationArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetRegionLocationArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:row: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Row); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.row (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:row: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetRegionLocationArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "reload", thrift.BOOL, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:reload: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.Reload)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.reload (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:reload: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetRegionLocationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetRegionLocationArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceGetRegionLocationResult struct {
	Success *THRegionLocation `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError         `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetRegionLocationResult() *THBaseServiceGetRegionLocationResult {
	return &THBaseServiceGetRegionLocationResult{}
}

var THBaseServiceGetRegionLocationResult_Success_DEFAULT *THRegionLocation

func (p *THBaseServiceGetRegionLocationResult) GetSuccess() *THRegionLocation {
	if !p.IsSetSuccess() {
		return THBaseServiceGetRegionLocationResult_Success_DEFAULT
	}
	return p.Success
}

var THBaseServiceGetRegionLocationResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetRegionLocationResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetRegionLocationResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetRegionLocationResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetRegionLocationResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetRegionLocationResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetRegionLocationResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &THRegionLocation{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *THBaseServiceGetRegionLocationResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetRegionLocationResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getRegionLocation_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetRegionLocationResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetRegionLocationResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetRegionLocationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetRegionLocationResult(%+v)", *p)
}

// Attributes:
//   - Table
type THBaseServiceGetAllRegionLocationsArgs struct {
	Table []byte `thrift:"table,1,required" db:"table" json:"table"`
}

func NewTHBaseServiceGetAllRegionLocationsArgs() *THBaseServiceGetAllRegionLocationsArgs {
	return &THBaseServiceGetAllRegionLocationsArgs{}
}

func (p *THBaseServiceGetAllRegionLocationsArgs) GetTable() []byte {
	return p.Table
}
func (p *THBaseServiceGetAllRegionLocationsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTable = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	return nil
}

func (p *THBaseServiceGetAllRegionLocationsArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceGetAllRegionLocationsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getAllRegionLocations_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetAllRegionLocationsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetAllRegionLocationsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetAllRegionLocationsArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceGetAllRegionLocationsResult struct {
	Success []*THRegionLocation `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError           `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetAllRegionLocationsResult() *THBaseServiceGetAllRegionLocationsResult {
	return &THBaseServiceGetAllRegionLocationsResult{}
}

var THBaseServiceGetAllRegionLocationsResult_Success_DEFAULT []*THRegionLocation

func (p *THBaseServiceGetAllRegionLocationsResult) GetSuccess() []*THRegionLocation {
	return p.Success
}

var THBaseServiceGetAllRegionLocationsResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetAllRegionLocationsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetAllRegionLocationsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetAllRegionLocationsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetAllRegionLocationsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetAllRegionLocationsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetAllRegionLocationsResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*THRegionLocation, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem295 := &THRegionLocation{}
		if err := _elem295.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem295), err)
		}
		p.Success = append(p.Success, _elem295)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetAllRegionLocationsResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetAllRegionLocationsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getAllRegionLocations_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetAllRegionLocationsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetAllRegionLocationsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetAllRegionLocationsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetAllRegionLocationsResult(%+v)", *p)
}

// Attributes:
//   - Table: to check in and delete from
//   - Row: row to check
//   - Family: column family to check
//   - Qualifier: column qualifier to check
//   - CompareOp: comparison to make on the value
//   - Value: the expected value to be compared against, if not provided the
//
// check is for the non-existence of the column in question
//   - RowMutations: row mutations to execute if the value matches
type THBaseServiceCheckAndMutateArgs struct {
	Table        []byte         `thrift:"table,1,required" db:"table" json:"table"`
	Row          []byte         `thrift:"row,2,required" db:"row" json:"row"`
	Family       []byte         `thrift:"family,3,required" db:"family" json:"family"`
	Qualifier    []byte         `thrift:"qualifier,4,required" db:"qualifier" json:"qualifier"`
	CompareOp    TCompareOp     `thrift:"compareOp,5,required" db:"compareOp" json:"compareOp"`
	Value        []byte         `thrift:"value,6" db:"value" json:"value"`
	RowMutations *TRowMutations `thrift:"rowMutations,7,required" db:"rowMutations" json:"rowMutations"`
}

func NewTHBaseServiceCheckAndMutateArgs() *THBaseServiceCheckAndMutateArgs {
	return &THBaseServiceCheckAndMutateArgs{}
}

func (p *THBaseServiceCheckAndMutateArgs) GetTable() []byte {
	return p.Table
}

func (p *THBaseServiceCheckAndMutateArgs) GetRow() []byte {
	return p.Row
}

func (p *THBaseServiceCheckAndMutateArgs) GetFamily() []byte {
	return p.Family
}

func (p *THBaseServiceCheckAndMutateArgs) GetQualifier() []byte {
	return p.Qualifier
}

func (p *THBaseServiceCheckAndMutateArgs) GetCompareOp() TCompareOp {
	return p.CompareOp
}

func (p *THBaseServiceCheckAndMutateArgs) GetValue() []byte {
	return p.Value
}

var THBaseServiceCheckAndMutateArgs_RowMutations_DEFAULT *TRowMutations

func (p *THBaseServiceCheckAndMutateArgs) GetRowMutations() *TRowMutations {
	if !p.IsSetRowMutations() {
		return THBaseServiceCheckAndMutateArgs_RowMutations_DEFAULT
	}
	return p.RowMutations
}
func (p *THBaseServiceCheckAndMutateArgs) IsSetRowMutations() bool {
	return p.RowMutations != nil
}

func (p *THBaseServiceCheckAndMutateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetRow bool = false
	var issetFamily bool = false
	var issetQualifier bool = false
	var issetCompareOp bool = false
	var issetRowMutations bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTable = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetRow = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetFamily = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
				issetQualifier = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
				issetCompareOp = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
				issetRowMutations = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetRow {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"))
	}
	if !issetFamily {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Family is not set"))
	}
	if !issetQualifier {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Qualifier is not set"))
	}
	if !issetCompareOp {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CompareOp is not set"))
	}
	if !issetRowMutations {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RowMutations is not set"))
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateArgs) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Family = v
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateArgs) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.Qualifier = v
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateArgs) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		temp := TCompareOp(v)
		p.CompareOp = temp
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateArgs) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateArgs) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	p.RowMutations = &TRowMutations{}
	if err := p.RowMutations.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.RowMutations), err)
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "checkAndMutate_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField4(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField5(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField6(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField7(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndMutateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:row: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Row); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.row (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:row: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndMutateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "family", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:family: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Family); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.family (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:family: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndMutateArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "qualifier", thrift.STRING, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:qualifier: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Qualifier); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.qualifier (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:qualifier: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndMutateArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "compareOp", thrift.I32, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:compareOp: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.CompareOp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.compareOp (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:compareOp: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndMutateArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 6); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:value: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Value); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.value (6) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 6:value: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndMutateArgs) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rowMutations", thrift.STRUCT, 7); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:rowMutations: ", p), err)
	}
	if err := p.RowMutations.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.RowMutations), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 7:rowMutations: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndMutateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCheckAndMutateArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceCheckAndMutateResult struct {
	Success *bool     `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceCheckAndMutateResult() *THBaseServiceCheckAndMutateResult {
	return &THBaseServiceCheckAndMutateResult{}
}

var THBaseServiceCheckAndMutateResult_Success_DEFAULT bool

func (p *THBaseServiceCheckAndMutateResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return THBaseServiceCheckAndMutateResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceCheckAndMutateResult_Io_DEFAULT *TIOError

func (p *THBaseServiceCheckAndMutateResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceCheckAndMutateResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceCheckAndMutateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceCheckAndMutateResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceCheckAndMutateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "checkAndMutate_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCheckAndMutateResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCheckAndMutateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCheckAndMutateResult(%+v)", *p)
}

// Attributes:
//   - Table: the tablename of the table to get tableDescriptor
type THBaseServiceGetTableDescriptorArgs struct {
	Table *TTableName `thrift:"table,1,required" db:"table" json:"table"`
}

func NewTHBaseServiceGetTableDescriptorArgs() *THBaseServiceGetTableDescriptorArgs {
	return &THBaseServiceGetTableDescriptorArgs{}
}

var THBaseServiceGetTableDescriptorArgs_Table_DEFAULT *TTableName

func (p *THBaseServiceGetTableDescriptorArgs) GetTable() *TTableName {
	if !p.IsSetTable() {
		return THBaseServiceGetTableDescriptorArgs_Table_DEFAULT
	}
	return p.Table
}
func (p *THBaseServiceGetTableDescriptorArgs) IsSetTable() bool {
	return p.Table != nil
}

func (p *THBaseServiceGetTableDescriptorArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTable = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Table = &TTableName{}
	if err := p.Table.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getTableDescriptor_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := p.Table.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableDescriptorArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceGetTableDescriptorResult struct {
	Success *TTableDescriptor `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError         `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetTableDescriptorResult() *THBaseServiceGetTableDescriptorResult {
	return &THBaseServiceGetTableDescriptorResult{}
}

var THBaseServiceGetTableDescriptorResult_Success_DEFAULT *TTableDescriptor

func (p *THBaseServiceGetTableDescriptorResult) GetSuccess() *TTableDescriptor {
	if !p.IsSetSuccess() {
		return THBaseServiceGetTableDescriptorResult_Success_DEFAULT
	}
	return p.Success
}

var THBaseServiceGetTableDescriptorResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetTableDescriptorResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetTableDescriptorResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetTableDescriptorResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetTableDescriptorResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetTableDescriptorResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &TTableDescriptor{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getTableDescriptor_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableDescriptorResult(%+v)", *p)
}

// Attributes:
//   - Tables: the tablename list of the tables to get tableDescriptor
type THBaseServiceGetTableDescriptorsArgs struct {
	Tables []*TTableName `thrift:"tables,1,required" db:"tables" json:"tables"`
}

func NewTHBaseServiceGetTableDescriptorsArgs() *THBaseServiceGetTableDescriptorsArgs {
	return &THBaseServiceGetTableDescriptorsArgs{}
}

func (p *THBaseServiceGetTableDescriptorsArgs) GetTables() []*TTableName {
	return p.Tables
}
func (p *THBaseServiceGetTableDescriptorsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTables bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTables = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTables {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tables is not set"))
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TTableName, 0, size)
	p.Tables = tSlice
	for i := 0; i < size; i++ {
		_elem296 := &TTableName{}
		if err := _elem296.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem296), err)
		}
		p.Tables = append(p.Tables, _elem296)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getTableDescriptors_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tables", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tables: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Tables)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Tables {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tables: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableDescriptorsArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceGetTableDescriptorsResult struct {
	Success []*TTableDescriptor `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError           `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetTableDescriptorsResult() *THBaseServiceGetTableDescriptorsResult {
	return &THBaseServiceGetTableDescriptorsResult{}
}

var THBaseServiceGetTableDescriptorsResult_Success_DEFAULT []*TTableDescriptor

func (p *THBaseServiceGetTableDescriptorsResult) GetSuccess() []*TTableDescriptor {
	return p.Success
}

var THBaseServiceGetTableDescriptorsResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetTableDescriptorsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetTableDescriptorsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetTableDescriptorsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetTableDescriptorsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetTableDescriptorsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TTableDescriptor, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem297 := &TTableDescriptor{}
		if err := _elem297.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem297), err)
		}
		p.Success = append(p.Success, _elem297)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getTableDescriptors_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableDescriptorsResult(%+v)", *p)
}

// Attributes:
//   - TableName: the tablename of the tables to check
type THBaseServiceTableExistsArgs struct {
	TableName *TTableName `thrift:"tableName,1" db:"tableName" json:"tableName"`
}

func NewTHBaseServiceTableExistsArgs() *THBaseServiceTableExistsArgs {
	return &THBaseServiceTableExistsArgs{}
}

var THBaseServiceTableExistsArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceTableExistsArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceTableExistsArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *THBaseServiceTableExistsArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceTableExistsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceTableExistsArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceTableExistsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "tableExists_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceTableExistsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceTableExistsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceTableExistsArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceTableExistsResult struct {
	Success *bool     `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceTableExistsResult() *THBaseServiceTableExistsResult {
	return &THBaseServiceTableExistsResult{}
}

var THBaseServiceTableExistsResult_Success_DEFAULT bool

func (p *THBaseServiceTableExistsResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return THBaseServiceTableExistsResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceTableExistsResult_Io_DEFAULT *TIOError

func (p *THBaseServiceTableExistsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceTableExistsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceTableExistsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceTableExistsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceTableExistsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceTableExistsResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceTableExistsResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceTableExistsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "tableExists_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceTableExistsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceTableExistsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceTableExistsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceTableExistsResult(%+v)", *p)
}

// Attributes:
//   - Regex: The regular expression to match against
//   - IncludeSysTables: set to false if match only against userspace tables
type THBaseServiceGetTableDescriptorsByPatternArgs struct {
	Regex            string `thrift:"regex,1" db:"regex" json:"regex"`
	IncludeSysTables bool   `thrift:"includeSysTables,2,required" db:"includeSysTables" json:"includeSysTables"`
}

func NewTHBaseServiceGetTableDescriptorsByPatternArgs() *THBaseServiceGetTableDescriptorsByPatternArgs {
	return &THBaseServiceGetTableDescriptorsByPatternArgs{}
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) GetRegex() string {
	return p.Regex
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) GetIncludeSysTables() bool {
	return p.IncludeSysTables
}
func (p *THBaseServiceGetTableDescriptorsByPatternArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetIncludeSysTables bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetIncludeSysTables = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetIncludeSysTables {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field IncludeSysTables is not set"))
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Regex = v
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.IncludeSysTables = v
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getTableDescriptorsByPattern_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "regex", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:regex: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Regex)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.regex (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:regex: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "includeSysTables", thrift.BOOL, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:includeSysTables: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.IncludeSysTables)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.includeSysTables (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:includeSysTables: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableDescriptorsByPatternArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceGetTableDescriptorsByPatternResult struct {
	Success []*TTableDescriptor `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError           `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetTableDescriptorsByPatternResult() *THBaseServiceGetTableDescriptorsByPatternResult {
	return &THBaseServiceGetTableDescriptorsByPatternResult{}
}

var THBaseServiceGetTableDescriptorsByPatternResult_Success_DEFAULT []*TTableDescriptor

func (p *THBaseServiceGetTableDescriptorsByPatternResult) GetSuccess() []*TTableDescriptor {
	return p.Success
}

var THBaseServiceGetTableDescriptorsByPatternResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetTableDescriptorsByPatternResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetTableDescriptorsByPatternResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetTableDescriptorsByPatternResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TTableDescriptor, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem298 := &TTableDescriptor{}
		if err := _elem298.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem298), err)
		}
		p.Success = append(p.Success, _elem298)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getTableDescriptorsByPattern_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableDescriptorsByPatternResult(%+v)", *p)
}

// Attributes:
//   - Name: The namesapce's name
type THBaseServiceGetTableDescriptorsByNamespaceArgs struct {
	Name string `thrift:"name,1,required" db:"name" json:"name"`
}

func NewTHBaseServiceGetTableDescriptorsByNamespaceArgs() *THBaseServiceGetTableDescriptorsByNamespaceArgs {
	return &THBaseServiceGetTableDescriptorsByNamespaceArgs{}
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceArgs) GetName() string {
	return p.Name
}
func (p *THBaseServiceGetTableDescriptorsByNamespaceArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getTableDescriptorsByNamespace_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableDescriptorsByNamespaceArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceGetTableDescriptorsByNamespaceResult struct {
	Success []*TTableDescriptor `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError           `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetTableDescriptorsByNamespaceResult() *THBaseServiceGetTableDescriptorsByNamespaceResult {
	return &THBaseServiceGetTableDescriptorsByNamespaceResult{}
}

var THBaseServiceGetTableDescriptorsByNamespaceResult_Success_DEFAULT []*TTableDescriptor

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) GetSuccess() []*TTableDescriptor {
	return p.Success
}

var THBaseServiceGetTableDescriptorsByNamespaceResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetTableDescriptorsByNamespaceResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TTableDescriptor, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem299 := &TTableDescriptor{}
		if err := _elem299.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem299), err)
		}
		p.Success = append(p.Success, _elem299)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getTableDescriptorsByNamespace_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableDescriptorsByNamespaceResult(%+v)", *p)
}

// Attributes:
//   - Regex: The regular expression to match against
//   - IncludeSysTables: set to false if match only against userspace tables
type THBaseServiceGetTableNamesByPatternArgs struct {
	Regex            string `thrift:"regex,1" db:"regex" json:"regex"`
	IncludeSysTables bool   `thrift:"includeSysTables,2,required" db:"includeSysTables" json:"includeSysTables"`
}

func NewTHBaseServiceGetTableNamesByPatternArgs() *THBaseServiceGetTableNamesByPatternArgs {
	return &THBaseServiceGetTableNamesByPatternArgs{}
}

func (p *THBaseServiceGetTableNamesByPatternArgs) GetRegex() string {
	return p.Regex
}

func (p *THBaseServiceGetTableNamesByPatternArgs) GetIncludeSysTables() bool {
	return p.IncludeSysTables
}
func (p *THBaseServiceGetTableNamesByPatternArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetIncludeSysTables bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetIncludeSysTables = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetIncludeSysTables {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field IncludeSysTables is not set"))
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByPatternArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Regex = v
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByPatternArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.IncludeSysTables = v
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByPatternArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getTableNamesByPattern_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByPatternArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "regex", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:regex: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Regex)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.regex (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:regex: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetTableNamesByPatternArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "includeSysTables", thrift.BOOL, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:includeSysTables: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.IncludeSysTables)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.includeSysTables (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:includeSysTables: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetTableNamesByPatternArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableNamesByPatternArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceGetTableNamesByPatternResult struct {
	Success []*TTableName `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError     `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetTableNamesByPatternResult() *THBaseServiceGetTableNamesByPatternResult {
	return &THBaseServiceGetTableNamesByPatternResult{}
}

var THBaseServiceGetTableNamesByPatternResult_Success_DEFAULT []*TTableName

func (p *THBaseServiceGetTableNamesByPatternResult) GetSuccess() []*TTableName {
	return p.Success
}

var THBaseServiceGetTableNamesByPatternResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetTableNamesByPatternResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetTableNamesByPatternResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetTableNamesByPatternResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetTableNamesByPatternResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetTableNamesByPatternResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByPatternResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TTableName, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem300 := &TTableName{}
		if err := _elem300.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem300), err)
		}
		p.Success = append(p.Success, _elem300)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByPatternResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByPatternResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getTableNamesByPattern_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByPatternResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableNamesByPatternResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableNamesByPatternResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableNamesByPatternResult(%+v)", *p)
}

// Attributes:
//   - Name: The namesapce's name
type THBaseServiceGetTableNamesByNamespaceArgs struct {
	Name string `thrift:"name,1,required" db:"name" json:"name"`
}

func NewTHBaseServiceGetTableNamesByNamespaceArgs() *THBaseServiceGetTableNamesByNamespaceArgs {
	return &THBaseServiceGetTableNamesByNamespaceArgs{}
}

func (p *THBaseServiceGetTableNamesByNamespaceArgs) GetName() string {
	return p.Name
}
func (p *THBaseServiceGetTableNamesByNamespaceArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getTableNamesByNamespace_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetTableNamesByNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableNamesByNamespaceArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceGetTableNamesByNamespaceResult struct {
	Success []*TTableName `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError     `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetTableNamesByNamespaceResult() *THBaseServiceGetTableNamesByNamespaceResult {
	return &THBaseServiceGetTableNamesByNamespaceResult{}
}

var THBaseServiceGetTableNamesByNamespaceResult_Success_DEFAULT []*TTableName

func (p *THBaseServiceGetTableNamesByNamespaceResult) GetSuccess() []*TTableName {
	return p.Success
}

var THBaseServiceGetTableNamesByNamespaceResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetTableNamesByNamespaceResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetTableNamesByNamespaceResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetTableNamesByNamespaceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TTableName, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem301 := &TTableName{}
		if err := _elem301.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem301), err)
		}
		p.Success = append(p.Success, _elem301)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getTableNamesByNamespace_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableNamesByNamespaceResult(%+v)", *p)
}

// Attributes:
//   - Desc: table descriptor for table
//   - SplitKeys: rray of split keys for the initial regions of the table
type THBaseServiceCreateTableArgs struct {
	Desc      *TTableDescriptor `thrift:"desc,1,required" db:"desc" json:"desc"`
	SplitKeys [][]byte          `thrift:"splitKeys,2" db:"splitKeys" json:"splitKeys"`
}

func NewTHBaseServiceCreateTableArgs() *THBaseServiceCreateTableArgs {
	return &THBaseServiceCreateTableArgs{}
}

var THBaseServiceCreateTableArgs_Desc_DEFAULT *TTableDescriptor

func (p *THBaseServiceCreateTableArgs) GetDesc() *TTableDescriptor {
	if !p.IsSetDesc() {
		return THBaseServiceCreateTableArgs_Desc_DEFAULT
	}
	return p.Desc
}

func (p *THBaseServiceCreateTableArgs) GetSplitKeys() [][]byte {
	return p.SplitKeys
}
func (p *THBaseServiceCreateTableArgs) IsSetDesc() bool {
	return p.Desc != nil
}

func (p *THBaseServiceCreateTableArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetDesc bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetDesc = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetDesc {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Desc is not set"))
	}
	return nil
}

func (p *THBaseServiceCreateTableArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Desc = &TTableDescriptor{}
	if err := p.Desc.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Desc), err)
	}
	return nil
}

func (p *THBaseServiceCreateTableArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([][]byte, 0, size)
	p.SplitKeys = tSlice
	for i := 0; i < size; i++ {
		var _elem302 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem302 = v
		}
		p.SplitKeys = append(p.SplitKeys, _elem302)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceCreateTableArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createTable_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCreateTableArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "desc", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:desc: ", p), err)
	}
	if err := p.Desc.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Desc), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:desc: ", p), err)
	}
	return err
}

func (p *THBaseServiceCreateTableArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "splitKeys", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:splitKeys: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.SplitKeys)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.SplitKeys {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:splitKeys: ", p), err)
	}
	return err
}

func (p *THBaseServiceCreateTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCreateTableArgs(%+v)", *p)
}

// Attributes:
//   - Io
type THBaseServiceCreateTableResult struct {
	Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceCreateTableResult() *THBaseServiceCreateTableResult {
	return &THBaseServiceCreateTableResult{}
}

var THBaseServiceCreateTableResult_Io_DEFAULT *TIOError

func (p *THBaseServiceCreateTableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceCreateTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceCreateTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceCreateTableResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceCreateTableResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceCreateTableResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createTable_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCreateTableResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCreateTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCreateTableResult(%+v)", *p)
}

// Attributes:
//   - TableName: the tablename to delete
type THBaseServiceDeleteTableArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
}

func NewTHBaseServiceDeleteTableArgs() *THBaseServiceDeleteTableArgs {
	return &THBaseServiceDeleteTableArgs{}
}

var THBaseServiceDeleteTableArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceDeleteTableArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceDeleteTableArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *THBaseServiceDeleteTableArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceDeleteTableArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTableName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	return nil
}

func (p *THBaseServiceDeleteTableArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceDeleteTableArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "deleteTable_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteTableArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceDeleteTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteTableArgs(%+v)", *p)
}

// Attributes:
//   - Io
type THBaseServiceDeleteTableResult struct {
	Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceDeleteTableResult() *THBaseServiceDeleteTableResult {
	return &THBaseServiceDeleteTableResult{}
}

var THBaseServiceDeleteTableResult_Io_DEFAULT *TIOError

func (p *THBaseServiceDeleteTableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceDeleteTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceDeleteTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceDeleteTableResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceDeleteTableResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceDeleteTableResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "deleteTable_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteTableResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceDeleteTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteTableResult(%+v)", *p)
}

// Attributes:
//   - TableName: the tablename to truncate
//   - PreserveSplits: whether to  preserve previous splits
type THBaseServiceTruncateTableArgs struct {
	TableName      *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
	PreserveSplits bool        `thrift:"preserveSplits,2,required" db:"preserveSplits" json:"preserveSplits"`
}

func NewTHBaseServiceTruncateTableArgs() *THBaseServiceTruncateTableArgs {
	return &THBaseServiceTruncateTableArgs{}
}

var THBaseServiceTruncateTableArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceTruncateTableArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceTruncateTableArgs_TableName_DEFAULT
	}
	return p.TableName
}

func (p *THBaseServiceTruncateTableArgs) GetPreserveSplits() bool {
	return p.PreserveSplits
}
func (p *THBaseServiceTruncateTableArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceTruncateTableArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false
	var issetPreserveSplits bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTableName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetPreserveSplits = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	if !issetPreserveSplits {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field PreserveSplits is not set"))
	}
	return nil
}

func (p *THBaseServiceTruncateTableArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceTruncateTableArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.PreserveSplits = v
	}
	return nil
}

func (p *THBaseServiceTruncateTableArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "truncateTable_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceTruncateTableArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceTruncateTableArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "preserveSplits", thrift.BOOL, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:preserveSplits: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.PreserveSplits)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.preserveSplits (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:preserveSplits: ", p), err)
	}
	return err
}

func (p *THBaseServiceTruncateTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceTruncateTableArgs(%+v)", *p)
}

// Attributes:
//   - Io
type THBaseServiceTruncateTableResult struct {
	Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceTruncateTableResult() *THBaseServiceTruncateTableResult {
	return &THBaseServiceTruncateTableResult{}
}

var THBaseServiceTruncateTableResult_Io_DEFAULT *TIOError

func (p *THBaseServiceTruncateTableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceTruncateTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceTruncateTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceTruncateTableResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceTruncateTableResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceTruncateTableResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "truncateTable_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceTruncateTableResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceTruncateTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceTruncateTableResult(%+v)", *p)
}

// Attributes:
//   - TableName: the tablename to enable
type THBaseServiceEnableTableArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
}

func NewTHBaseServiceEnableTableArgs() *THBaseServiceEnableTableArgs {
	return &THBaseServiceEnableTableArgs{}
}

var THBaseServiceEnableTableArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceEnableTableArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceEnableTableArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *THBaseServiceEnableTableArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceEnableTableArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTableName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	return nil
}

func (p *THBaseServiceEnableTableArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceEnableTableArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "enableTable_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceEnableTableArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceEnableTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceEnableTableArgs(%+v)", *p)
}

// Attributes:
//   - Io
type THBaseServiceEnableTableResult struct {
	Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceEnableTableResult() *THBaseServiceEnableTableResult {
	return &THBaseServiceEnableTableResult{}
}

var THBaseServiceEnableTableResult_Io_DEFAULT *TIOError

func (p *THBaseServiceEnableTableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceEnableTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceEnableTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceEnableTableResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceEnableTableResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceEnableTableResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "enableTable_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceEnableTableResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceEnableTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceEnableTableResult(%+v)", *p)
}

// Attributes:
//   - TableName: the tablename to disable
type THBaseServiceDisableTableArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
}

func NewTHBaseServiceDisableTableArgs() *THBaseServiceDisableTableArgs {
	return &THBaseServiceDisableTableArgs{}
}

var THBaseServiceDisableTableArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceDisableTableArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceDisableTableArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *THBaseServiceDisableTableArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceDisableTableArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTableName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	return nil
}

func (p *THBaseServiceDisableTableArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceDisableTableArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "disableTable_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDisableTableArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceDisableTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDisableTableArgs(%+v)", *p)
}

// Attributes:
//   - Io
type THBaseServiceDisableTableResult struct {
	Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceDisableTableResult() *THBaseServiceDisableTableResult {
	return &THBaseServiceDisableTableResult{}
}

var THBaseServiceDisableTableResult_Io_DEFAULT *TIOError

func (p *THBaseServiceDisableTableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceDisableTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceDisableTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceDisableTableResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceDisableTableResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceDisableTableResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "disableTable_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDisableTableResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceDisableTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDisableTableResult(%+v)", *p)
}

// Attributes:
//   - TableName: the tablename to check
type THBaseServiceIsTableEnabledArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
}

func NewTHBaseServiceIsTableEnabledArgs() *THBaseServiceIsTableEnabledArgs {
	return &THBaseServiceIsTableEnabledArgs{}
}

var THBaseServiceIsTableEnabledArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceIsTableEnabledArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceIsTableEnabledArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *THBaseServiceIsTableEnabledArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceIsTableEnabledArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTableName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	return nil
}

func (p *THBaseServiceIsTableEnabledArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceIsTableEnabledArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "isTableEnabled_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIsTableEnabledArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceIsTableEnabledArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIsTableEnabledArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceIsTableEnabledResult struct {
	Success *bool     `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceIsTableEnabledResult() *THBaseServiceIsTableEnabledResult {
	return &THBaseServiceIsTableEnabledResult{}
}

var THBaseServiceIsTableEnabledResult_Success_DEFAULT bool

func (p *THBaseServiceIsTableEnabledResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return THBaseServiceIsTableEnabledResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceIsTableEnabledResult_Io_DEFAULT *TIOError

func (p *THBaseServiceIsTableEnabledResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceIsTableEnabledResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceIsTableEnabledResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceIsTableEnabledResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceIsTableEnabledResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceIsTableEnabledResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceIsTableEnabledResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceIsTableEnabledResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "isTableEnabled_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIsTableEnabledResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIsTableEnabledResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIsTableEnabledResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIsTableEnabledResult(%+v)", *p)
}

// Attributes:
//   - TableName: the tablename to check
type THBaseServiceIsTableDisabledArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
}

func NewTHBaseServiceIsTableDisabledArgs() *THBaseServiceIsTableDisabledArgs {
	return &THBaseServiceIsTableDisabledArgs{}
}

var THBaseServiceIsTableDisabledArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceIsTableDisabledArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceIsTableDisabledArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *THBaseServiceIsTableDisabledArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceIsTableDisabledArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTableName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	return nil
}

func (p *THBaseServiceIsTableDisabledArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceIsTableDisabledArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "isTableDisabled_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIsTableDisabledArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceIsTableDisabledArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIsTableDisabledArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceIsTableDisabledResult struct {
	Success *bool     `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceIsTableDisabledResult() *THBaseServiceIsTableDisabledResult {
	return &THBaseServiceIsTableDisabledResult{}
}

var THBaseServiceIsTableDisabledResult_Success_DEFAULT bool

func (p *THBaseServiceIsTableDisabledResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return THBaseServiceIsTableDisabledResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceIsTableDisabledResult_Io_DEFAULT *TIOError

func (p *THBaseServiceIsTableDisabledResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceIsTableDisabledResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceIsTableDisabledResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceIsTableDisabledResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceIsTableDisabledResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceIsTableDisabledResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceIsTableDisabledResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceIsTableDisabledResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "isTableDisabled_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIsTableDisabledResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIsTableDisabledResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIsTableDisabledResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIsTableDisabledResult(%+v)", *p)
}

// Attributes:
//   - TableName: the tablename to check
type THBaseServiceIsTableAvailableArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
}

func NewTHBaseServiceIsTableAvailableArgs() *THBaseServiceIsTableAvailableArgs {
	return &THBaseServiceIsTableAvailableArgs{}
}

var THBaseServiceIsTableAvailableArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceIsTableAvailableArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceIsTableAvailableArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *THBaseServiceIsTableAvailableArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceIsTableAvailableArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTableName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "isTableAvailable_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceIsTableAvailableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIsTableAvailableArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceIsTableAvailableResult struct {
	Success *bool     `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceIsTableAvailableResult() *THBaseServiceIsTableAvailableResult {
	return &THBaseServiceIsTableAvailableResult{}
}

var THBaseServiceIsTableAvailableResult_Success_DEFAULT bool

func (p *THBaseServiceIsTableAvailableResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return THBaseServiceIsTableAvailableResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceIsTableAvailableResult_Io_DEFAULT *TIOError

func (p *THBaseServiceIsTableAvailableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceIsTableAvailableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceIsTableAvailableResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceIsTableAvailableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceIsTableAvailableResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "isTableAvailable_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIsTableAvailableResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIsTableAvailableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIsTableAvailableResult(%+v)", *p)
}

// Attributes:
//   - TableName: the tablename to check
//   - SplitKeys: keys to check if the table has been created with all split keys
type THBaseServiceIsTableAvailableWithSplitArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
	SplitKeys [][]byte    `thrift:"splitKeys,2" db:"splitKeys" json:"splitKeys"`
}

func NewTHBaseServiceIsTableAvailableWithSplitArgs() *THBaseServiceIsTableAvailableWithSplitArgs {
	return &THBaseServiceIsTableAvailableWithSplitArgs{}
}

var THBaseServiceIsTableAvailableWithSplitArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceIsTableAvailableWithSplitArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceIsTableAvailableWithSplitArgs_TableName_DEFAULT
	}
	return p.TableName
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) GetSplitKeys() [][]byte {
	return p.SplitKeys
}
func (p *THBaseServiceIsTableAvailableWithSplitArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTableName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([][]byte, 0, size)
	p.SplitKeys = tSlice
	for i := 0; i < size; i++ {
		var _elem303 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem303 = v
		}
		p.SplitKeys = append(p.SplitKeys, _elem303)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "isTableAvailableWithSplit_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "splitKeys", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:splitKeys: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.SplitKeys)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.SplitKeys {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:splitKeys: ", p), err)
	}
	return err
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIsTableAvailableWithSplitArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceIsTableAvailableWithSplitResult struct {
	Success *bool     `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceIsTableAvailableWithSplitResult() *THBaseServiceIsTableAvailableWithSplitResult {
	return &THBaseServiceIsTableAvailableWithSplitResult{}
}

var THBaseServiceIsTableAvailableWithSplitResult_Success_DEFAULT bool

func (p *THBaseServiceIsTableAvailableWithSplitResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return THBaseServiceIsTableAvailableWithSplitResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceIsTableAvailableWithSplitResult_Io_DEFAULT *TIOError

func (p *THBaseServiceIsTableAvailableWithSplitResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceIsTableAvailableWithSplitResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceIsTableAvailableWithSplitResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "isTableAvailableWithSplit_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIsTableAvailableWithSplitResult(%+v)", *p)
}

// Attributes:
//   - TableName: the tablename to add column family to
//   - Column: column family descriptor of column family to be added
type THBaseServiceAddColumnFamilyArgs struct {
	TableName *TTableName              `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
	Column    *TColumnFamilyDescriptor `thrift:"column,2,required" db:"column" json:"column"`
}

func NewTHBaseServiceAddColumnFamilyArgs() *THBaseServiceAddColumnFamilyArgs {
	return &THBaseServiceAddColumnFamilyArgs{}
}

var THBaseServiceAddColumnFamilyArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceAddColumnFamilyArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceAddColumnFamilyArgs_TableName_DEFAULT
	}
	return p.TableName
}

var THBaseServiceAddColumnFamilyArgs_Column_DEFAULT *TColumnFamilyDescriptor

func (p *THBaseServiceAddColumnFamilyArgs) GetColumn() *TColumnFamilyDescriptor {
	if !p.IsSetColumn() {
		return THBaseServiceAddColumnFamilyArgs_Column_DEFAULT
	}
	return p.Column
}
func (p *THBaseServiceAddColumnFamilyArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceAddColumnFamilyArgs) IsSetColumn() bool {
	return p.Column != nil
}

func (p *THBaseServiceAddColumnFamilyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false
	var issetColumn bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTableName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetColumn = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	if !issetColumn {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Column is not set"))
	}
	return nil
}

func (p *THBaseServiceAddColumnFamilyArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceAddColumnFamilyArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Column = &TColumnFamilyDescriptor{}
	if err := p.Column.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Column), err)
	}
	return nil
}

func (p *THBaseServiceAddColumnFamilyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "addColumnFamily_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceAddColumnFamilyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceAddColumnFamilyArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "column", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column: ", p), err)
	}
	if err := p.Column.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Column), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column: ", p), err)
	}
	return err
}

func (p *THBaseServiceAddColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceAddColumnFamilyArgs(%+v)", *p)
}

// Attributes:
//   - Io
type THBaseServiceAddColumnFamilyResult struct {
	Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceAddColumnFamilyResult() *THBaseServiceAddColumnFamilyResult {
	return &THBaseServiceAddColumnFamilyResult{}
}

var THBaseServiceAddColumnFamilyResult_Io_DEFAULT *TIOError

func (p *THBaseServiceAddColumnFamilyResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceAddColumnFamilyResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceAddColumnFamilyResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceAddColumnFamilyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceAddColumnFamilyResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceAddColumnFamilyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "addColumnFamily_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceAddColumnFamilyResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceAddColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceAddColumnFamilyResult(%+v)", *p)
}

// Attributes:
//   - TableName: the tablename to delete column family from
//   - Column: name of column family to be deleted
type THBaseServiceDeleteColumnFamilyArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
	Column    []byte      `thrift:"column,2,required" db:"column" json:"column"`
}

func NewTHBaseServiceDeleteColumnFamilyArgs() *THBaseServiceDeleteColumnFamilyArgs {
	return &THBaseServiceDeleteColumnFamilyArgs{}
}

var THBaseServiceDeleteColumnFamilyArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceDeleteColumnFamilyArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceDeleteColumnFamilyArgs_TableName_DEFAULT
	}
	return p.TableName
}

func (p *THBaseServiceDeleteColumnFamilyArgs) GetColumn() []byte {
	return p.Column
}
func (p *THBaseServiceDeleteColumnFamilyArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceDeleteColumnFamilyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false
	var issetColumn bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTableName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetColumn = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	if !issetColumn {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Column is not set"))
	}
	return nil
}

func (p *THBaseServiceDeleteColumnFamilyArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceDeleteColumnFamilyArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Column = v
	}
	return nil
}

func (p *THBaseServiceDeleteColumnFamilyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "deleteColumnFamily_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteColumnFamilyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceDeleteColumnFamilyArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "column", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Column); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.column (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column: ", p), err)
	}
	return err
}

func (p *THBaseServiceDeleteColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteColumnFamilyArgs(%+v)", *p)
}

// Attributes:
//   - Io
type THBaseServiceDeleteColumnFamilyResult struct {
	Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceDeleteColumnFamilyResult() *THBaseServiceDeleteColumnFamilyResult {
	return &THBaseServiceDeleteColumnFamilyResult{}
}

var THBaseServiceDeleteColumnFamilyResult_Io_DEFAULT *TIOError

func (p *THBaseServiceDeleteColumnFamilyResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceDeleteColumnFamilyResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceDeleteColumnFamilyResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceDeleteColumnFamilyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceDeleteColumnFamilyResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceDeleteColumnFamilyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "deleteColumnFamily_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteColumnFamilyResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceDeleteColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteColumnFamilyResult(%+v)", *p)
}

// Attributes:
//   - TableName: the tablename to modify column family
//   - Column: column family descriptor of column family to be modified
type THBaseServiceModifyColumnFamilyArgs struct {
	TableName *TTableName              `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
	Column    *TColumnFamilyDescriptor `thrift:"column,2,required" db:"column" json:"column"`
}

func NewTHBaseServiceModifyColumnFamilyArgs() *THBaseServiceModifyColumnFamilyArgs {
	return &THBaseServiceModifyColumnFamilyArgs{}
}

var THBaseServiceModifyColumnFamilyArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceModifyColumnFamilyArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceModifyColumnFamilyArgs_TableName_DEFAULT
	}
	return p.TableName
}

var THBaseServiceModifyColumnFamilyArgs_Column_DEFAULT *TColumnFamilyDescriptor

func (p *THBaseServiceModifyColumnFamilyArgs) GetColumn() *TColumnFamilyDescriptor {
	if !p.IsSetColumn() {
		return THBaseServiceModifyColumnFamilyArgs_Column_DEFAULT
	}
	return p.Column
}
func (p *THBaseServiceModifyColumnFamilyArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceModifyColumnFamilyArgs) IsSetColumn() bool {
	return p.Column != nil
}

func (p *THBaseServiceModifyColumnFamilyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false
	var issetColumn bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTableName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetColumn = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	if !issetColumn {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Column is not set"))
	}
	return nil
}

func (p *THBaseServiceModifyColumnFamilyArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceModifyColumnFamilyArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Column = &TColumnFamilyDescriptor{}
	if err := p.Column.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Column), err)
	}
	return nil
}

func (p *THBaseServiceModifyColumnFamilyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "modifyColumnFamily_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceModifyColumnFamilyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceModifyColumnFamilyArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "column", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column: ", p), err)
	}
	if err := p.Column.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Column), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column: ", p), err)
	}
	return err
}

func (p *THBaseServiceModifyColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceModifyColumnFamilyArgs(%+v)", *p)
}

// Attributes:
//   - Io
type THBaseServiceModifyColumnFamilyResult struct {
	Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceModifyColumnFamilyResult() *THBaseServiceModifyColumnFamilyResult {
	return &THBaseServiceModifyColumnFamilyResult{}
}

var THBaseServiceModifyColumnFamilyResult_Io_DEFAULT *TIOError

func (p *THBaseServiceModifyColumnFamilyResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceModifyColumnFamilyResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceModifyColumnFamilyResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceModifyColumnFamilyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceModifyColumnFamilyResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceModifyColumnFamilyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "modifyColumnFamily_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceModifyColumnFamilyResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceModifyColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceModifyColumnFamilyResult(%+v)", *p)
}

// Attributes:
//   - Desc: the descriptor of the table to modify
type THBaseServiceModifyTableArgs struct {
	Desc *TTableDescriptor `thrift:"desc,1,required" db:"desc" json:"desc"`
}

func NewTHBaseServiceModifyTableArgs() *THBaseServiceModifyTableArgs {
	return &THBaseServiceModifyTableArgs{}
}

var THBaseServiceModifyTableArgs_Desc_DEFAULT *TTableDescriptor

func (p *THBaseServiceModifyTableArgs) GetDesc() *TTableDescriptor {
	if !p.IsSetDesc() {
		return THBaseServiceModifyTableArgs_Desc_DEFAULT
	}
	return p.Desc
}
func (p *THBaseServiceModifyTableArgs) IsSetDesc() bool {
	return p.Desc != nil
}

func (p *THBaseServiceModifyTableArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetDesc bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetDesc = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetDesc {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Desc is not set"))
	}
	return nil
}

func (p *THBaseServiceModifyTableArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Desc = &TTableDescriptor{}
	if err := p.Desc.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Desc), err)
	}
	return nil
}

func (p *THBaseServiceModifyTableArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "modifyTable_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceModifyTableArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "desc", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:desc: ", p), err)
	}
	if err := p.Desc.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Desc), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:desc: ", p), err)
	}
	return err
}

func (p *THBaseServiceModifyTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceModifyTableArgs(%+v)", *p)
}

// Attributes:
//   - Io
type THBaseServiceModifyTableResult struct {
	Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceModifyTableResult() *THBaseServiceModifyTableResult {
	return &THBaseServiceModifyTableResult{}
}

var THBaseServiceModifyTableResult_Io_DEFAULT *TIOError

func (p *THBaseServiceModifyTableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceModifyTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceModifyTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceModifyTableResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceModifyTableResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceModifyTableResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "modifyTable_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceModifyTableResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceModifyTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceModifyTableResult(%+v)", *p)
}

// Attributes:
//   - NamespaceDesc: descriptor which describes the new namespace
type THBaseServiceCreateNamespaceArgs struct {
	NamespaceDesc *TNamespaceDescriptor `thrift:"namespaceDesc,1,required" db:"namespaceDesc" json:"namespaceDesc"`
}

func NewTHBaseServiceCreateNamespaceArgs() *THBaseServiceCreateNamespaceArgs {
	return &THBaseServiceCreateNamespaceArgs{}
}

var THBaseServiceCreateNamespaceArgs_NamespaceDesc_DEFAULT *TNamespaceDescriptor

func (p *THBaseServiceCreateNamespaceArgs) GetNamespaceDesc() *TNamespaceDescriptor {
	if !p.IsSetNamespaceDesc() {
		return THBaseServiceCreateNamespaceArgs_NamespaceDesc_DEFAULT
	}
	return p.NamespaceDesc
}
func (p *THBaseServiceCreateNamespaceArgs) IsSetNamespaceDesc() bool {
	return p.NamespaceDesc != nil
}

func (p *THBaseServiceCreateNamespaceArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetNamespaceDesc bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetNamespaceDesc = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetNamespaceDesc {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NamespaceDesc is not set"))
	}
	return nil
}

func (p *THBaseServiceCreateNamespaceArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.NamespaceDesc = &TNamespaceDescriptor{}
	if err := p.NamespaceDesc.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NamespaceDesc), err)
	}
	return nil
}

func (p *THBaseServiceCreateNamespaceArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createNamespace_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCreateNamespaceArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "namespaceDesc", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:namespaceDesc: ", p), err)
	}
	if err := p.NamespaceDesc.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NamespaceDesc), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:namespaceDesc: ", p), err)
	}
	return err
}

func (p *THBaseServiceCreateNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCreateNamespaceArgs(%+v)", *p)
}

// Attributes:
//   - Io
type THBaseServiceCreateNamespaceResult struct {
	Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceCreateNamespaceResult() *THBaseServiceCreateNamespaceResult {
	return &THBaseServiceCreateNamespaceResult{}
}

var THBaseServiceCreateNamespaceResult_Io_DEFAULT *TIOError

func (p *THBaseServiceCreateNamespaceResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceCreateNamespaceResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceCreateNamespaceResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceCreateNamespaceResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceCreateNamespaceResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceCreateNamespaceResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createNamespace_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCreateNamespaceResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCreateNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCreateNamespaceResult(%+v)", *p)
}

// Attributes:
//   - NamespaceDesc: descriptor which describes the new namespace
type THBaseServiceModifyNamespaceArgs struct {
	NamespaceDesc *TNamespaceDescriptor `thrift:"namespaceDesc,1,required" db:"namespaceDesc" json:"namespaceDesc"`
}

func NewTHBaseServiceModifyNamespaceArgs() *THBaseServiceModifyNamespaceArgs {
	return &THBaseServiceModifyNamespaceArgs{}
}

var THBaseServiceModifyNamespaceArgs_NamespaceDesc_DEFAULT *TNamespaceDescriptor

func (p *THBaseServiceModifyNamespaceArgs) GetNamespaceDesc() *TNamespaceDescriptor {
	if !p.IsSetNamespaceDesc() {
		return THBaseServiceModifyNamespaceArgs_NamespaceDesc_DEFAULT
	}
	return p.NamespaceDesc
}
func (p *THBaseServiceModifyNamespaceArgs) IsSetNamespaceDesc() bool {
	return p.NamespaceDesc != nil
}

func (p *THBaseServiceModifyNamespaceArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetNamespaceDesc bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetNamespaceDesc = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetNamespaceDesc {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NamespaceDesc is not set"))
	}
	return nil
}

func (p *THBaseServiceModifyNamespaceArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.NamespaceDesc = &TNamespaceDescriptor{}
	if err := p.NamespaceDesc.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NamespaceDesc), err)
	}
	return nil
}

func (p *THBaseServiceModifyNamespaceArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "modifyNamespace_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceModifyNamespaceArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "namespaceDesc", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:namespaceDesc: ", p), err)
	}
	if err := p.NamespaceDesc.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NamespaceDesc), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:namespaceDesc: ", p), err)
	}
	return err
}

func (p *THBaseServiceModifyNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceModifyNamespaceArgs(%+v)", *p)
}

// Attributes:
//   - Io
type THBaseServiceModifyNamespaceResult struct {
	Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceModifyNamespaceResult() *THBaseServiceModifyNamespaceResult {
	return &THBaseServiceModifyNamespaceResult{}
}

var THBaseServiceModifyNamespaceResult_Io_DEFAULT *TIOError

func (p *THBaseServiceModifyNamespaceResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceModifyNamespaceResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceModifyNamespaceResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceModifyNamespaceResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceModifyNamespaceResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceModifyNamespaceResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "modifyNamespace_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceModifyNamespaceResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceModifyNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceModifyNamespaceResult(%+v)", *p)
}

// Attributes:
//   - Name: namespace name
type THBaseServiceDeleteNamespaceArgs struct {
	Name string `thrift:"name,1,required" db:"name" json:"name"`
}

func NewTHBaseServiceDeleteNamespaceArgs() *THBaseServiceDeleteNamespaceArgs {
	return &THBaseServiceDeleteNamespaceArgs{}
}

func (p *THBaseServiceDeleteNamespaceArgs) GetName() string {
	return p.Name
}
func (p *THBaseServiceDeleteNamespaceArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	return nil
}

func (p *THBaseServiceDeleteNamespaceArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *THBaseServiceDeleteNamespaceArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "deleteNamespace_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteNamespaceArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *THBaseServiceDeleteNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteNamespaceArgs(%+v)", *p)
}

// Attributes:
//   - Io
type THBaseServiceDeleteNamespaceResult struct {
	Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceDeleteNamespaceResult() *THBaseServiceDeleteNamespaceResult {
	return &THBaseServiceDeleteNamespaceResult{}
}

var THBaseServiceDeleteNamespaceResult_Io_DEFAULT *TIOError

func (p *THBaseServiceDeleteNamespaceResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceDeleteNamespaceResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceDeleteNamespaceResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceDeleteNamespaceResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceDeleteNamespaceResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceDeleteNamespaceResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "deleteNamespace_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteNamespaceResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceDeleteNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteNamespaceResult(%+v)", *p)
}

// Attributes:
//   - Name: name of namespace descriptor
type THBaseServiceGetNamespaceDescriptorArgs struct {
	Name string `thrift:"name,1,required" db:"name" json:"name"`
}

func NewTHBaseServiceGetNamespaceDescriptorArgs() *THBaseServiceGetNamespaceDescriptorArgs {
	return &THBaseServiceGetNamespaceDescriptorArgs{}
}

func (p *THBaseServiceGetNamespaceDescriptorArgs) GetName() string {
	return p.Name
}
func (p *THBaseServiceGetNamespaceDescriptorArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	return nil
}

func (p *THBaseServiceGetNamespaceDescriptorArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *THBaseServiceGetNamespaceDescriptorArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getNamespaceDescriptor_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetNamespaceDescriptorArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetNamespaceDescriptorArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetNamespaceDescriptorArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceGetNamespaceDescriptorResult struct {
	Success *TNamespaceDescriptor `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError             `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetNamespaceDescriptorResult() *THBaseServiceGetNamespaceDescriptorResult {
	return &THBaseServiceGetNamespaceDescriptorResult{}
}

var THBaseServiceGetNamespaceDescriptorResult_Success_DEFAULT *TNamespaceDescriptor

func (p *THBaseServiceGetNamespaceDescriptorResult) GetSuccess() *TNamespaceDescriptor {
	if !p.IsSetSuccess() {
		return THBaseServiceGetNamespaceDescriptorResult_Success_DEFAULT
	}
	return p.Success
}

var THBaseServiceGetNamespaceDescriptorResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetNamespaceDescriptorResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetNamespaceDescriptorResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetNamespaceDescriptorResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetNamespaceDescriptorResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetNamespaceDescriptorResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetNamespaceDescriptorResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &TNamespaceDescriptor{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *THBaseServiceGetNamespaceDescriptorResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetNamespaceDescriptorResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getNamespaceDescriptor_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetNamespaceDescriptorResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetNamespaceDescriptorResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetNamespaceDescriptorResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetNamespaceDescriptorResult(%+v)", *p)
}

type THBaseServiceListNamespaceDescriptorsArgs struct {
}

func NewTHBaseServiceListNamespaceDescriptorsArgs() *THBaseServiceListNamespaceDescriptorsArgs {
	return &THBaseServiceListNamespaceDescriptorsArgs{}
}

func (p *THBaseServiceListNamespaceDescriptorsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceListNamespaceDescriptorsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "listNamespaceDescriptors_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceListNamespaceDescriptorsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceListNamespaceDescriptorsArgs(%+v)", *p)
}

// Attributes:
//   - Success
//   - Io
type THBaseServiceListNamespaceDescriptorsResult struct {
	Success []*TNamespaceDescriptor `thrift:"success,0" db:"success" json:"success,omitempty"`
	Io      *TIOError               `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceListNamespaceDescriptorsResult() *THBaseServiceListNamespaceDescriptorsResult {
	return &THBaseServiceListNamespaceDescriptorsResult{}
}

var THBaseServiceListNamespaceDescriptorsResult_Success_DEFAULT []*TNamespaceDescriptor

func (p *THBaseServiceListNamespaceDescriptorsResult) GetSuccess() []*TNamespaceDescriptor {
	return p.Success
}

var THBaseServiceListNamespaceDescriptorsResult_Io_DEFAULT *TIOError

func (p *THBaseServiceListNamespaceDescriptorsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceListNamespaceDescriptorsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceListNamespaceDescriptorsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceListNamespaceDescriptorsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceListNamespaceDescriptorsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceListNamespaceDescriptorsResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TNamespaceDescriptor, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem304 := &TNamespaceDescriptor{}
		if err := _elem304.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem304), err)
		}
		p.Success = append(p.Success, _elem304)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceListNamespaceDescriptorsResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceListNamespaceDescriptorsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "listNamespaceDescriptors_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceListNamespaceDescriptorsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceListNamespaceDescriptorsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceListNamespaceDescriptorsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceListNamespaceDescriptorsResult(%+v)", *p)
}
